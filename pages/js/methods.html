<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0"
    />
    <title>Document</title>
    <link rel="stylesheet" href="../../css/styles.css" />
    <link
      rel="stylesheet"
      href="../../css/styles-print.css"
    />
  </head>
  <body>
    <a class="print-home-link" href="../../index.html"
      >На головну</a
    >
    <h1 class="m-bottom-min center-text">Методи</h1>

    <section>
      <table>
        <thead>
          <th class="bcg-color-head">Метод</th>
          <th class="bcg-color-head">Опис</th>
          <th class="bcg-color-head">Приклад</th>
          <!-- <th>Використання</th> -->
        </thead>

        <tbody>
          <tr>
            <td class="center-text bcg-color" colspan="3">
              <b>Методи рядків</b>
            </td>
          </tr>

          <tr>
            <td>slice()</td>
            <td>
              Використовується для створення копії частини
              або всього рядка без зміни оригінального
              рядка. Він дозволяє витягувати підрядок з
              вихідного рядка, вказуючи початковий та
              кінцевий (не включаючи) індекси. <br />
              Параметр <i>endIndex</i> є
              <i>необов'язковим</i>. Якщо endIndex не
              вказаний, витягуються всі елементи до кінця
              рядка. Якщо викликати метод slice()
              <i>без аргументів</i>, він створює точну копію
              рядка і повертає її.
            </td>
            <td>
              const name = "Jacob Mercer";<br />
              name.slice(0, 4); // 'Jaco'<br />
              name.slice(3, 9); // 'ob Mer'<br />
              name.slice(0, name.length);<br />
              // 'Jacob Mercer'
            </td>
          </tr>

          <tr>
            <td>toLowerCase()</td>
            <td>
              Використовується для зміни регістру символів у
              рядку. Не змінює вихідний рядок, а повертає
              новий рядок.
            </td>
            <td>
              const message = "Welcome to Bahamas!"; <br />
              message.toLowerCase(); // "welcome to
              bahamas!"<br />
            </td>
          </tr>

          <tr>
            <td>toUpperCase()</td>
            <td>
              Використовується для зміни регістру символів у
              рядку. Не змінює вихідний рядок, а повертає
              новий рядок.
            </td>
            <td>
              const message = "Welcome to Bahamas!"; <br />
              message.toUpperCase(); // "WELCOME TO
              BAHAMAS!"
            </td>
          </tr>

          <tr>
            <td>startsWith()</td>
            <td>
              Повертає булеве значення <i>true</i> або
              <i>false</i>, залежно від того, чи відповідає
              початок рядка заданому значенню.
              <b>Чутливий до регістру</b>
            </td>
            <td>
              const str = "Hello, world!";<br />
              str.startsWith("Hello"); // true<br />
              str.startsWith("hello"); // false
            </td>
          </tr>

          <tr>
            <td>endsWith()</td>
            <td>
              Повертає булеве значення <i>true</i> або
              <i>false</i>, залежно від того, чи відповідає
              кінець рядка заданому значенню.
              <b>Чутливий до регістру</b>
            </td>
            <td>
              const str = "Hello, world!";<br />
              str.endsWith("world!"); // true
              str.endsWith("World!"); // false
            </td>
          </tr>

          <tr>
            <td>trim()</td>
            <td>
              Використовується для видалення початкових і
              кінцевих пробілів із рядка. Не змінює вихідний
              рядок, а повертає новий
            </td>
            <td>
              const input = " JavaScript is awesome! ";<br />
              input.trim(); // "JavaScript is awesome!"<br />
            </td>
          </tr>

          <tr>
            <td>indexOf()</td>
            <td>
              Використовується для пошуку першого входження
              підрядка в рядок. Повертає індекс першого
              входження (індекс першого символу) підрядка,
              якщо він знайдений або <b>-1</b>, якщо
              підрядок не виявлено.
              <b>Чутливий до регістру</b>
            </td>
            <td>
              const message = "Welcome to Bahamas!";<br />
              message.indexOf("to"); // 8<br />
              message.indexOf("To"); // -1<br />
              message.indexOf("hello"); // -1<br /><br />
              const clients = ["Poly", "Kiwi", "Poly"];<br />
              clients.indexOf("Poly"); // 0<br />
              clients.indexOf("Monkong"); // -1
            </td>
          </tr>

          <tr>
            <td>includes()</td>
            <td>
              Використовується для перевірки наявності
              підрядка у рядку. Повертає логічне значення
              <i>true</i>, якщо підрядок знайдено, і
              <i>false</i>, якщо підрядок відсутній.
              <b>Чутливий до регістру</b>.
            </td>
            <td>
              const name = 'Jacob Mercer';<br />
              name.includes('Jacob'); // true
              <br />
              name.includes('John'); // false
              <br />
              <br />
              const planets = ["Earth", "Mars"];<br />

              planets.includes("Earth"); // true<br />
              planets.includes("Jupiter"); // false
            </td>
          </tr>

          <tr>
            <td>replace()</td>
            <td>
              Використовується для заміни одного підрядка на
              інший.
              <b>Чутливий до регістру</b>
            </td>
            <td>
              const mes = "Poly is awersome";<br />
              mes.replace("Poly", "Marta"); // "Marta is
              awersome"<br />
              mes.replace("poly", "Marta"); // "Poly is
              awersome"
            </td>
          </tr>
        </tbody>

        <tbody>
          <tr>
            <td class="center-text bcg-color" colspan="3">
              <b>Методи масивів</b>
            </td>
          </tr>

          <tr>
            <td>indexOf()</td>
            <td>
              Використовується для пошуку першого входження
              підрядка в рядок. Повертає індекс першого
              входження (індекс першого символу) підрядка,
              якщо він знайдений або <b>-1</b>, якщо
              підрядок не виявлено. <br />
              <b>Чутливий до регістру</b>. <br />
              <b>Не створює новий масив</b>
            </td>
            <td>
              const message = "Welcome to Bahamas!";<br />
              message.indexOf("to"); // 8<br />
              message.indexOf("To"); // -1<br />
              message.indexOf("hello"); // -1<br /><br />
              const clients = ["Poly", "Kiwi", "Poly"];<br />
              clients.indexOf("Poly"); // 0<br />
              clients.indexOf("Monkong"); // -1
            </td>
          </tr>

          <tr>
            <td>includes()</td>
            <td>
              Використовується для перевірки наявності
              підрядка у рядку. Повертає логічне значення
              <i>true</i>, якщо підрядок знайдено, і
              <i>false</i>, якщо підрядок відсутній. <br />
              <b>Чутливий до регістру</b>. <br />
              <b>Не створює новий масив</b>
            </td>
            <td>
              const name = 'Jacob Mercer';<br />
              name.includes('Jacob'); // true
              <br />
              name.includes('John'); // false
              <br />
              <br />
              const planets = ["Earth", "Mars"];<br />

              planets.includes("Earth"); // true<br />
              planets.includes("Jupiter"); // false
            </td>
          </tr>

          <tr>
            <td>join()</td>
            <td>
              Дозволяє об'єднати елементи масиву в рядок. У
              результуючому рядку елементи будуть розділені
              символом або групою символів, зазначених у
              дужках.<br />
              <b>Не створює новий масив</b>
            </td>
            <td>
              const words = ["JavaScript", "is" ];<br />
              words.join(""); // 'JavaScriptis'<br />
              words.join(" "); // 'JavaScript is'<br />
              words.join("-"); // 'JavaScript-is'
            </td>
          </tr>

          <tr>
            <td>split()</td>
            <td>
              Дозволяє перетворити рядок на масив, розбивши
              його за вказаним роздільником у дужках
              (зворотній від join())<br />
              <b>Створює новий масив</b>
            </td>
            <td>
              const name = "Man";<br />
              const message = "Hello world";<br />
              name.split(""); // ["M", "a", "n"]<br />
              message.split(" "); // ["Hello", "world"]
            </td>
            <br />
          </tr>

          <tr>
            <td>slice()</td>
            <td>
              Повертає новий масив, що містить копію частини
              вихідного масиву, не змінюючи його. Копія
              створюється від індексу <b>begin</b> до, але
              <i>не включаючи</i> індекс <b>end</b>. <br />
              <br />
              Якщо не вказати параметри <b>begin</b> і
              <b>end</b>, буде створено повну копію
              вихідного масиву. <br />
              Якщо не вказати <b>end</b>, копіювання
              відбуватиметься від <b>begin</b> до кінця
              масиву. <br />
              Якщо значення <b>begin</b> <i>негативне</i>, а
              <b>end</b> <i>не вказано</i>, будуть
              скопійовані останні <b>begin</b> елементів
              (тобто стільки елементів з кінця, скільки
              вказано в параметрі <b>begin</b>)<br />
              <b>Створює новий масив</b>
              <br /><br />
              <div class="bcg-box">
                <p>slice(begin_position, end_position)</p>
              </div>
              <br />
            </td>
            <td>
              const planets = ["Earth", "Mars", "Venus"];<br /><br />
              planets.slice(0, 2); // ['Earth', 'Mars']<br />
              planets.slice(1, 3); // ['Mars', 'Venus']<br />
              planets.slice(); // ["Earth", "Mars", "Venus"]
              <br />
              planets.slice(1); // ["Mars", "Venus"]<br />
              planets.slice(-2); // ["Mars", "Venus"]
            </td>
          </tr>

          <tr>
            <td>splice()</td>
            <td>
              Дозволяє видаляти, додавати та замінювати
              довільну кількість елементів масиву. <br />
              <br />
              <b>Видалення</b>. Видаляє елементи від
              елементу з індексом <b>begin</b> у кількості
              <b>num</b>.<br />
              Якщо <b>num</b> не вказанний, або більший за
              кількість елементів, що йдуть після
              <b>begin</b> - видаляє усі елементи до
              кінця.<br />
              Якщо <b>begin</b> - це <i>негативне</i> число,
              - будуть видалені останні
              <b>begin</b> елементів (тобто стільки
              елементів з кінця, скільки вказано в параметрі
              <b>begin</b>)<br />
              <br />
              <b>Додавання</b>. Додає елементи
              <b>new_element_1, new_element_2, ...</b> від
              елементу з індексом <b>begin</b> (<b>num</b>
              необхідно передати як <b>0</b>).<br />
              <br />
              <b>Заміна</b>. Замінює елементи
              <b>new_element_1, new_element_2, ...</b> від
              елементу з індексом <b>begin</b> у кількості
              <b>num</b>.<br />
              <b>Не створює новий масив</b><br />

              <br />
              <div class="bcg-box">
                splice(begin_position, num, new_element_1,
                new_element_2, ...)
              </div>
            </td>
            <td>
              const array = [0, 1, 2, 3, 4];<br />
              <br />
              array.splice(2, 2); // [0, 1, 4]<br />
              array.splice(2); // [0, 1]<br />
              array.splice(-2); // [0, 1, 2]<br />
              array.splice(-2, 1); // [0, 1, 2, 4]<br />
              <br />
              <br />
              array.splice(2, 0, 11); // [0, 1, 11, 2, 3,
              4]<br />
              array.splice(2, 0, 11, 12); // [0, 1, 11, 12,
              2, 3, 4]<br />
              array.splice(-2, 0, 22); // [0, 1, 2, 22, 3,
              4]<br />
              <br />
              array.splice(2, 1, 22); // [0, 1, 22, 3, 4]<br />
              array.splice(2, 2, 22); // [0, 1, 22, 4]<br />
              array.splice(2, 2, 22, 33); // [0, 1, 22, 33,
              4]<br />
            </td>
          </tr>

          <tr>
            <td>concat()</td>
            <td>
              Використовується для об'єднання двох або
              більше масивів. Не змінює вихідні масиви.
              <br />
              Порядок аргументів методу визначає порядок
              розташування елементів у новому масиві.<br />
              <b>Створює новий масив</b>
            </td>
            <td>
              const firstArray = ["Mercury", "Venus"];
              <br />
              const secondArray = ["Mars"];<br />
              const result =
              firstArray.concat(secondArray);<br />
              result; // ["Mercury", "Venus", "Mars"];
            </td>
          </tr>

          <tr>
            <td>push()</td>
            <td>
              Використовується для <b>додавання</b> одного
              або більше елементів у <b>кінець масиву</b>.
              Елемент, що додається - записуєтсья у
              дужках.<br />
              <b>Не створює новий масив</b>
            </td>
            <td>
              const planets = ["Earth", "Mars"];<br />
              planets.push("Jupiter");<br />
              planets; // ['Earth', 'Mars', 'Jupiter']<br /><br />
              planets.push("Saturn", "Neptune");<br />
              planets; // ['Earth', 'Mars', 'Jupiter',
              "Saturn", "Neptune"]
            </td>
          </tr>

          <tr>
            <td>pop()</td>
            <td>
              Використовується для <b>видалення</b> одного
              елементу з <b>кінця масиву</b>.
              <i>У дужках нічого не вказується.</i><br />
              <b>Не створює новий масив</b>
            </td>
            <td>
              const planets = ["Earth", "Mars"];<br />
              planets.pop();<br />
              planets; // ['Earth']
            </td>
          </tr>

          <tr>
            <td>unshift()</td>
            <td>
              Використовується для <b>додавання</b> одного
              або більше елементів у <b>початок масиву</b>.
              Елемент, що додається - записуєтсья у
              дужках.<br />
              <b>Не створює новий масив</b>
            </td>
            <td>
              const planets = ["Earth", "Mars"];<br />
              planets.unshift("Venus");<br />
              planets; // ['Venus', 'Earth', 'Mars']
            </td>
          </tr>

          <tr>
            <td>shift()</td>
            <td>
              Використовується для <b>видалення</b> одного
              елементу з <b>початку масиву</b>.
              <i>У дужках нічого не вказується.</i><br />
              <b>Не створює новий масив</b>
            </td>
            <td>
              const planets = ["Earth", "Mars"];<br />
              planets.shift();<br />
              planets; // ['Mars']
            </td>
          </tr>

          <tr>
            <td>forEach(callback)</td>
            <td>
              Метод перебирання масиву, який
              використовується для заміни циклів
              <b>for</b> і <b>for...of</b> в роботі з
              колекцією. Повертає <b>undefined</b>, навіть
              якщо явно задати вираз після <b>return</b
              ><br />
              <div class="bcg-box">
                array.forEach(function callback(element,
                index, array) { // Тіло колбек-функції });
              </div>
              Не всі параметри обов’язково оголошувати, але
              дуже важлива їх послідовність. <br />
              <b>Важливо!</b> Єдиний випадок, коли варто
              використовувати цикли <i>for</i> або
              <i>for...of</i> для перебирання масиву, — це
              задачі з <i>перериванням виконання циклу</i>.
              Перервати виконання методу forEach не можна,
              він завжди перебирає масив до кінця.
            </td>
            <td>
              const numbers = [5, 10, 15, 20, 25];<br />
              <br />
              numbers.forEach(function (number, index) {<br />
              console.log(`Index ${index}, value
              ${number}`);<br />
              });
            </td>
          </tr>
          <tr>
            <td>
              <b><i>Перебираючі методи</i></b>
            </td>
            <td>
              Усі перебираючі методи масивів мають схожий
              синтаксис. На вихідному
              <b>array</b> викликається перебираючий метод
              <b>method</b>, у який аргументом передається
              колбек-функція <b>callback</b>.
              <div class="bcg-box">
                array.method(callback(currentValue, index,
                array))
              </div>
              <b>currentValue</b> - значення поточного
              елемента масиву; <br />
              <b>index</b> - індекс поточного елемента
              масиву; <br />
              <b>array</b> - посилання на сам вихідний
              масив. <br />
              <b>Корисно!</b> Усі параметри, окрім значення
              поточного елемента масиву <b>item</b>,
              <i>необов'язкові</i>.
            </td>
            <td>
              array.method((item, idx, arr) => { <br />
              тіло <br />
              });
            </td>
          </tr>
          <tr>
            <td>map()</td>
            <td>
              <i>Метод перебору.</i> Трансформує масив.
              Викликає колбек-функцію для кожного елемента
              вихідного масиву, а результат її роботи
              записує в <b>новий масив</b>. <br />
              - Поелементно перебирає оригінальний масив;<br />
              - Не змінює оригінальний масив;<br />
              - Результат роботи колбек-функції записується
              в новий масив;<br />
              - Повертає новий масив такої ж довжини, як і в
              масиві, до якого він був застосований.
            </td>
            <td>
              const students = [<br />
              { name: "Mango", score: 83 },<br />
              { name: "Poly", score: 59 },<br />
              ];<br />
              <br />
              const names = students.map(student =>
              student.name);<br />
              console.log(names); // ["Mango", "Poly"]
            </td>
          </tr>
          <tr>
            <td>flatMap()</td>
            <td>
              <i>Метод перебору.</i> Аналогічний методу
              <b>map()</b>, але застосовується у випадках,
              коли результат — це багатовимірний масив, який
              необхідно «<i>розгладити</i>» (вийняти
              елементи із вкладеного масиву). <br />
              Новий масив <i>«розгладжується»</i> на
              глибину, що дорівнює одиниці (одна
              вкладеність).
            </td>
            <td>
              const students = [<br />
              { name: "Mango", courses: ["mathematics",
              "physics"] },<br />
              { name: "Poly", courses: ["science",
              "mathematics"] },<br />
              ];<br />
              const mappedCourses = students.map(student =>
              student.courses);<br />
              // [["mathematics", "physics"], ["science",
              "mathematics"]]<br />
              const flattenedCourses =
              students.flatMap(student =>
              student.courses);<br />
              // ["mathematics", "physics", "science",
              "mathematics"];
            </td>
          </tr>
          <tr>
            <td>filter()</td>
            <td>
              <i>Метод перебору.</i> Викликає колбек-функцію
              для кожного елемента вихідного масиву. Якщо
              результат її виконання <b>true</b>, поточний
              елемент додається в новий масив.
            </td>
            <td>
              const values = [51, -3, 27, -68];<br />
              <br />
              const positiveValues = values.filter(value =>
              value >= 0);<br />
              // [51, 27]<br />
              <br />

              const HIGH_SCORE = 80;<br />
              const students = [<br />
              { name: 'Mango', score: 83 },<br />
              { name: 'Poly', score: 59 },<br />
              { name: 'Kiwi', score: 94 },<br />
              ];<br />
              <br />
              const best = students.filter(student =>
              student.score >= HIGH_SCORE);<br />
              console.log(best);<br />
              <br />
              [<br />
              { name: 'Mango', score: 83 },<br />
              { name: 'Kiwi', score: 94 },<br />
              ];
            </td>
          </tr>
          <tr>
            <td>find()</td>
            <td>
              <i>Метод перебору.</i> Дозволяє знайти і
              повернути <b>перший</b> відповідний елемент,
              що задовольняє умову, після чого перебирання
              масиву припиняється. Тобто він, на відміну від
              методу <b>filter(callback)</b>, шукає до
              першого збігу.
            </td>
            <td>
              const color = [<br />
              { label: "red", color: "#F44336" },<br />
              { label: "blue", color: "#2196F3" },<br />
              ];<br />
              <br />
              color.find((option) => option.label ===
              "blue"); <br />
              // { label: "blue", color: "#2196F3" }
            </td>
          </tr>
          <tr>
            <td>every()</td>
            <td>
              <i>Метод перебору.</i> Перевіряє, чи
              задовольняють усі елементи умову
              колбек-функції. <br />
              <br />
              - Повертає <b>true</b>, якщо
              <b>всі</b> елементи масиву задовольняють
              умову;<br />
              - Повертає <b>false</b>, якщо хоча б один
              елемент масиву не задовольняє умову;<br />
              - Перебирання масиву припиняється, якщо колбек
              повертає <b>false</b>.
            </td>
            <td>
              [1, 2, 3].every((value) =><br />
              value >= 0);<br />
              // true<br />
              <br />
              [1, 2, -10].every((value) =><br />
              value >= 0);<br />
              // false
            </td>
          </tr>
          <tr>
            <td>some()</td>
            <td>
              <i>Метод перебору.</i> Перевіряє, чи
              задовольняє хоча б <b>один</b> елемент умову
              колбек-функції.<br />
              <br />
              - Повертає <b>true</b>, якщо хоча б один
              елемент масиву задовольняє умову;<br />
              - Повертає <b>false</b>, якщо жоден елемент
              масиву не задовольняє умову;<br />
              - Перебирання масиву припиняється, якщо колбек
              повертає <b>true</b>.<br />
            </td>
            <td>
              [-7, -20, 3].some(value =><br />
              value >= 0);<br />
              <br />
              // true [1, 2, 3].some(value =><br />
              value < 0);<br />
              // false
            </td>
          </tr>
          <tr>
            <td>reduce()</td>
            <td>
              <i>Метод перебору.</i> Використовується для
              послідовної обробки кожного елемента масиву із
              <b>збереженням</b> проміжного результату.<br />
              <div class="bcg-box">
                array.reduce((previousValue, element, index,
                array) => { Тіло колбек-функції },
                initialValue);
              </div>
              <b>previousValue</b> — це акумулятор, тобто
              проміжний результат. Значення, яке поверне
              колбек-функція на поточній ітерації, буде
              значенням цього параметра на наступній
              ітерації;<br />
              <b>element</b> — поточний елемент масиву;<br />
              <b>index</b> — індекс поточної ітерації;<br />
              <b>array</b> — посилання на вихідний масив;<br />
              <b>initialValue</b> — початкове значення
              акумулятора (<i>не обов’язковий</i>).<br />
              <b>Цікаво!</b> У повсякденних завданнях його
              застосування зводиться до роботи з числами.
            </td>
            <td>
              const total = [2, 7, 3].reduce((previousValue,
              number) => {<br />
              return previousValue + number;<br />
              }, 0);<br />
              <br />
              console.log(total); // 12
            </td>
          </tr>
          <tr>
            <td>toSorted()</td>
            <td>
              Сортує елементи масиву.<br />
              - Сортує вихідний масив;<br />
              - Повертає новий масив;<br />
              - За замовчуванням сортує за зростанням.
            </td>
            <td>
              const scores = [61, 19, 74];<br />
              const ascendingScores = scores.toSorted();<br />
              // [19, 61, 74]<br />
              <br />
              const letters = ["b", "B", "a", "A"]; <br />
              // ["A", "B", "a", "b"]
            </td>
          </tr>
        </tbody>

        <tbody>
          <tr>
            <td class="center-text bcg-color" colspan="3">
              <b>Методи об'єктів</b>
            </td>
          </tr>

          <tr>
            <td>Object.keys()</td>
            <td>
              Приймає об'єкт і повертає масив ключів його
              властивостей. Якщо в об'єкті немає
              властивостей, метод поверне порожній масив.
            </td>
            <td>
              const book = {<br />
              title: "The Last Kingdom",<br />
              author: "Bernard Cornwell",<br />
              };<br />
              <br />
              const keys = Object.keys(book);<br />
              console.log(keys); // ['title', 'author']
            </td>
          </tr>

          <tr>
            <td>Object.values()</td>
            <td>
              Приймає об'єкт і повертає масив значень
              властивостей. Якщо в об'єкті немає
              властивостей, метод поверне порожній масив.
            </td>
            <td>
              const book = {<br />
              title: "The Last Kingdom",<br />
              author: "Bernard Cornwell",<br />
              rating: 8.38,<br />
              };<br />
              <br />
              const values = Object.values(book);<br />
              console.log(values); // ["The Last Kingdom",
              "Bernard Cornwell", 8.38]
            </td>
          </tr>

          <!-- <tr>
            <td></td>
            <td></td>
            <td></td>
          </tr> -->

          <!-- <tr>
            <td></td>
            <td></td>
            <td></td>
          </tr> -->
        </tbody>
      </table>
    </section>
  </body>
</html>
