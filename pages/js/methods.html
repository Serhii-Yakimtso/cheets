<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0"
    />
    <title>Document</title>
    <link rel="stylesheet" href="../../css/styles.css" />
    <link
      rel="stylesheet"
      href="../../css/styles-print.css"
    />
  </head>
  <body>
    <a class="print-home-link" href="../../index.html"
      >На головну</a
    >
    <h1 class="m-bottom-min center-text">Методи</h1>

    <section>
      <table class="print-m-bottom-max">
        <caption>
          Методи рядків
        </caption>
        <thead>
          <th class="bcg-color-head">Метод</th>
          <th class="bcg-color-head">Опис</th>
          <th class="bcg-color-head">Приклад</th>
        </thead>

        <tbody>
          <tr>
            <td>slice()</td>
            <td>
              Використовується для створення копії частини
              або всього рядка без зміни оригінального
              рядка. Він дозволяє витягувати підрядок з
              вихідного рядка, вказуючи початковий та
              кінцевий (не включаючи) індекси. <br />
              Параметр <i>endIndex</i> є
              <i>необов'язковим</i>. Якщо endIndex не
              вказаний, витягуються всі елементи до кінця
              рядка. Якщо викликати метод slice()
              <i>без аргументів</i>, він створює точну копію
              рядка і повертає її.
            </td>
            <td>
              const name = "Jacob Mercer";<br />
              name.slice(0, 4); // 'Jaco'<br />
              name.slice(3, 9); // 'ob Mer'<br />
              name.slice(0, name.length);<br />
              // 'Jacob Mercer'
            </td>
          </tr>

          <tr>
            <td>toLowerCase()</td>
            <td>
              Використовується для зміни регістру символів у
              рядку. Не змінює вихідний рядок, а повертає
              новий рядок.
            </td>
            <td>
              const message = "Welcome to Bahamas!"; <br />
              message.toLowerCase(); // "welcome to
              bahamas!"<br />
            </td>
          </tr>

          <tr>
            <td>toUpperCase()</td>
            <td>
              Використовується для зміни регістру символів у
              рядку. Не змінює вихідний рядок, а повертає
              новий рядок.
            </td>
            <td>
              const message = "Welcome to Bahamas!"; <br />
              message.toUpperCase(); // "WELCOME TO
              BAHAMAS!"
            </td>
          </tr>

          <tr>
            <td>startsWith()</td>
            <td>
              Повертає булеве значення <i>true</i> або
              <i>false</i>, залежно від того, чи відповідає
              початок рядка заданому значенню.
              <b>Чутливий до регістру</b>
            </td>
            <td>
              const str = "Hello, world!";<br />
              str.startsWith("Hello"); // true<br />
              str.startsWith("hello"); // false
            </td>
          </tr>

          <tr>
            <td>endsWith()</td>
            <td>
              Повертає булеве значення <i>true</i> або
              <i>false</i>, залежно від того, чи відповідає
              кінець рядка заданому значенню.
              <b>Чутливий до регістру</b>
            </td>
            <td>
              const str = "Hello, world!";<br />
              str.endsWith("world!"); // true
              str.endsWith("World!"); // false
            </td>
          </tr>

          <tr>
            <td>trim()</td>
            <td>
              Використовується для видалення початкових і
              кінцевих пробілів із рядка. Не змінює вихідний
              рядок, а повертає новий
            </td>
            <td>
              const input = " JavaScript ";<br />
              input.trim(); // "JavaScript "<br />
            </td>
          </tr>

          <tr>
            <td>indexOf()</td>
            <td>
              Використовується для пошуку першого входження
              підрядка в рядок. Повертає індекс першого
              входження (індекс першого символу) підрядка,
              якщо він знайдений або <b>-1</b>, якщо
              підрядок не виявлено.
              <b>Чутливий до регістру</b>
            </td>
            <td>
              const message = "Welcome to Bahamas!";<br />
              message.indexOf("to"); // 8<br />
              message.indexOf("To"); // -1<br />
              message.indexOf("hello"); // -1<br />
              const clients = ["Poly", "Kiwi", "Poly"];<br />
              clients.indexOf("Poly"); // 0<br />
              clients.indexOf("Monkong"); // -1
            </td>
          </tr>

          <tr>
            <td>includes()</td>
            <td>
              Використовується для перевірки наявності
              підрядка у рядку. Повертає логічне значення
              <i>true</i>, якщо підрядок знайдено, і
              <i>false</i>, якщо підрядок відсутній.
              <b>Чутливий до регістру</b>.
            </td>
            <td>
              const name = 'Jacob Mercer';<br />
              name.includes('Jacob'); // true
              <br />
              name.includes('John'); // false
              <br />
              const planets = ["Earth", "Mars"];<br />

              planets.includes("Earth"); // true<br />
              planets.includes("Jupiter"); // false
            </td>
          </tr>

          <tr>
            <td>replace()</td>
            <td>
              Використовується для заміни одного підрядка на
              інший.
              <b>Чутливий до регістру</b>
            </td>
            <td>
              const mes = "Poly is awersome";<br />
              mes.replace("Poly", "Marta"); // "Marta is
              awersome"<br />
              mes.replace("poly", "Marta"); // "Poly is
              awersome"
            </td>
          </tr>
        </tbody>
      </table>

      <table class="print-m-bottom-max">
        <caption>
          Методи масивів
        </caption>
        <thead>
          <th class="bcg-color-head">Метод</th>
          <th class="bcg-color-head">Опис</th>
          <th class="bcg-color-head" style="width: 240px">
            Приклад
          </th>
        </thead>

        <tbody>
          <tr>
            <td>indexOf()</td>
            <td>
              Використовується для пошуку першого входження
              підрядка в рядок. Повертає індекс першого
              входження (індекс першого символу) підрядка,
              якщо він знайдений або <b>-1</b>, якщо
              підрядок не виявлено. <br />
              <b>Чутливий до регістру</b>. <br />
              <b>Не створює новий масив</b>
            </td>
            <td>
              const message = "Welcome to Bahamas!";<br />
              message.indexOf("to"); // 8<br />
              message.indexOf("To"); // -1<br />
              message.indexOf("hello"); // -1<br /><br />
              const clients = ["Poly", "Kiwi", "Poly"];<br />
              clients.indexOf("Poly"); // 0<br />
              clients.indexOf("Monkong"); // -1
            </td>
          </tr>

          <tr>
            <td>includes()</td>
            <td>
              Використовується для перевірки наявності
              підрядка у рядку. Повертає логічне значення
              <i>true</i>, якщо підрядок знайдено, і
              <i>false</i>, якщо підрядок відсутній. <br />
              <b>Чутливий до регістру</b>. <br />
              <b>Не створює новий масив</b>
            </td>
            <td>
              const name = 'Jacob Mercer';<br />
              name.includes('Jacob'); // true
              <br />
              name.includes('John'); // false
              <br />
              <br />
              const planets = ["Earth", "Mars"];<br />

              planets.includes("Earth"); // true<br />
              planets.includes("Jupiter"); // false
            </td>
          </tr>

          <tr>
            <td>join()</td>
            <td>
              Дозволяє об'єднати елементи масиву в рядок. У
              результуючому рядку елементи будуть розділені
              символом або групою символів, зазначених у
              дужках.<br />
              <b>Не створює новий масив</b>
            </td>
            <td>
              const words = ["JavaScript", "is" ];<br />
              words.join(""); // 'JavaScriptis'<br />
              words.join(" "); // 'JavaScript is'<br />
              words.join("-"); // 'JavaScript-is'
            </td>
          </tr>

          <tr>
            <td>split()</td>
            <td>
              Дозволяє перетворити рядок на масив, розбивши
              його за вказаним роздільником у дужках
              (зворотній від join())<br />
              <b>Створює новий масив</b>
            </td>
            <td>
              const name = "Man";<br />
              const message = "Hello world";<br />
              name.split(""); // ["M", "a", "n"]<br />
              message.split(" "); // ["Hello", "world"]
            </td>
            <br />
          </tr>

          <tr>
            <td>splice()</td>
            <td>
              Дозволяє видаляти, додавати та замінювати
              довільну кількість елементів масиву. <br />
              <br />
              <b>Видалення</b>. Видаляє елементи від
              елементу з індексом <b>begin</b> у кількості
              <b>num</b>.<br />
              Якщо <b>num</b> не вказанний, або більший за
              кількість елементів, що йдуть після
              <b>begin</b> - видаляє усі елементи до
              кінця.<br />
              Якщо <b>begin</b> - це <i>негативне</i> число,
              - видаляться останні <b>begin</b> елементів
              (стільки елементів з кінця, скільки вказано в
              параметрі <b>begin</b>)<br />
              <br />
              <b>Додавання</b>. Додає елементи
              <b>new_element_1, new_element_2, ...</b> від
              елементу з індексом <b>begin</b> (<b>num</b>
              необхідно передати як <b>0</b>).<br />
              <br />
              <b>Заміна</b>. Замінює елементи
              <b>new_element_1, new_element_2, ...</b> від
              елементу з індексом <b>begin</b> у кількості
              <b>num</b>.<br />
              <b>Не створює новий масив</b><br />

              <div class="bcg-box">
                splice(begin_position, num, new_element_1,
                new_element_2, ...)
              </div>
            </td>
            <td>
              const array = [0, 1, 2, 3, 4];<br />
              <br />
              array.splice(2, 2); // [0, 1, 4]<br />
              array.splice(2); // [0, 1]<br />
              array.splice(-2); // [0, 1, 2]<br />
              array.splice(-2, 1); // [0, 1, 2, 4]<br />
              <br />
              <br />
              array.splice(2, 0, 11); // [0, 1, 11, 2, 3,
              4]<br />
              array.splice(2, 0, 11, 12); // [0, 1, 11, 12,
              2, 3, 4]<br />
              array.splice(-2, 0, 22); // [0, 1, 2, 22, 3,
              4]<br />
              <br />
              array.splice(2, 1, 22); // [0, 1, 22, 3, 4]<br />
              array.splice(2, 2, 22); // [0, 1, 22, 4]<br />
              array.splice(2, 2, 22, 33); // [0, 1, 22, 33,
              4]<br />
            </td>
          </tr>

          <tr>
            <td>slice()</td>
            <td>
              Повертає <b>новий масив</b>, що містить копію
              частини вихідного масиву, не змінюючи його.
              Копія створюється від індексу <b>begin</b> до,
              але <i>не включаючи</i> індекс <b>end</b>.
              <br />
              <br />
              Якщо не вказати параметри <b>begin</b> і
              <b>end</b>, буде створено повну копію
              вихідного масиву. <br />
              Якщо не вказати <b>end</b>, копіювання
              відбуватиметься від <b>begin</b> до кінця
              масиву. <br />
              Якщо значення <b>begin</b> <i>негативне</i>, а
              <b>end</b> <i>не вказано</i>, будуть
              скопійовані останні <b>begin</b> елементів
              (тобто стільки елементів з кінця, скільки
              вказано в параметрі <b>begin</b>)<br />
              <b>Створює новий масив</b>
              <br /><br />
              <div class="bcg-box">
                <p>slice(begin_position, end_position)</p>
              </div>
            </td>
            <td>
              const planets = ["Earth", "Mars", "Venus"];<br /><br />
              planets.slice(0, 2); // ['Earth', 'Mars']<br />
              planets.slice(1, 3); // ['Mars', 'Venus']<br />
              planets.slice(); // ["Earth", "Mars", "Venus"]
              <br />
              planets.slice(1); // ["Mars", "Venus"]<br />
              planets.slice(-2); // ["Mars", "Venus"]
            </td>
          </tr>

          <tr>
            <td>concat()</td>
            <td>
              Використовується для об'єднання двох або
              більше масивів. Не змінює вихідні масиви.
              <br />
              Порядок аргументів методу визначає порядок
              розташування елементів у новому масиві.<br />
              <b>Створює новий масив</b>
            </td>
            <td>
              const firstArray = ["Mercury", "Venus"];
              <br />
              const secondArray = ["Mars"];<br />
              const result =
              firstArray.concat(secondArray);<br />
              result; // ["Mercury", "Venus", "Mars"];
            </td>
          </tr>

          <tr>
            <td>push()</td>
            <td>
              Використовується для <b>додавання</b> одного
              або більше елементів у <b>кінець масиву</b>.
              Елемент, що додається - записуєтсья у
              дужках.<br />
              <b>Не створює новий масив</b>
            </td>
            <td>
              const planets = ["Earth", "Mars"];<br />
              planets.push("Jupiter");<br />
              planets; // ['Earth', 'Mars', 'Jupiter']<br /><br />
              planets.push("Saturn", "Neptune");<br />
              planets; // ['Earth', 'Mars', 'Jupiter',
              "Saturn", "Neptune"]
            </td>
          </tr>

          <tr>
            <td>pop()</td>
            <td>
              Використовується для <b>видалення</b> одного
              елементу з <b>кінця масиву</b>.
              <i>У дужках нічого не вказується.</i><br />
              <b>Не створює новий масив</b>
            </td>
            <td>
              const planets = ["Earth", "Mars"];<br />
              planets.pop();<br />
              planets; // ['Earth']
            </td>
          </tr>

          <tr>
            <td>unshift()</td>
            <td>
              Використовується для <b>додавання</b> одного
              або більше елементів у <b>початок масиву</b>.
              Елемент, що додається - записуєтсья у
              дужках.<br />
              <b>Не створює новий масив</b>
            </td>
            <td>
              const planets = ["Earth", "Mars"];<br />
              planets.unshift("Venus");<br />
              planets; // ['Venus', 'Earth', 'Mars']
            </td>
          </tr>

          <tr>
            <td>
              shift()
              <br /><br /><br /><br /><br /><br /><br /><br /><br /><br />
            </td>
            <td>
              Використовується для <b>видалення</b> одного
              елементу з <b>початку масиву</b>.
              <i>У дужках нічого не вказується.</i><br />
              <b>Не створює новий масив</b
              ><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />
            </td>
            <td>
              const planets = ["Earth", "Mars"];<br />
              planets.shift();<br />
              planets; // ['Mars']
              <br /><br /><br /><br /><br /><br /><br /><br /><br />
            </td>
          </tr>

          <tr>
            <td>forEach(callback)</td>
            <td>
              Метод перебирання масиву, який
              використовується для заміни циклів
              <b>for</b> і <b>for...of</b> в роботі з
              колекцією. Повертає <b>undefined</b>, навіть
              якщо явно задати вираз після <b>return</b
              ><br />
              <div class="bcg-box">
                array.forEach(function callback(element,
                index, array) { // Тіло колбек-функції });
              </div>
              Не всі параметри обов’язково оголошувати, але
              дуже важлива їх послідовність. <br />
              <b>Важливо!</b> Єдиний випадок, коли варто
              використовувати цикли <i>for</i> або
              <i>for...of</i> для перебирання масиву, — це
              задачі з <i>перериванням виконання циклу</i>.
              Перервати виконання методу forEach не можна,
              він завжди перебирає масив до кінця.
            </td>
            <td>
              const numbers = [5, 10, 15, 20, 25];<br />
              <br />
              numbers.forEach(function (number, index) {<br />
              console.log(`Index ${index}, value
              ${number}`);<br />
              });
            </td>
          </tr>

          <tr>
            <td>
              <b><i>Перебираючі методи</i></b>
            </td>
            <td>
              Усі перебираючі методи масивів мають схожий
              синтаксис. На вихідному
              <b>array</b> викликається перебираючий метод
              <b>method</b>, у який аргументом передається
              колбек-функція <b>callback</b>.
              <div class="bcg-box">
                array.method(callback(currentValue, index,
                array))
              </div>
              <b>currentValue</b> - значення поточного
              елемента масиву; <br />
              <b>index</b> - індекс поточного елемента
              масиву; <br />
              <b>array</b> - посилання на сам вихідний
              масив. <br />
              <b>Корисно!</b> Усі параметри, окрім значення
              поточного елемента масиву <b>item</b>,
              <i>необов'язкові</i>.
            </td>
            <td>
              array.method((item, idx, arr) => { <br />
              тіло <br />
              });
            </td>
          </tr>

          <tr>
            <td>map()</td>
            <td>
              <i>Метод перебору.</i> Трансформує масив.
              Викликає колбек-функцію для кожного елемента
              вихідного масиву, а результат її роботи
              записує в <b>новий масив</b>. <br />
              - Поелементно перебирає оригінальний масив;<br />
              - Не змінює оригінальний масив;<br />
              - Повертає <b>новий масив</b> такої ж довжини,
              як і в масиві, до якого він був застосований.
            </td>
            <td>
              const students = [<br />
              { name: "Mango", score: 83 },<br />
              { name: "Poly", score: 59 },<br />
              ];<br />
              const names = students.map(student =>
              student.name);<br />
              console.log(names); // ["Mango", "Poly"]
            </td>
          </tr>

          <tr>
            <td>flatMap()</td>
            <td>
              <i>Метод перебору.</i> Аналогічний методу
              <b>map()</b>, але застосовується у випадках,
              коли результат — це багатовимірний масив, який
              необхідно «<i>розгладити</i>» (вийняти
              елементи із вкладеного масиву). <br />
              Новий масив <i>«розгладжується»</i> на
              глибину, що дорівнює одиниці (одна
              вкладеність).
            </td>
            <td>
              const students = [<br />
              { name: "Mango", courses: ["mathematics",
              "physics"] },<br />
              { name: "Poly", courses: ["science",
              "mathematics"] },<br />
              ];<br />
              const mappedCourses = students.map(student =>
              student.courses);<br />
              // [["mathematics", "physics"], ["science",
              "mathematics"]]<br />
              const flattenedCourses =
              students.flatMap(student =>
              student.courses);<br />
              // ["mathematics", "physics", "science",
              "mathematics"];
            </td>
          </tr>

          <tr>
            <td>filter()</td>
            <td>
              <i>Метод перебору.</i> Викликає колбек-функцію
              для кожного елемента вихідного масиву. Якщо
              результат її виконання <b>true</b>, поточний
              елемент додається в новий масив.
            </td>
            <td>
              const values = [51, -3, 27, -68];<br />
              <br />
              const positiveValues = values.filter(value =>
              value >= 0);<br />
              // [51, 27]<br />
              <br />

              const HIGH_SCORE = 80;<br />
              const students = [<br />
              { name: 'Mango', score: 83 },<br />
              { name: 'Poly', score: 59 },<br />
              { name: 'Kiwi', score: 94 },<br />
              ];<br />
              <br />
              const best = students.filter(student =>
              student.score >= HIGH_SCORE);<br />
              console.log(best);<br />
              <br />
              [<br />
              { name: 'Mango', score: 83 },<br />
              { name: 'Kiwi', score: 94 },<br />
              ];<br /><br />
            </td>
          </tr>

          <tr>
            <td>find()</td>
            <td>
              <i>Метод перебору.</i> Дозволяє знайти і
              повернути <b>перший</b> відповідний елемент,
              що задовольняє умову, після чого перебирання
              масиву припиняється. Тобто він, на відміну від
              методу <b>filter(callback)</b>, шукає до
              першого збігу.
            </td>
            <td>
              const color = [<br />
              { label: "red", color: "#F44336" },<br />
              { label: "blue", color: "#2196F3" },<br />
              ];<br />
              <br />
              color.find((option) => option.label ===
              "blue"); <br />
              // { label: "blue", color: "#2196F3" }<br /><br />
            </td>
          </tr>

          <tr>
            <td>every()</td>
            <td>
              <i>Метод перебору.</i> Перевіряє, чи
              задовольняють усі елементи умову
              колбек-функції. <br />
              <br />
              - Повертає <b>true</b>, якщо
              <b>всі</b> елементи масиву задовольняють
              умову;<br />
              - Повертає <b>false</b>, якщо хоча б один
              елемент масиву не задовольняє умову;<br />
              - Перебирання масиву припиняється, якщо колбек
              повертає <b>false</b>.<br /><br />
            </td>
            <td>
              [1, 2, 3].every((value) =><br />
              value >= 0);<br />
              // true<br />
              <br />
              [1, 2, -10].every((value) =><br />
              value >= 0);<br />
              // false
            </td>
          </tr>

          <tr>
            <td>some()</td>
            <td>
              <i>Метод перебору.</i> Перевіряє, чи
              задовольняє хоча б <b>один</b> елемент умову
              колбек-функції.<br />
              <br />
              - Повертає <b>true</b>, якщо хоча б один
              елемент масиву задовольняє умову;<br />
              - Повертає <b>false</b>, якщо жоден елемент
              масиву не задовольняє умову;<br />
              - Перебирання масиву припиняється, якщо колбек
              повертає <b>true</b>.<br /><br />
            </td>
            <td>
              [-7, -20, 3].some(value =><br />
              value >= 0);<br />
              <br />
              // true [1, 2, 3].some(value =><br />
              value < 0);<br />
              // false
            </td>
          </tr>

          <tr>
            <td>reduce()</td>
            <td>
              <i>Метод перебору.</i> Використовується для
              послідовної обробки кожного елемента масиву із
              <b>збереженням</b> проміжного результату.<br />
              <div class="bcg-box">
                array.reduce((previousValue, element, index,
                array) => { Тіло колбек-функції },
                initialValue);
              </div>
              <b>previousValue</b> — це акумулятор, тобто
              проміжний результат. Значення, яке поверне
              колбек-функція на поточній ітерації, буде
              значенням цього параметра на наступній
              ітерації;<br />
              <b>element</b> — поточний елемент масиву;<br />
              <b>index</b> — індекс поточної ітерації;<br />
              <b>array</b> — посилання на вихідний масив;<br />
              <b>initialValue</b> — початкове значення
              акумулятора (<i>не обов’язковий</i>).<br />
              <b>Цікаво!</b> У повсякденних завданнях його
              застосування зводиться до роботи з числами.
            </td>
            <td>
              const total = [2, 7, 3].reduce((previousValue,
              number) => {<br />
              return previousValue + number;<br />
              }, 0);<br />
              <br />
              console.log(total); // 12
            </td>
          </tr>

          <tr>
            <td rowspan="3">toSorted()</td>
            <td>
              Сортує елементи масиву.<br />
              - Сортує вихідний масив;<br />
              - Повертає <b>новий масив</b>;<br />
              - За замовчуванням сортує за зростанням.
            </td>
            <td>
              const scores = [61, 19, 74];<br />
              scores.toSorted(); // [19, 61, 74]<br />
              <br />
              const letters = ["b", "B", "a", "A"]; <br />
              letters.toSorted(); // ["A", "B", "a", "b"]
            </td>
          </tr>
          <tr>
            <td>
              Для зазначення
              <b>свого порядку сортування чисел</b> потрібно
              передати <i>колбек-функцію</i> з двома
              параметрами. <br />
              <div class="bcg-box">
                <p>
                  array.toSorted((a, b) => { // Callback
                  function body });
                </p>
              </div>
              - <b>a</b> — перший елемент для порівняння.
              <br />
              - <b>b</b> — другий елемент для порівняння.<br />
              При сортуванні масиву чисел і передачі в метод
              toSorted() колбек-функції, числа не будуть
              приводитися до рядків.
            </td>
            <td>
              const scores = [61, 19, 92 ];<br />
              <b>// за зростанням</b><br />
              const s = scores.toSorted((a, b) => a - b);<br />
              console.log(s); // [19, 61, 92]<br />
              <b>// за спаданням</b><br />
              const s = scores.toSorted((a, b) => b - a);<br />
              console.log(s); // [92, 61, 19]
            </td>
          </tr>
          <tr>
            <td>
              Для зазначення
              <b>свого порядку сортування рядків</b>
              використовується метод рядків
              <b>localeCompare()</b> у
              <i>тілі колбек-функції</i>.
              <br />
              <div class="bcg-box">
                <p>
                  firstString.localeCompare(secondString)
                </p>
              </div>
              - <b>firstString</b> — рядок, який потрібно
              порівняти.
              <br />
              - <b>secondString</b> — рядок, з яким
              порівнюється.<br />
            </td>
            <td>
              const men = ["Jacob", <br />"Artemis",
              "Solomon"];<br />
              <br />
              const s = men.toSorted((a, b) <br />
              => a.localeCompare(b));<br />
              console.log(s); // [ "Artemis", "Jacob",
              "Solomon" ]<br />
              <br />
              const s = men.toSorted((a, b) <br />
              => b.localeCompare(a));<br />
              console.log(s); // [ "Solomon", "Jacob",
              "Artemis" ]<br />
            </td>
          </tr>

          <tr>
            <td>sort()</td>
            <td>
              Сортує елементи масиву.<br />
              - Сортує вихідний масив;<br />
              - Повертає <b>старий масив</b>;<br />
              - За замовчуванням сортує за зростанням.<br />
              <br />
              <i>аналогічний до методу <b>toSorted()</b></i>
              <br />
              <div class="bcg-box">
                <p>
                  array.toSorted( // Callback function });
                </p>
              </div>
            </td>
            <td>
              const scores = [61, 19, 74];<br />
              scores.sort(); // [19, 61, 74]<br />
              <br />
              const letters = ["b", "B", "a", "A"]; <br />
              letters.sort(); // ["A", "B", "a", "b"]
            </td>
          </tr>
        </tbody>
      </table>

      <table class="print-m-bottom-max">
        <caption>
          Методи об'єктів
        </caption>
        <thead>
          <th class="bcg-color-head">Метод</th>
          <th class="bcg-color-head">Опис</th>
          <th class="bcg-color-head">Приклад</th>
        </thead>

        <tbody>
          <tr>
            <td>Object.keys()</td>
            <td>
              Приймає об'єкт і повертає масив ключів його
              властивостей. Якщо в об'єкті немає
              властивостей, метод поверне порожній масив.
            </td>
            <td>
              const book = {<br />
              title: "The Last Kingdom",<br />
              author: "Bernard Cornwell",<br />
              };<br />
              <br />
              const keys = Object.keys(book);<br />
              console.log(keys); // ['title', 'author']
            </td>
          </tr>

          <tr>
            <td>Object.values()</td>
            <td>
              Приймає об'єкт і повертає масив значень
              властивостей. Якщо в об'єкті немає
              властивостей, метод поверне порожній масив.
            </td>
            <td>
              const book = {<br />
              title: "The Last Kingdom",<br />
              author: "Bernard Cornwell",<br />
              rating: 8.38,<br />
              };<br />
              <br />
              const values = Object.values(book);<br />
              console.log(values); <br />
              // ["The Last Kingdom", "Bernard Cornwell",
              8.38]
            </td>
          </tr>

          <tr>
            <td>Object.create(obj)</td>
            <td>
              Створює і повертає новий об'єкт, зв'язуючи
              його з об'єктом <b>obj</b>.
            </td>
            <td>
              const animal = {<br />
              legs: 4,<br />
              };<br />
              <br />
              const dog = Object.create(animal);<br />
              dog.name = "Mango";<br />
              <br />
              console.log(dog); <br />
              // { name: "Mango", [[Prototype]]: animal }
            </td>
          </tr>

          <tr>
            <td>isPrototypeOf()</td>
            <td>
              Перевірка, чи є об'єкт прототипом іншого
              об'єкта.
              <div class="bcg-box">
                objA.isPrototypeOf(objB)
              </div>
              Метод перевіряє, чи є об'єкт
              <b>objA</b> прототипом для об’єкта
              <b>objB</b>. Якщо так, повертає <b>true</b>, в
              іншому разі повертає <b>false</b>
            </td>
            <td>
              const animal = { };<br />

              const dog = Object.create(animal);<br />
              <br />
              console.log(dog); // { [[Prototype]]: animal
              }<br />
              <br />
              console.log(animal.isPrototypeOf(dog)); //
              true<br />
              console.log(dog.isPrototypeOf(animal)); //
              false
            </td>
          </tr>

          <tr>
            <td>hasOwnProperty(key)</td>
            <td>
              Перевіряє наявність власної властивості з
              ім'ям key і повертає <b>true</b>, якщо є, і
              <b>false</b> в іншому випадку.
            </td>
            <td>
              const animal = {<br />
              legs: 4,<br />
              };<br />
              const dog = Object.create(animal);<br />
              dog.name = "Mango";<br />
              <br />

              console.log(dog.hasOwnProperty("name")); //
              true<br />
              console.log(dog.hasOwnProperty("legs")); //
              false
            </td>
          </tr>

          <!-- <tr>
            <td></td>
            <td></td>
            <td></td>
          </tr> -->
        </tbody>
      </table>

      <table class="print-m-bottom-max">
        <caption>
          Методи функцій
        </caption>
        <thead>
          <th class="bcg-color-head">Метод</th>
          <th class="bcg-color-head">Опис</th>
          <th class="bcg-color-head">Приклад</th>
        </thead>

        <tbody>
          <tr>
            <td>call()</td>
            <td>
              Викликає функцію та вказує <b>this</b> для
              об'єкта, якщо функція не є його методом.
              <br />
              <div class="bcg-box">
                <p>foo.call(thisArg, arg1, arg2, ...)</p>
              </div>

              <b>thisArg</b> — об'єкт, який необхідно
              встановити як контекст (значення this) для
              функції <br />
              <b>arg1, arg2, ...</b> — необов'язкові
              аргументи, які будуть передані функції
            </td>
            <td>
              function greet(str) {<br />
              console.log(`${str}, ${this.username}`);<br />
              }<br />
              <br />
              const mango = {<br />
              username: "Mango",<br />
              };<br />
              <br />
              greet.call(mango, "Welcome");<br />
              // "Welcome, Mango"
            </td>
          </tr>

          <tr>
            <td>apply()</td>
            <td>
              Викликає функцію та вказує <b>this</b> для
              об'єкта, якщо функція не є його методом.
              Аналог методу <b>call</b>, відмінність у тому,
              що в методі apply()
              <i
                >синтаксис передачі аргументів вимагає
                масиву</i
              >,
              <br />
              <div class="bcg-box">
                <p>foo.call(thisArg, [arg1, arg2, ...])</p>
              </div>

              <b>thisArg</b> — об'єкт, який необхідно
              встановити як контекст (значення this) для
              функції <br />
              <b>[arg1, arg2, ...]</b> — необов'язкові
              аргументи, які будуть передані функції.
              Обов'язково передається <b>масив</b>.
            </td>
            <td>
              function greet(str) {<br />
              console.log(`${str}, ${this.username}`);<br />
              }<br />
              <br />
              const mango = {<br />
              username: "Mango",<br />
              };<br />
              <br />
              greet.apply(mango, ["Welcome"]); <br />
              // "Welcome, Mango"
            </td>
          </tr>

          <tr>
            <td>bind()</td>
            <td>
              Створює і повертає <b>нову функцію</b>, яка
              має заздалегідь встановлений контекст, і ця
              нова функція може бути викликана пізніше з
              будь-якими аргументами. <br />
              <div class="bcg-box">
                <p>
                  const boundFoo = foo.bind(thisArg, arg1,
                  arg2, ...)
                </p>
              </div>
            </td>
            <td>
              "use strict";<br />

              const customer = {<br />
              name: "Jacob",<br />
              sayHello() {<br />
              console.log(`Hello, ${this.name}!`);<br />
              }<br />
              };<br />
              <br />
              customer.sayHello(); // "Hello, Jacob!"<br />
              <br />
              const greet =
              customer.sayHello.bind(customer);<br />
              <br />
              greet(); // "Hello, Jacob!"
            </td>
          </tr>

          <!-- <tr>
            <td></td>
            <td></td>
            <td></td>
          </tr> -->

          <!-- <tr>
            <td></td>
            <td></td>
            <td></td>
          </tr> -->
        </tbody>
      </table>

      <table class="print-m-bottom-max">
        <caption>
          Методи DOM
        </caption>
        <thead>
          <th class="bcg-color-head">Метод</th>
          <th class="bcg-color-head">Опис</th>
          <th class="bcg-color-head">Приклад</th>
        </thead>

        <!-- Методи пошуку елементів -->
        <tbody>
          <tr>
            <td class="bcg-color center-text" colspan="3">
              <b>Методи пошуку елементів</b>
            </td>
          </tr>

          <!-- querySelector -->
          <tr>
            <td>querySelector()</td>
            <td>
              <p>
                Використовується, якщо необхідно знайти
                тільки один, найчастіше унікальний елемент.
              </p>
              <ul class="list-style">
                <li>
                  Повертає <b>перший</b> знайдений елемент
                  усередині element, що відповідає рядку
                  <i>CSS-селектора selector</i>. Навіть якщо
                  їх декілька, завжди повернеться посилання
                  тільки на перший елемент у DOM-дереві.
                </li>
                <li>
                  Якщо не знайдено - поверне
                  <b>null</b>
                </li>
              </ul>
              <div class="bcg-box">
                <p>element.querySelector(selector)</p>
              </div>
            </td>
            <td>
              <p>
                &#60;ul class="list"&#62;<br />
                <b
                  >&#60;li
                  class="list-item"&#62;&#60;/li&#62;</b
                ><br />
                &#60;li
                class="list-item"&#62;&#60;/li&#62;<br />
                &#60;/ul&#62;<br />
                <br />
                const listItems =
                document.querySelector(".list-item")
              </p>
            </td>
          </tr>

          <!-- querySelectorAll -->
          <tr>
            <td>querySelectorAll()</td>
            <td>
              <p>
                Використовується, якщо необхідно знайти
                колекцію елементів, тобто отримати масив
                посилань на елементи з однаковим селектором.
              </p>
              <ul class="list-style">
                <li>
                  Повертає <i>псевдомасив</i> усіх елементів
                  всередині element, які відповідають
                  CSS-селектору <b>selector</b>
                </li>
                <li>
                  Якщо нічого не знайдено, поверне порожній
                  масив
                </li>
              </ul>
              <div class="bcg-box">
                <p>element.querySelectorAll(selector)</p>
              </div>
            </td>
            <td>
              <p>
                &#60;ul class="list"&#62;<br />
                <b
                  >&#60;li
                  class="list-item"&#62;&#60;/li&#62;</b
                ><br />
                <b>
                  &#60;li
                  class="list-item"&#62;&#60;/li&#62;</b
                ><br />
                &#60;/ul&#62;<br />
                <br />
                const listItems =
                document.querySelectorAll(".list-item")
              </p>
            </td>
          </tr>
        </tbody>

        <!-- Методи властивості classList -->
        <tbody>
          <tr>
            <td class="bcg-color center-text" colspan="3">
              <b>Методи властивості classList</b>
            </td>
          </tr>

          <!-- Приклад -->
          <tr>
            <td colspan="3">
              <p><b>Приклад для методів нижче</b></p>
              <p>
                &#60;a class="link"
                href="&#60;https://goit.global&#62;"
                &#62;GoIT&#60;/a &#62;;<br />
                const link =
                document.querySelector(".link");<br />
                console.log(link.classList); // ["link",
                "is-active", length: 2, value: "link
                is-active"]
              </p>
            </td>
          </tr>

          <!-- contains() -->
          <tr>
            <td>contains()</td>
            <td>
              <p>
                Перевіряє наявність класу <b>className</b> в
                елемента, та повертає <b>true</b> або
                <b>false</b>
              </p>
              <p class="">
                <i
                  >Очікує аргументом рядок без крапки (без
                  селектора класу) з іменем класу</i
                >
              </p>
              <div class="bcg-box">
                <p>el.classList.contains(className)</p>
              </div>
            </td>
            <td>
              <p>
                const hasActiveClass =
                link.classList.contains("is-active"); //
                true
                <br /><br />
                const hasActiveClass =
                link.classList.contains("title"); // false
              </p>
            </td>
          </tr>

          <!-- add() -->
          <tr>
            <td>add()</td>
            <td>
              <p class="">
                Додає клас <b>className</b> до списку класів
                елемента.
              </p>
              <div class="bcg-box">
                <p>el.classList.add(className)</p>
              </div>
            </td>
            <td>
              <p>
                link.classList.add("special");<br />
                // ["link", "is-active", <b>"special"</b> ,
                length: 3, value: "link is-active
                <b>special</b>"]
              </p>
            </td>
          </tr>

          <!-- remove() -->
          <tr>
            <td>remove()</td>
            <td>
              <p class="">
                Видаляє клас <b>className</b> зі списку
                класів елемента.
              </p>
              <div class="bcg-box">
                <p>el.classList.remove(className)</p>
              </div>
              <p>
                <i
                  >Якщо видалити клас, якого не існує на
                  елементі, то це не викличе помилку.
                </i>
              </p>
            </td>
            <td>
              <p>
                link.classList.remove("is-active");<br />
                // ["link", "special", length: 2, value:
                "link special"]
              </p>
            </td>
          </tr>

          <!-- toggle() -->
          <tr>
            <td>toggle()</td>
            <td>
              <p>Працює як перемикач:</p>
              <ul class="list-style">
                <li>
                  якщо клас className <i>відсутній</i>, то
                  <b>додає</b> його в
                  <i>кінець списку класів</i>;
                </li>
                <li>
                  якщо клас className <i>присутній</i> —
                  <b>видаляє</b> його.
                </li>
              </ul>
              <div class="bcg-box">
                <p>el.classList.toggle(className)</p>
              </div>
            </td>
            <td>
              <p>
                link.classList.toggle("is-active");<br />
                // ["link", "special", "is-active", length:
                3, value: "link special is-active"]
              </p>
            </td>
          </tr>

          <!-- replace() -->
          <tr>
            <td>replace()</td>
            <td>
              <p class="">
                Замінює існуючий клас <b>oldClassName</b> на
                вказаний <b>newClassName</b>.
              </p>
              <div class="bcg-box">
                <p>
                  el.classList.replace(oldClassName,
                  newClassName)
                </p>
              </div>
            </td>
            <td>
              link.classList.replace("special",
              "regular");<br />
              // ["link", "regular", "is-active", length: 3,
              value: "link regular is-active"]
            </td>
          </tr>
        </tbody>

        <!-- Методи атрибутів -->
        <tbody>
          <tr>
            <td class="bcg-color center-text" colspan="3">
              <b>Методи атрибутів</b>
            </td>
          </tr>

          <!-- Приклад -->
          <tr>
            <td colspan="3">
              <p><b>Приклад для методів нижче</b></p>
              <p>
                &#60;img class="image"
                src="&#60;https://picsum.photos/id/15/320/240&#62;"
                alt="Rocks and waterfall" width="300" /&#62;
                <br />

                const image =
                document.querySelector(".image");
              </p>
            </td>
          </tr>

          <!-- hasAttribute() -->
          <tr>
            <td>hasAttribute()</td>
            <td>
              <p class="m-bottom-min">
                Перевіряє наявність атрибуту у елементі, та
                повертає <b>true</b> чи <b>false</b>.
              </p>
              <p class="">
                Приймає один аргумент — рядок
                <b>nameAttribute</b> з іменем атрибута.
              </p>
              <div class="bcg-box">
                el.hasAttribute(nameAttribute)
              </div>
            </td>
            <td>
              image.hasAttribute("src"); // true
              <br />
              image.hasAttribute("href"); // false
            </td>
          </tr>

          <!-- getAttribute() -->
          <tr>
            <td>getAttribute()</td>
            <td>
              <p class="m-bottom-min">
                Повертає значення атрибута для вказаного
                HTML-елемента
              </p>
              <div class="bcg-box">
                <p>el.getAttribute(nameAttribute)</p>
              </div>
            </td>
            <td>
              <p>
                image.getAttribute("alt"); // "Rocks and
                waterfall"
              </p>
            </td>
          </tr>

          <!-- setAttribute() -->
          <tr>
            <td>setAttribute()</td>
            <td>
              <p class="m-bottom-min">
                Встановлює або змінює значення зазначеного
                атрибута для вказаного HTML-елемента
              </p>
              <ul class="">
                <li>
                  <b>nameAttribute</b> - ім'я атрибута, який
                  потрібно встановити або змінити;
                </li>
                <li>
                  <b>value</b> - значення, яке треба
                  присвоїти цьому атрибуту.
                </li>
              </ul>
              <div class="bcg-box">
                el.setAttribute(nameAttribute, value)
              </div>
            </td>
            <td>
              image.getAttribute("alt"); // Amazing nature
            </td>
          </tr>

          <!-- removeAttribute() -->
          <tr>
            <td>removeAttribute()</td>
            <td>
              <p class="m-bottom-min">
                Видаляє атрибут із вказаного HTML-елемента
              </p>
              <p class="">
                Якщо зазначеного атрибута немає на елементі,
                метод не викликає жодних помилок та не
                робить нічого.
              </p>
              <div class="bcg-box">
                el.removeAttribute(nameAttribute)
              </div>
            </td>
            <td>
              image.removeAttribute("alt");
              image.hasAttribute("alt"); // false
            </td>
          </tr>
        </tbody>

        <!-- Методи створення, додавання та видалення елементів -->
        <tbody>
          <tr>
            <td class="bcg-color center-text" colspan="3">
              <b
                >Методи створення, додавання та видалення
                елементів</b
              >
            </td>
          </tr>

          <!-- createElement() -->
          <tr>
            <td>createElement()</td>
            <td>
              <p>
                Створює елемент з ім'ям tagName і повертає
                посилання на його об’єкт як результат свого
                виконання.
              </p>
              <p>
                <b>tagName</b> — це рядок, що вказує тип
                елемента, який створюється.
              </p>
              <p>
                Елемент створюється в пам'яті, у DOM його ще
                немає.
              </p>
              <div class="bcg-box">
                document.createElement(tagName)
              </div>
            </td>
            <td>
              <p>
                document.createElement(<b>tagName</b>)
                <br /><br />
                const list = document.createElement("ul");
                <br />
                const item =
                document.createElement("li");<br />
                const text = document.createElement("p");
              </p>
            </td>
          </tr>

          <!-- append() -->
          <tr>
            <td>append()</td>
            <td>
              <p>
                додає один або декілька елементів
                <b>після всіх дітей</b> елемента
              </p>
              <div class="bcg-box">
                elem.append(el1, el2, ...)
              </div>
            </td>
            <td>
              list.append(item) <br />
              <br />
              &#60;ul&#62;<br />
              &#60;li&#62;&#60;/li&#62;<br />
              <b> &#60;li&#62;&#60;/li&#62;<br /> </b>
              &#60;/ul&#62;
            </td>
          </tr>

          <!-- prepend() -->
          <tr>
            <td>prepend()</td>
            <td>
              <p>
                додає один або декілька елементів
                <b>перед усіма дітьми</b> елемента
              </p>
              <div class="bcg-box">
                elem.prepend(el1, el2, ...)
              </div>
            </td>
            <td>
              list.prepend(item) <br />
              <br />
              &#60;ul&#62;<br />
              <b> &#60;li&#62;&#60;/li&#62;<br /> </b>
              &#60;li&#62;&#60;/li&#62;<br />
              &#60;/ul&#62;
            </td>
          </tr>

          <!-- after() -->
          <tr>
            <td>after()</td>
            <td>
              <p>
                додає один або декілька елементів
                <b>після елемента</b>
              </p>
              <div class="bcg-box">
                elem.after(el1, el2, ...)
              </div>
            </td>
            <td>
              list.after(text) <br />
              <br />
              &#60;ul&#62;<br />
              &#60;li&#62;&#60;/li&#62;<br />
              &#60;li&#62;&#60;/li&#62;<br />
              &#60;/ul&#62;<br />
              <b> &#60;p&#62;&#60;/p&#62;</b>
            </td>
          </tr>

          <!-- before() -->
          <tr>
            <td>before()</td>
            <td>
              <p>
                додає один або декілька елементів
                <b>перед елементом</b>
              </p>
              <div class="bcg-box">
                elem.before(el1, el2, ...)
              </div>
            </td>
            <td>
              list.before(text) <br />
              <br />
              <b> &#60;p&#62;&#60;/p&#62;</b><br />
              &#60;ul&#62;<br />
              &#60;li&#62;&#60;/li&#62;<br />
              &#60;li&#62;&#60;/li&#62;<br />
              &#60;/ul&#62;
            </td>
          </tr>

          <!-- remove() -->
          <tr>
            <td>remove()</td>
            <td>
              <p>Видаляє елемент</p>
              <div class="bcg-box">element.remove()</div>
            </td>
            <td>text.remove();</td>
          </tr>

          <!-- insertAdjacentHTML() -->
          <tr>
            <td>insertAdjacentHTML()</td>
            <td>
              <p>
                додавання рядка з HTML-тегами перед, після
                або всередину елемента.
              </p>
              <div class="bcg-box">
                element.insertAdjacentHTML(position, string)
              </div>
              <p>
                Аргумент <b>position</b> — це рядок, який
                визначає позицію щодо елемента element. Він
                приймає одне з чотирьох значень.
              </p>
              <ul class="list-style">
                <li>
                  <b>"beforebegin"</b> — перед element
                  (працюєть, коли element вже знаходиться в
                  DOM-дереві)
                </li>
                <li>
                  <b>"afterbegin"</b> — всередині element,
                  перед усіма дітьми
                </li>
                <li>
                  <b>"beforeend"</b> — всередині element,
                  після усіх дітей
                </li>
                <li>
                  <b>"afterend"</b> — після element
                  (працюєть, коли element вже знаходиться в
                  DOM-дереві)
                </li>
              </ul>
              <p>
                Аргумент <b>string</b> — рядок з вілідною
                HTML-розміткою або зміна, що її містить
              </p>
            </td>
            <td>
              list.insertAdjacentHTML("beforebegin",
              "&#60;h2&#62;Popular
              technologies&#60;/h2&#62;");
            </td>
          </tr>
        </tbody>

        <tbody>
          <tr>
            <td class="bcg-color center-text" colspan="3">
              <b></b>
            </td>
          </tr>

          <tr>
            <td></td>
            <td>
              <p></p>
              <div class="bcg-box"></div>
            </td>
            <td></td>
          </tr>
        </tbody>
      </table>
    </section>
  </body>
</html>
