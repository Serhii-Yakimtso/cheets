<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0"
    />
    <link rel="stylesheet" href="../../css/styles.css" />
    <link
      rel="stylesheet"
      href="../../css/styles-print.css"
    />

    <title>Document</title>
  </head>
  <body>
    <a class="print-home-link" href="../../index.html"
      >На головну</a
    >
    <h1 class="m-bottom center-text">Об'єкти</h1>

    <section class="m-bottom">
      <div class="print-flex-box">
        <div>
          <p>
            Елемент, в якому можно зберігати згрупованні
            данні.
          </p>
          <ul class="list-style">
            <li>
              оголошення об’єкта — фігурні дужки <b>{}</b>.
            </li>
            <li>
              при створенні можна додати <b>властивості</b>,
              але не обов’язково. Кожна властивість
              обов’язково складається з пари
              <b>ключ: значення</b>.
            </li>
            <li>
              <b>ключ</b> — ім'ям властивості (зазвичай
              рядок).
            </li>
            <li>
              <b>значенням властивості</b> можуть бути
              будь-які типи: примітиви, масиви, об'єкти,
              булі, функції тощо.
            </li>
            <li>
              властивості між собою розділяються
              <b>комою</b>.
            </li>
          </ul>
        </div>
        <div class="bcg-box print-bcg-box">
          pconst book = {<br />
          title: "The Last Kingdom",<br />
          author: "Bernard Cornwell",<br />
          genres: ["historical prose", "adventure"],<br />
          public: true,<br />
          rating: 8.38,<br />
          stats: {<br />
          reads: 4827,<br />
          likes: 1308,<br />
          },<br />
          };
        </div>
      </div>
    </section>

    <section class="m-bottom">
      <h2 class="m-bottom-min">Доступ до властивостей</h2>
      <div class="m-bottom-min print-flex-box">
        <div>
          <p>Синтаксис <b>objectName.key</b></p>
          <ul class="list-style">
            <li>
              На місце звернення буде повернуте значення
              властивості з таким ключем.
            </li>
            <li>
              Якщо в об'єкті відсутня властивість з таким
              ключем, на місце звернення повернеться
              <b>undefined</b>.
            </li>
          </ul>
        </div>
        <div class="bcg-box print-bcg-box">
          <p>
            const book = {<br />
            title: "The Last Kingdom",<br />
            };<br />
            <br />
            console.log(book.title;); // "The Last
            Kingdom"<br />
            console.log(book.price); // undefined
          </p>
        </div>
      </div>
      <div class="print-flex-box">
        <div>
          <p>Синтаксис <b>objectName[”key”]</b></p>
          <ul class="list-style">
            <li>
              у квадратні дужки вкладається <i>рядок</i> або
              <i>змінна</i>
            </li>
            <li>
              цей синтаксис використовується рідко - як
              правило, у випадках, коли ім'я властивості
              заздалегідь не відоме або воно зберігається у
              змінній.
            </li>
          </ul>
        </div>
        <div class="bcg-box print-bcg-box">
          <p>
            const book = {<br />
            title: "The Last Kingdom",<br />
            author: "Bernard Cornwell",<br />
            };<br />
            <br />
            console.log(book.title); // "The Last Kingdom"
            <br />
            console.log(book["title"]); // "The Last
            Kingdom"
            <br />
            <br />
            const propKey = "author";<br />
            console.log(book.propKey); // undefined<br />
            console.log(book[propKey]); // "Bernard
            Cornwell"
          </p>
        </div>
      </div>
    </section>

    <section class="m-bottom">
      <h2 class="m-bottom-min">
        Доступ до вкладених властивостей
      </h2>
      <div class="print-flex-box">
        <div>
          <p>
            Для доступу до вкладених властивостей
            використовується ланцюжок звернень через
            «крапку»
          </p>
          <ul class="list-style">
            <li>
              <b>user.location</b> — це звернення (шлях) до
              об'єкта у властивості location,
            </li>
            <li>
              <b>user.location.country</b> — звернення до
              властивості country в цьому об'єкті
            </li>
          </ul>
        </div>
        <div class="bcg-box print-bcg-box">
          <p>
            const user = {<br />
            location: {<br />
            country: "Jamaica",<br />
            },<br />
            };<br />
            console.log(user.location.country); //
            "Jamaica"<br />
          </p>
        </div>
      </div>
    </section>

    <section class="m-bottom">
      <h2 class="m-bottom-min">
        Доступ до властивості-масиву
      </h2>
      <div class="print-flex-box">
        <div>
          <p></p>
          <ul class="list-style">
            <li>
              отримати доступ до елементів масиву можна
              через квадратні дужки та індекс:
              <b>user.hobbies[0]</b>;
            </li>
            <li>
              можна використовувати властивості й методи
              масиву
            </li>
          </ul>
        </div>
        <div class="bcg-box print-bcg-box">
          <p>
            const user = {<br />
            hobbies: ["swimming", "music", "sci-fi"], <br />
            }<br />
            console.log(user.hobbies); // ["swimming",
            "music"]<br />
            console.log(user.hobbies[0]); // "swimming"<br />
            console.log(user.hobbies.length); // 2
          </p>
        </div>
      </div>
    </section>

    <section class="m-bottom">
      <h2 class="m-bottom-min">
        Зміна значення властивостей
      </h2>
      <div class="print-flex-box">
        <div>
          <p>
            Щоб <b>змінити</b> значення властивості в
            об'єкті, треба звернутися до неї за її ключем та
            присвоїти нове значення.
          </p>
          <!-- <ul class="list-style">
          <li></li>
          <li></li>
        </ul> -->
        </div>
        <div class="bcg-box print-bcg-box">
          <p>
            const book = {<br />
            title: "The Last Kingdom",<br />
            genres: ["historical prose", "adventure"],<br />
            rating: 8.38,<br />
            };<br />
            <br />
            book.rating = 9;<br />
            book.genres.push("drama");<br />
            <br />
            console.log(book.rating); // 9<br />
            console.log(book.genres); // ["historical
            prose", "adventure", "drama"]
          </p>
        </div>
      </div>
    </section>

    <section class="m-bottom">
      <h2 class="m-bottom-min">Додавання властивостей</h2>
      <div class="print-flex-box">
        <div>
          <p>
            Якщо звернутись до значення властивості, яка
            відсутня в об'єкті - вона буде у ньому створена.
          </p>
          <!-- <ul class="list-style">
          <li></li>
          <li></li>
        </ul> -->
        </div>
        <div class="bcg-box print-bcg-box">
          <p>
            const book = {<br />
            title: "The Last Kingdom",<br />
            };<br />
            <br />
            book.pageCount = 836;<br />
            console.log(book.pageCount); // 836
          </p>
        </div>
      </div>
    </section>

    <section class="m-bottom">
      <h2 class="m-bottom-min">Короткі властивості</h2>
      <div class="print-flex-box">
        <div>
          <p>
            Під час створення об'єкта значення властивості
            може бути необхідно взяти зі змінної або
            параметра функції з таким самим ім'ям, як і сама
            властивість. <br />
            Щоб уникнути дублювання імен (наприклад,
            <i>name: name</i>, і <i>age: age</i>,)
            використовують короткі записи, де вказується
            лише ім'я властивості (наприклад, <i>name</i> і
            <i>age</i>) - значення властивості буде взято зі
            змінної з аналогічним ім'ям
          </p>
          <!-- <ul class="list-style">
          <li></li>
          <li></li>
        </ul> -->
        </div>
        <div class="bcg-box print-bcg-box">
          <p>
            const name = "Henry Sibola";<br />
            const age = 25;<br />
            <br />
            const user = {<br />
            name: name,<br />
            age: age,<br />
            };<br />
            const user = {<br />
            name,<br />
            age,<br />
            };
          </p>
        </div>
      </div>
    </section>

    <section class="m-bottom">
      <h2 class="m-bottom-min">
        Обчислювальні властивості
      </h2>
      <div class="print-flex-box">
        <div>
          <p class="m-bottom-min">
            Під час оголошення об'єкта може бути необхідно
            додати властивість з ім'ям, яке ми заздалегідь
            не знаємо, тому що воно зберігається як значення
            змінної або як результат виконання функції.
          </p>
          <p>
            Синтаксис схожий із додаванням властивостей
            через квадратні дужки, але допомагає уникнути
            зайвого коду.
          </p>
          <!-- <ul class="list-style">
          <li></li>
          <li></li>
        </ul> -->
        </div>
        <div class="bcg-box print-bcg-box">
          <p>
            const propName = "name";<br />
            <br />
            <i>Синтаксис через квадратні дужки</i><br />
            const user = {<br />
            age: 25,<br />
            };<br />
            <br />
            user[propName] = "Henry Sibola";<br />
            <br />
            <i>Синтаксис через обчислювальні властивості</i
            ><br />
            const propName = "name";<br />
            const user = {<br />
            age: 25,<br />
            [propName]: "Henry Sibola",<br />
            };
          </p>
        </div>
      </div>
    </section>

    <section class="m-bottom">
      <h2 class="m-bottom-min">
        Створення об'єкта за допомогою синтаксису ...spread
      </h2>
      <div class="m-bottom-min print-flex-box">
        <p class="m-bottom-min">
          Операція <b>...spread</b> дозволяє розпилити
          властивості довільної кількості об'єктів в один
          новий.
        </p>
        <div class="bcg-box print-bcg-box">
          <p>
            const first = { propA: 5, propB: 10 };<br />
            const second = { propC: 15 };<br />
            const third = { ...first, ...second };<br />
            console.log(third); // { propA: 5, propB: 10,
            propC: 15 }
          </p>
        </div>
      </div>

      <div class="print-flex-box">
        <p class="m-bottom-min">
          <b>Порядок розподілу має значення</b>. Імена
          властивостей об'єкта — унікальні, тому властивості
          об'єкта, що розпиляються, можуть перезаписати
          значення вже існуючої властивості, якщо їх імена
          збігаютьс
        </p>
        <div class="bcg-box print-bcg-box">
          <p>
            const first = { propA: 5, propB: 10,
            <b>propC: 50</b> };<br />
            const second = { propC: 15, propD: 20 };<br />
            <br />
            const third = { ...first, ...second };<br />
            console.log(third); // { propA: 5, propB: 10,
            <b>propC: 15</b>, propD: 20 }<br />
            <br />
            const fourth = { ...second, ...first };<br />
            console.log(fourth); // { propA: 5, propB: 10,
            <b>propC: 50</b>, propD: 20 }
          </p>
        </div>
      </div>
    </section>

    <section class="m-bottom">
      <h2 class="m-bottom-min">Методи об'єкта</h2>
      <div class="print-flex-box">
        <div>
          <p class="m-bottom-min">
            <b>Метод об'єкта</b> - це звичайна функція,
            оголошена як властивість об'єкта , а не як
            окрема змінна.
          </p>
          <p>
            Для звернення до методу об'єкта використовується
            стандартний синтаксис із крапкою.
          </p>
        </div>
        <div class="bcg-box print-bcg-box">
          <p>
            const obj = {<br />
            getMessage(value) {<br />
            console.log(`I'm a method with ${value}!`);<br />
            }<br />
            };<br />
            obj.getMessage(5); // "I'm a method with 5!"<br />
            obj.getMessage(10); // "I'm a method with 10!"
          </p>
        </div>
      </div>
    </section>

    <section class="m-bottom print-m-bottom-max">
      <h2 class="m-bottom-min">
        this - як доступ до властивостей об'єкта
      </h2>
      <p class="m-bottom-min">
        Ключове слово <b>this</b> — це контекст виконання
        функції.
      </p>
      <p class="m-bottom-min">
        Значенням <b>this</b> буде посилання на об'єкт перед
        <i>«крапкою»</i>, тобто об'єкт, який викликав цей
        метод, у нашому випадку — це посилання на об'єкт
        bookShelf
      </p>
      <p class="m-bottom-min">
        Для доступу до властивостей об'єкта в методах
        звертаємось до нього через <b>this</b> і далі,
        стандартно, «через крапку» до властивостей.
      </p>

      <div class="m-bottom-min print-flex-box">
        <div
          class="bcg-box m-bottom-min print-bcg-box print-m-left-none"
        >
          <p>
            const bookShelf = {<br />
            books: ["The Last Kingdom", "The Mist"],<br />
            getBooks() {<br />
            console.log(this);<br />
            },<br />
            };<br />

            bookShelf.getBooks(); <br />// {books: ["The
            Last Kingdom", "The Mist"],<br />
            getBooks: f}
          </p>
        </div>
        <div class="bcg-box m-bottom-min print-bcg-box">
          <p>
            const bookShelf = {<br />
            books: ["The Last Kingdom", "The Mist"],<br />
            getBooks() {<br />
            return this.books;<br />
            }<br />
            };<br />
            <br />
            console.log(bookShelf.getBooks());<br />
            // ["The Last Kingdom", "The Mist"]
          </p>
        </div>
      </div>

      <div class="print-flex-box">
        <img
          class="objects-this-img-pattern m-bottom-min"
          src="../../images/js-this-1.jpg"
          alt="схема this"
        />
        <img
          class="objects-this-img-pattern m-bottom-min"
          src="../../images/js-this-2.jpg"
          alt="схема this"
        />
      </div>
      <p class="m-bottom">
        <b>Важливо!</b>. Ім'я об'єкта — річ ненадійна.
        Методи одного об'єкта можна копіювати в інший (з
        іншим ім'ям), і часто, при створенні об'єкта, ми
        наперед зовсім не знаємо імені. Використання this
        гарантує, що метод працює саме з тим об'єктом, який
        його викликав.
      </p>
      <p class="m-bottom">
        <b>Важливо!</b>. Значення <b>this</b> визначається
        <i>не на момент оголошення функції</i> (за винятком
        стрілкових функцій), <i>а на момент її виклику</i>
      </p>

      <div class="m-bottom print-flex-box">
        <div>
          <p class="m-bottom-min">
            <b> this - як зміна за посиланням </b>
          </p>
          <div class="bcg-box print-bcg-box">
            <p>
              const bookShelf = {<br />
              books: ["The Last Kingdom"],<br />
              addBook(bookName) {<br />
              this.books.push(bookName);<br />
              }<br />
              };<br />
              bookShelf.addBook("The Mist");
            </p>
          </div>
        </div>
        <div>
          <p class="m-bottom-min">
            <b> this - із масивами об’єктів </b>
          </p>
          <div class="bcg-box print-bcg-box">
            <p>
              const bookShelf = {<br />
              books: [],<br />
              addBook(newBook) {<br />
              this.books.push(newBook);<br />
              }<br />
              };<br />
              <br />
              bookShelf.addBook({ title: "Dream Guardian",
              rating: 9 });
            </p>
          </div>
        </div>
      </div>

      <div class="m-bottom print-flex-box">
        <div>
          <p class="m-bottom-min">
            <b>
              this - обчислення значень об'єктів у масиві
            </b>
          </p>
          <div
            class="bcg-box print-bcg-box print-m-left-none"
          >
            <p>
              const bookShelf = {<br />
              books: [<br />
              { title: "The Last Kingdom", rating: 8 },<br />
              { title: "The Mist", rating: 6 },<br />
              ],<br />
              getAvarageRating() {<br />
              let totalRating = 0;<br />
              <br />
              for (const book of this.books) {<br />
              totalRating += book.rating;<br />
              }<br />
              <br />
              return totalRating / this.books.length;<br />
              },<br />
              };<br />
              <br />
              bookShelf.getAvarageRating(); // 7
            </p>
          </div>
        </div>

        <div>
          <p class="m-bottom-min">
            <b> this - зміна об'єкта в масиві </b>
          </p>
          <div class="bcg-box print-bcg-box">
            <p>
              const bookShelf = {<br />
              books: [<br />
              { title: "The Last Kingdom", rating: 8 },<br />
              { title: "The Mist", rating: 6 },<br />
              ],<br />
              changeRating(bookName, newRating) {<br />
              for(const book of this.books) {<br />
              if(book.title === bookName) {<br />
              book.rating = newRating;<br />
              }<br />
              }<br />
              }<br />
              };<br />
              <br />
              changeRating("The Last Kingdom", 4);<br />
              console.log(bookShelf.books[1])<br />
              // { title: "The Last Kingdom", rating: 4 }
            </p>
          </div>
        </div>
      </div>

      <div
        class="m-bottom print-flex-box print-m-bottom-max"
      >
        <div>
          <p class="m-bottom-min">
            <b> this - додавання методів у об'єкт </b>
          </p>
          <div
            class="bcg-box print-bcg-box print-m-left-none"
          >
            <p>
              "use strict";<br />

              function showThis() {<br />
              console.log(this);<br />
              }<br />
              <br />
              const user = {<br />
              username: "Poly",<br />
              };<br />
              <br />
              user.showContext = showThis;<br />

              user.showContext(); <br />// {username:
              "Poly", showContext: ƒ}<br />

              showThis(); // undefined
            </p>
          </div>
        </div>
      </div>

      <h3 class="m-bottom-min">Глобальний контекст</h3>
      <div class="print-flex-box">
        <p class="m-bottom-min">
          Якщо функція виконується
          <i>не в суворому режимі</i>,
          <b>this</b> посилається на об'єкт <b>window</b>.
          <br />
          <br />
          <i>У суворому режимі</i> значення <b>this</b> у
          глобальному контексті завжди буде
          <b>undefined</b>.
        </p>
        <div class="print-flex-box">
          <div class="bcg-box m-bottom-min print-bcg-box">
            <p>
              function foo() {<br />
              console.log(this);<br />
              }<br />
              <br />
              foo(); // window
            </p>
          </div>
          <div class="bcg-box print-bcg-box">
            <p>
              <b>"use strict"; </b><br />
              function foo() {<br />
              console.log(this);<br />
              }<br />
              <br />
              foo(); // undefined
            </p>
          </div>
        </div>
      </div>

      <h3 class="m-bottom-min">
        this у стрілочних функціях
      </h3>
      <div class="m-bottom print-flex-box">
        <p class="m-bottom-min">
          1.Контекст <b>this</b> усередині стрілочної
          функції визначається місцем її <b>оголошення</b>,
          а не виклику.
          <br />
          2.Стрілочні функції
          <b>ігнорують наявність суворого режиму</b>. Тому в
          глобальному контексті у стрілці завжди this
          посилається на об'єкт <b>window</b>.<br />
          3. <i>Неможливо</i> змінити значення
          <b>this</b> усередині стрілочних функцій
          <i>після її оголошення</i>. Методи
          <i>call, apply і bind</i> не впливають на значення
          this у стрілках.
        </p>
        <div class="bcg-box print-bcg-box">
          <p>
            const showThis = () => {<br />
            console.log(this);<br />
            };<br />
            <br />
            const user = {<br />
            username: "Mango",<br />
            };<br />
            <br />
            user.showContext = showThis;<br />

            user.showContext(); // window
          </p>
        </div>
      </div>

      <h3 class="m-bottom-min">
        ВИСНОВОК! this у функціях
      </h3>
      <p class="m-bottom">
        <b>this</b> використовується у методах об'єкту,
        функціях, стрілочних функціях та методах функцій,
        таких як <b>call()</b>, <b>apply()</b> та
        <b>bind()</b>
      </p>

      <h3 class="m-bottom-min">Алгоритм визначення this</h3>
      <div class="m-bottom print-flex-box">
        <img
          src="../../images/js/js-this.jpg"
          alt=""
          width="100%"
        />
      </div>
    </section>

    <section>
      <h2 class="m-bottom">Прототипи</h2>
      <div class="m-bottom print-flex-box">
        <div>
          <p class="m-bottom-min">
            <b>Прототипне успадкування</b> - організація
            об'єктів в ланцюжки таким чином, щоб
            здійснювався автоматичний пошук властивості в
            іншому об'єкті, якщо її не знайдено в поточному.
          </p>
          <p class="m-bottom-min">
            Метод <b>Object.create(obj)</b> створює і
            повертає новий об'єкт, зв'язуючи його з об'єктом
            <b>obj</b>.
          </p>
          <p class="m-bottom-min">
            Об'єкт, на який вказує посилання у властивості
            <b>[[Prototype]]</b>, називається прототипом.
            Об'єкт <b>animal</b> — це прототип для об'єкта
            <b>dog</b>.
          </p>
          <p>
            Звертаючись до <b>dog.legs</b>, інтерпретатор
            шукає властивість <b>legs</b> в об'єкті
            <b>dog</b>, не знаходить і продовжує пошук в
            об'єкті за посиланням з <b>[[Prototype]]</b>,
            тобто в цьому випадку в об'єкті <b>animal</b> —
            його прототипі.
          </p>
        </div>
        <div class="bcg-box print-bcg-box">
          <p>
            const animal = {<br />
            legs: 4,<br />
            };<br />
            <br />
            const dog = Object.create(animal);<br />
            dog.name = "Mango";<br />
            <br />
            console.log(dog); <br />
            // { name: "Mango", [[Prototype]]: animal }<br />
            <br />
            console.log(dog.name); // "Mango"<br />
            console.log(dog.legs); // 4
          </p>
        </div>
      </div>

      <h3 class="m-bottom-min">
        Власні і невласні властивості
      </h3>
      <div class="m-bottom print-flex-box">
        <div>
          <p class="m-bottom-min">
            Властивість <b>name</b> належить об'єкту
            <b>dog</b>, тому називається
            <b>власною властивістю</b> об'єкта <b>dog</b>.
          </p>
          <p class="m-bottom-min">
            Властивість <b>legs</b> не належить об'єкту
            <b>dog</b>. Це властивість його
            <i>прототипу</i> <b>animal</b>, тому вона
            називається <b>невласною властивістю</b> об'єкта
            <b>dog</b>. <b>obj</b>.
          </p>
          <p class="m-bottom-min">
            Для перевірки, чи є в об'єкті
            <i>власна властивість</i>, використовується
            метод <b>obj.hasOwnProperty(key)</b>.
          </p>
        </div>
        <div class="bcg-box print-bcg-box">
          <p>
            const animal = {<br />
            legs: 4,<br />
            };<br />
            const dog = Object.create(animal);<br />
            dog.name = "Mango";<br />
            <br />

            console.log(dog.hasOwnProperty("name")); //
            true<br />
            console.log(dog.hasOwnProperty("legs")); //
            false
          </p>
        </div>
      </div>

      <h3 class="m-bottom-min">
        Перебір власних властивостей
      </h3>
      <div class="m-bottom-min print-flex-box">
        <div>
          <p class="m-bottom-min">
            Оператор <b>in</b>, який використовується в
            циклі <b>for...in</b>, не розрізняє власні
            властивості об'єкта і його прототипу. Ця
            особливість заважає, оскільки зазвичай потрібно
            перебрати тільки власні властивості.
          </p>
          <p class="m-bottom-min">
            Для вибору саме <i>власних властивостей</i> під
            час перебору необхідно на кожній ітерації додати
            <i>перевірку</i> на власну властивість
          </p>
        </div>
        <div class="bcg-box print-bcg-box">
          <p>
            const animal = { legs: 4 };<br />
            const dog = Object.create(animal);<br />
            dog.name = "Mango";<br />
            <br />
            for (const key in dog) {<br />
            if(dog.hasOwnProperty(key)) {<br />
            console.log(key); // "name"<br />
            }<br />
            }
          </p>
        </div>
      </div>
      <div
        class="m-bottom print-flex-box print-m-bottom-max"
      >
        <p class="m-bottom-min">
          Методи <b>Object.keys(obj)</b> і
          <b>Object.values(obj)</b> повертають масив
          <i>тільки власних ключів</i> або значень
          <i>тільки власних властивостей</i> об'єкта obj,
          без необхідності додаткових перевірок.
        </p>
        <div class="bcg-box print-bcg-box">
          <p>
            const animal = { legs: 4 };<br />
            const dog = Object.create(animal);<br />
            dog.name = "Mango";<br />
            <br />
            console.log(Object.keys(dog)); // ["name"]<br />
            console.log(Object.values(dog)); // ["Mango"]<br />
            <br />
            for(const key of Object.keys(dog)) {<br />
            console.log(key); // "name"<br />
            }
          </p>
        </div>
      </div>
    </section>

    <section>
      <h2 class="m-bottom">Класи</h2>

      <h3 class="m-bottom-min">Визначення</h3>
      <div class="m-bottom">
        <p class="m-bottom-min">
          <b>Клас</b> — це спосіб опису сутності, що
          визначає структуру та поведінку об'єктів, а також
          правила для взаємодії з цією сутністю (контракт).
          Вони виступають в якості
          <i>шаблонів для створення нових об'єктів</i>.
        </p>
        <p class="m-bottom-min">
          <b>Екземпляр</b> (об'єкт, інстанція) — це окремий
          представник <i>класу</i>, який має дані
          (властивості) і методи (функції), які працюють з
          цими даними. Екземпляр — це те, що створено
          <i>за шаблоном</i>, тобто на підставі опису з
          класу.
        </p>
        <p class="m-bottom-min">
          <b>Інтерфейс</b> — це набір <i>властивостей</i> і
          <i>методів</i> класу, доступних для використання у
          роботі з екземпляром.
        </p>
      </div>

      <h3 class="m-bottom-min">Оголошення класу</h3>
      <div>
        <div class="m-bottom-min print-flex-box">
          <ul class="list-style">
            <li>
              ключове слово <b>class</b> (Класи прийнято
              називати з <b>великої літери</b>, а в назві
              відображати тип об'єкта (іменника), що
              створюється)
            </li>
            <li>ім’я класу (у прикладі: User)</li>
            <li>тіло класу у фігурних дужках</li>
          </ul>
          <div class="bcg-box print-bcg-box">
            <p>
              class User {<br />
              // Тіло класу<br />
              }
            </p>
          </div>
        </div>

        <div class="m-bottom-min print-flex-box">
          <p>
            За допомогою спеціального оператора
            <b>new</b> створюється його <b>екземпляр</b>
          </p>
          <div class="bcg-box print-bcg-box">
            <p>
              class User {<br />
              // Тіло класу<br />
              }<br />
              const mango = new User();
            </p>
          </div>
        </div>

        <div class="m-bottom-min print-flex-box">
          <div>
            <p class="m-bottom-min">
              Метод <b>constructor</b> використовується для
              ініціалізації екземпляра класу
            </p>
            <p class="m-bottom-min">
              Виклик класу з оператором
              <b>new</b> призводить до створення нового
              об'єкта й автоматичного виклику методу
              <i>constructor</i>.
            </p>
            <p class="m-bottom-min">
              <b>Аргументи</b>, які передаються при виклику
              <i>new User()</i>, стають
              <i>значеннями параметрів</i> для методу
              constructor.
            </p>
            <p class="m-bottom-min border-box">
              <b>Цікаво!</b> Якщо його не визначити в явному
              вигляді, то буде створений конструктор за
              замовчуванням — порожня функція, яка не змінює
              екземпляр класу.
            </p>
            <p class="border-box">
              <b>Цікаво!</b> метод constructor викликається
              в контексті створюваного екземпляра.
            </p>
          </div>
          <div class="bcg-box print-bcg-box">
            <p>
              class User {<br />
              constructor(name, email) {<br />
              this.name = name;<br />
              this.email = email;<br />
              }<br />
              }<br />
              <br />
              const mango = new User("Mango",<br />
              "mango@mail.com");<br />
              <br />
              console.log(mango); <br />
              // { name: 'Mango', <br />email:
              'mango@mail.com' }
            </p>
          </div>
        </div>

        <p class="m-bottom-min">
          Властивості name та email називаються
          <b>публічними властивостями</b>, оскільки вони є
          власними властивостями об'єкта-екземпляра.
        </p>

        <div class="m-bottom-min print-flex-box">
          <p>У параметри можна передати об'єкт.</p>
          <div class="bcg-box print-bcg-box">
            <p>
              class User {<br />
              constructor(params) { this.name = params.name;
              } }<br />
              <br />
              const mango = new User({ name: "Mango", });
            </p>
          </div>
        </div>

        <div
          class="m-bottom-min print-flex-box print-m-bottom-max"
        >
          <p>
            До параметра можна застосувати деструктуризацію.
          </p>
          <div class="bcg-box print-bcg-box">
            <p>
              class User {<br />
              constructor({ name, email }) { this.name =
              name;<br />
              this.email = email;<br />
              } }<br />
              <br />
              const mango = new User({<br />
              name: "Mango",<br />
              email: "mango@mail.com",<br />
              });
            </p>
          </div>
        </div>

        <div class="m-bottom-min print-flex-box">
          <p>
            <b>Методи класу</b> — це функції, які будуть
            доступні екземпляру в його прототипі. Вони
            оголошуються в довільному порядку
            <i>після конструктора</i>. Методи класу
            <i
              >не розділені жодними спеціальними
              символами</i
            >.
          </p>
          <div class="bcg-box print-bcg-box">
            <p>
              class User {<br />
              constructor({ name, email }) {<br />
              this.name = name;<br />
              this.email = email;<br />
              }<br />
              <br />
              getEmail() { return this.email; }<br />
              <br />
              changeEmail(newEmail) { this.email = newEmail;
              }<br />
              }
            </p>
          </div>
        </div>

        <div class="m-bottom-min print-flex-box">
          <p>
            Після створення екземпляра можна використовувати
            оголошені методи класу, які будуть звертатися до
            властивостей об'єкта, що їх викликав.
          </p>
          <div class="bcg-box print-bcg-box">
            <p>
              mango.changeEmail("new@mail.com");<br />
              <br />
              console.log(mango.getEmail()); //
              "new@mail.com"
            </p>
          </div>
        </div>
      </div>

      <h3 class="m-bottom-min">Прототип екземпляру</h3>
      <div class="m-bottom-min print-flex-box">
        <div>
          <p class="m-bottom-min">
            Методи класу не стають власними властивостями
            екземпляра. На відміну від значень властивостей,
            вони не є унікальними. Це одна й та сама
            функція, яка викликається в контексті різних
            об'єктів. Немає сенсу копіювати методи для
            кожного екземпляра
          </p>
          <p class="m-bottom-min">
            Методи класу автоматично додаються до
            спеціального об'єкта, який зберігається у
            властивості
            <b>prototype</b> самого класу.
          </p>
          <p>
            При створенні <i>екземпляра</i> через
            <i>new</i>, об'єкт, збережений у властивості
            <i>prototype</i> класу, автоматично стає його
            прототипом. Це означає, що властивість
            <b>[[Prototype]] екземпляра</b>
            <i
              >отримує посилання на властивість prototype
              класу</i
            >.
          </p>
        </div>
        <div class="bcg-box print-bcg-box">
          <p>
            class User {<br />
            constructor({ name, email }) {<br />
            this.name = name;<br />
            this.email = email;<br />
            }<br />
            <br />
            getEmail() {<br />
            return this.email;<br />
            } } <br />
            console.log(User.prototype); <br />
            // {constructor: ƒ, getEmail: ƒ}
          </p>
        </div>
      </div>

      <h3 class="m-bottom-min">Методи класу</h3>
      <div
        class="m-bottom-min print-flex-box print-m-bottom-max"
      >
        <div>
          <p class="m-bottom-min">
            <b>Інкапсуляція</b> — це парадигма ООП, яка
            передбачає приховування деталей внутрішньої
            реалізації класу від зовнішнього коду.
            Інкапсуляція реалізується
            <b>приватними властивостями та методами</b>,
            доступ до яких можна отримати тільки
            <i>всередині класу</i>.
          </p>
          <p class="m-bottom-min">
            Приватною властивість стає при додаванні до її
            імені на початку символ символа
            <b>#</b>. Оголошується приватна властивість до
            ініціалізації в конструкторі.
          </p>
          <p>
            Щоб отримати або змінити значення
            <i>приватної властивості</i> використовуються
            <b>публічні методи</b>.
          </p>
        </div>
        <div class="bcg-box print-bcg-box">
          <p>
            class User {<br />
            constructor({ name, email }) {<br />
            this.name = name;<br />
            this.<b>#</b>email = email;<br />
            }<br />
            <br />
            getEmail() { return this.<b>#</b>email; } <br />
            }<br />
            <br />
            console.log(mango.name); // "Mango"<br />
            console.log(mango.#email); // Виникне помилка<br />
            <br />
            console.log(mango.getEmail());
            <br />// "mango@mail.com"<br /><br />
            mango.changeEmail("mango@supermail.com");<br /><br />
            console.log(mango.getEmail());
            <br />// "mango@supermail.com"<br />
          </p>
        </div>
      </div>

      <div class="m-bottom-min print-flex-box">
        <div>
          <p class="m-bottom-min">
            <b>Приватні методи</b> — дозволяють проводити
            дії, що приховні від користувача. Для цього, до
            імені класу додається символ "#"
          </p>
          <p class="m-bottom-min">
            Метод не доступний ззовні класу, тому
            користувачі (або інші розробники) не можуть його
            викликати напряму. Це безпеку та стабільність
            роботи класу.
          </p>
          <p>
            <i
              >Публічні методи можуть використовавати
              приватні методи</i
            >
          </p>
        </div>
        <div class="bcg-box print-bcg-box">
          <p>
            class User {<br />
            name; #email;<br />
            constructor({ name, email }) {<br />
            this.name = name;<br />
            this.#email = email;<br />
            }<br />

            getEmail() { return this.#email; }<br />

            changeEmail(newEmail) {<br />
            if (this.#validateEmail(newEmail)) {<br />
            this.#email = newEmail;<br />
            } else {<br />
            console.log('Invalid email format');<br />
            } }<br />

            #validateEmail(email) {<br />
            return email.includes('@');<br />
            } }<br />

            const mango = new User({<br />
            name: 'Mango',<br />
            email: 'mango@mail.com',<br />
            });<br />

            mango.changeEmail('new@mail.com');<br />
            console.log(mango.getEmail()); //
            "new@mail.com"<br />

            mango.#validateEmail('test'); // Помилка
          </p>
        </div>
      </div>

      <h3 class="m-bottom-min">Геттери і сеттери</h3>
      <div class="m-bottom-min print-flex-box">
        <div>
          <p class="m-bottom-min">
            <i>Геттери і сеттери</i> — це спеціальний
            синтаксис оголошення методів для взаємодії з
            властивостями. Імітують звичайну публічну
            властивість класу, але дозволяють взаємодіяти з
            іншими властивостями зручнішим способом.
          </p>
          <p class="m-bottom-min">
            Щоб <i>оголосити</i> геттер і сеттер, потрібно
            поставити перед ім'ям властивості відповідні
            ключові слова — <b>get</b> і <b>set</b>
          </p>
          <p class="m-bottom-min border-box">
            <b>Важливо!</b> Геттер і сеттер повинні
            називатися однаково, так само, як і властивість,
            з якою вони працюють.
          </p>
          <p class="border-box">
            <b>Важливо!</b> доречно використовувати для
            простих операцій читання та зміни значення
            властивостей, особливо приватних, як їх
            публічний інтерфейс. Для роботи з властивістю,
            яка зберігає масив або об'єкт, вони не
            підійдуть.
          </p>
        </div>
        <div class="bcg-box print-bcg-box">
          <p>
            class User {<br />
            #email;<br />
            <br />
            constructor({ name, email }) {<br />
            this.name = name;<br />
            this.#email = email;<br />
            }<br />
            <br />
            get email() { return this.#email; }<br />

            set email(newEmail) { this.#email = newEmail;
            }<br />
            }
          </p>
        </div>
      </div>

      <h3 class="m-bottom-min">Статичні властивості</h3>
      <div class="m-bottom-min print-flex-box">
        <div>
          <p class="m-bottom-min">
            <b>Статичні властивості</b> - властивості, що
            доступні тільки класові, але не його
            екземплярам. Корисні для зберігання інформації,
            що стосується класу.
          </p>
          <p class="m-bottom-min">
            Статичні властивості <i>оголошуються</i> в тілі
            класу за допомогою ключового слова
            <b>static</b>. Статичні властивості можна
            використовувати як у методах класу, так і поза
            класом.
          </p>
          <p class="m-bottom-min border-box">
            <b>Важливо!</b> У екземпляра немає доступу до
            статичних властивостей класу.
          </p>
        </div>
        <div class="bcg-box print-bcg-box">
          <p>
            class MyClass {<br />
            static myProp = "value";<br />
            }<br />
            <br />
            console.log(MyClass.myProp); // "value"<br />
            <br />
            const inst = new MyClass();<br />
            console.log(inst.myProp); // undefined
          </p>
        </div>
      </div>
      <div class="m-bottom-min print-flex-box">
        <div>
          <p class="m-bottom-min"><b>Приклад</b></p>
          <p class="m-bottom-min">
            Додамо класу користувача приватну властивість
            role — його роль, що визначає набір прав,
            наприклад: адміністратор, редактор, звичайний
            користувач тощо. Можливі ролі користувачів
            будемо зберігати як статичну властивість roles —
            об'єкт із властивостями.
          </p>
        </div>
        <div class="bcg-box print-bcg-box">
          <p>
            class User {<br />
            static roles = {<br />
            admin: "admin",<br />
            editor: "editor",<br />
            basic: "basic"<br />
            };<br />
            <br />
            #email;<br />
            #role;<br />
            <br />
            constructor({ email, role = User.roles.basic })
            {<br />
            this.#email = email;<br />
            this.#role = role;<br />
            }<br />
            <br />
            get role() { return this.#role; }<br />
            set role(newRole) { this.#role = newRole; }<br />
            }<br />
            <br />
            const mango = new User({<br />
            email: "mango@mail.com",<br />
            role: User.roles.admin,<br />
            });<br />
            <br />
            console.log(mango.role); // "admin"<br />
            mango.role = User.roles.editor;<br />
            console.log(mango.role); // "editor"
          </p>
        </div>
      </div>

      <h3 class="m-bottom-min">Статичні методи</h3>
      <div class="m-bottom-min print-flex-box">
        <div>
          <p class="m-bottom-min">
            <b>Статичні методи</b> — це методи, доступні
            тільки класу. Вони можуть бути
            <b>публічні</b> та <b>приватні</b>.
          </p>
        </div>
        <div class="bcg-box print-bcg-box">
          <p>
            class MyClass {<br />
            static myMethod() { console.log("A static
            method"); }<br />
            }<br />
            <br />
            MyClass.myMethod(); // "A static method"
          </p>
        </div>
      </div>
      <div class="m-bottom-min print-flex-box">
        <div>
          <p class="m-bottom-min"><b>Приклад</b></p>
          <p class="m-bottom-min">
            Додамо у клас User: <br />
            - статичну <i>властивість</i>
            <i>takenEmails</i> для зберігання зайнятих пошт
            користувачів<br />
            - статичний <i>метод</i> <i>isEmailTaken</i>,
            який перевіряє, чи доступна пошта<br />
            <br />
            Під час ініціалізації екземпляра в конструкторі
            класу будемо додавати пошту в список зайнятих.
          </p>
          <p class="m-bottom-min border-box">
            <b>Особливість статичних методів!</b> <br />
            Під час їх виклику ключове слово
            <i>this</i> посилається на сам <i>клас</i>. Це
            означає, що статичний метод може отримати доступ
            до статичних властивостей класу, але не до
            властивостей екземпляра. Це логічно, адже
            статичні методи викликає сам клас, а не його
            екземпляри.
          </p>
        </div>
        <div class="bcg-box print-bcg-box">
          <p>
            class User {<br />
            static #takenEmails = [];<br />
            <br />
            static isEmailTaken(email) {<br />
            return User.#takenEmails.includes(email);<br />
            }<br />
            <br />
            #email;<br />
            <br />
            constructor({ email }) {<br />
            this.#email = email;<br />
            User.#takenEmails.push(email);<br />
            }<br />
            }<br />
            <br />
            const mango = new User({ email: "mango@mail.com"
            });<br />
            <br />
            console.log(User.isEmailTaken("poly@mail.com"));
            // false<br />
            console.log(User.isEmailTaken("mango@mail.com"));
            // true
          </p>
        </div>
      </div>

      <h3 class="m-bottom-min">Наслідування класів</h3>
      <div class="m-bottom-min print-flex-box">
        <div>
          <p class="m-bottom-min">
            Ключове слово <b>extends</b> дозволяє
            реалізувати наслідування класів, коли один клас
            (<i>дочірній, похідний</i>) наслідує властивості
            й методи іншого класу (<i>батьківського</i>).
          </p>
        </div>
        <div class="bcg-box print-bcg-box">
          <p>
            class Parent {} <br />
            <br />
            class Child extends Parent { // ... }
          </p>
        </div>
      </div>
      <div class="m-bottom-min print-flex-box">
        <div>
          <p class="m-bottom-min">
            Базовий (батьківський) клас зберігає загальні
            характеристики й методи для групи похідних
            (дочірніх) класів, які наслідують властивості й
            методи батьківського, але також додають свої
            унікальні.
          </p>
          <p>
            Створюючи незалежні класи для кожного типу
            користувача (наприклад), отримуємо дублювання
            загальних властивостей і методів. Якщо необхідно
            змінити, наприклад, назву властивості,
            доведеться проходити по всіх класах, - це
            незручно й вимагає багато часу.
            <br />

            Замість цього можна:<br />
            <br />

            - створити загальний клас User, який буде
            зберігати набір загальних властивостей і
            методів<br />
            - після чого створити класи для кожного типу
            користувача, які наслідують цей набір від класу
            User
            <br />
            <br />
            За потреби змінити щось спільне, достатньо буде
            змінити тільки код класу User.
          </p>
        </div>
        <div class="bcg-box print-bcg-box">
          <p>
            class User {<br />
            #email;<br />
            <br />
            constructor(email) { this.#email = email; }<br />
            <br />
            get email() { return this.#email; }<br />
            <br />
            set email(newEmail) { this.#email = newEmail;
            }<br />
            }<br />
            <br />
            class ContentEditor extends User {<br />
            // Тіло класу ContentEditor<br />
            }<br />
            <br />
            const editor = new
            ContentEditor("mango@mail.com");<br /><br />
            console.log(editor); <br />// { #email:
            "mango@mail.com" }<br /><br />
            console.log(editor.email); <br />//
            "mango@mail.com"
          </p>
        </div>
      </div>

      <h3 class="m-bottom-min">
        Конструктор дочірнього класу
      </h3>
      <div class="m-bottom-min print-flex-box">
        <div>
          <p class="m-bottom-min">
            <b>super(args)</b> — це спеціальна функція,
            псевдонім конструктора батьківського класу.
            Викликається у конструкторі дочірнього класу
          </p>
          <p class="m-bottom-min border-box">
            <b>Важливо!</b> В іншому випадку при спробі
            звернутися до this у конструкторі дочірнього
            класу виникне помилка.
          </p>
          <p class="m-bottom-min">
            Під час виклику
            <i>конструктора батьківського класу</i>
            передаємо необхідні йому аргументи для
            ініціалізації властивостей.
          </p>
        </div>
        <div class="bcg-box print-bcg-box">
          <p>
            class User {<br />
            #email;<br />
            <br />
            constructor(email) { this.#email = email; }<br />
            <br />
            get email() { return this.#email; }<br />
            <br />
            set email(newEmail) { this.#email = newEmail;
            }<br />
            }<br />
            <br />
            class ContentEditor extends User {<br />
            constructor({ email, posts }) {<br />
            super(email); <br />// Виклик конструктора
            батьківського класу User<br /><br />
            this.posts = posts;<br />
            }<br />
            }<br />
            <br />
            const editor = new ContentEditor({ <br />
            email: "mango@mail.com", <br />
            posts: [] <br />
            });<br />
            console.log(editor); // { #email:
            "mango@mail.com", posts: [] }<br />
            console.log(editor.email); // "mango@mail.com"
          </p>
        </div>
      </div>

      <h3 class="m-bottom-min">Методи дочірнього класу</h3>
      <div class="m-bottom-min print-flex-box">
        <div>
          <p class="m-bottom-min">
            У дочірньому класі можна оголошувати методи, які
            будуть доступні тільки його екземплярам.
          </p>
        </div>
        <div class="bcg-box print-bcg-box">
          <p>
            // Опис класу User вище
            <br />
            <br />
            class ContentEditor extends User {<br />
            constructor({ email, posts }) {<br />
            super(email);<br />
            this.posts = posts;<br />
            }<br />
            <br />
            addPost(post) { this.posts.push(post); }<br />
            }<br />
            <br />
            const editor = new ContentEditor({ <br />
            email: "mango@mail.com", <br />
            posts: [] <br />
            });<br />
            <br />

            editor.addPost("post-1");<br />
            editor.addPost("post-2");<br />
            console.log(editor.posts); // ['post-1',
            'post-2']
          </p>
        </div>
      </div>
    </section>
  </body>
</html>
