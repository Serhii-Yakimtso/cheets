<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0"
    />
    <title>Document</title>
    <link rel="stylesheet" href="../../css/styles.css" />
    <link
      rel="stylesheet"
      href="../../css/styles-print.css"
    />
  </head>
  <body>
    <a class="print-home-link" href="../../index.html"
      >На головну</a
    >
    <h1 class="m-bottom">DOM</h1>

    <section class="m-bottom">
      <h2 class="m-bottom-min">
        Об'єктна модель документа
      </h2>
      <p class="m-bottom-min">
        <b>ECMAScript (ES)</b> — це стандарт, який описує
        мову програмування JavaScript. Цей стандарт визначає
        синтаксис і семантику мови, а також набір вбудованих
        об'єктів і функцій для роботи з даними, текстом,
        датами та іншими аспектами програмування. ECMAScript
        надає основну структуру мови, на якій базується
        JavaScript.
      </p>
      <p class="m-bottom-min">
        <b
          >Об'єктна модель документа (Document Object
          Model)</b
        >
        — незалежний інтерфейс для роботи з
        <b>HTML-документом</b>. Ця модель містить набір
        властивостей і методів, що дозволяють шукати,
        створювати й видаляти елементи, реагувати на дії
        користувача і багато іншого, тобто поєднує сторінку
        з мовою програмування. DOM — це відображення
        HTML-документа.
      </p>
      <p class="m-bottom-min">
        <b
          >Об'єктна модель браузера (Browser Object
          Model)</b
        >
        — незалежний від мови інтерфейс для роботи з
        <b>браузером</b>. Містить набір властивостей і
        методів, що дозволяють отримати доступ до ряду
        функцій браузера. Саме завдяки BOM можна отримувати
        розміри вікна браузера, прокручувати сторінку,
        читати URL, працювати з історією навігації, місцем
        розташування тощо.
      </p>
      <p class="m-bottom-min">
        Згідно з DOM-моделлю, кожен тег утворює окремий
        <b>елемент-вузол</b> (element node), а кожен
        фрагмент тексту всередині елемента —
        <b>текстовий вузол</b> (text node) (містить тільки
        рядок тексту й не може мати дочірніх елементів).
      </p>
      <p class="m-bottom-min">
        В HTML вкладеність визначає відносини батько-дитина
        між елементами. У DOM об'єкти пов'язані в
        деревоподібній структурі даних, фіксуючи ці
        відносини.
      </p>
      <p class="m-bottom-min">
        Браузер будує DOM поступово, щойно надходять перші
        фрагменти коду, він починає парсити HTML, додаючи
        вузли в деревоподібну структуру.
      </p>
      <p class="m-bottom">
        Після того як DOM-дерево побудовано, у ньому можна
        знайти елемент за допомогою JavaScript. Оскільки
        кожен елемент має інтерфейс із безліччю властивостей
        і методів, з ним можна виконувати необхідні дії.
      </p>

      <!-- <h3 class="m-bottom-min">Навігація по DOM</h3>
      <p class="m-bottom-min">
        Елементи DOM-дерева мають ієрархічне відношення один
        до одного. Для опису відносин використовуються
        терміни
        <i
          >предок (ancestor), нащадок (descendant), батько
          (parent), дитина (child) і сусід (sibling)</i
        >.
      </p>
      <p class="m-bottom-min">
        щоб скористатися цими можливостями, спочатку
        потрібно отримати посилання на нього, наприклад, за
        допомогою методу <b>document.querySelector()</b>.
      </p>
      <ul class="list-style m-bottom">
        <li>
          Найвищий елемент називається
          <b>кореневим</b> (root node).
        </li>
        <li>
          Кожен елемент, крім кореневого, має тільки один
          батьківський.
        </li>
        <li>
          В елемента може бути скільки завгодно дітей.
        </li>
        <li>
          <b>Сусіди</b> — це елементи зі спільним
          батьківським елементом.
        </li>
        <li>
          <b>Дочірні елементи (діти)</b> — елементи, що
          безпосередньо вкладені в поточний елемент
          (елементи першого рівня вкладеності).
        </li>
        <li>
          <b>Нащадки</b> — усі елементи, які знаходяться в
          поточному елементі, разом з їхніми дітьми, дітьми
          їхніх дітей тощо. Тобто все на зразок дерева.
        </li>
      </ul> -->
      <table
        class="print-m-bottom-max"
        style="font-size: 14px"
      >
        <caption>
          Властивості навігації DOM
        </caption>
        <thead>
          <tr>
            <th>Властивість</th>
            <th>Опис</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>elem.parentNode</td>
            <td>
              посилання на <b>батьківський</b> вузол-елемент
              вузла elem
            </td>
          </tr>
          <tr>
            <td>elem.childNodes</td>
            <td>
              <i>псевдомасив</i>, у якому зібрані
              <b>всі дочірні</b>
              вузли-елементи і текстові вузли вузла elem
            </td>
          </tr>
          <tr>
            <td>elem.children</td>
            <td>
              <i>псевдомасив</i>, у якому зібрані
              <b>всі дочірні</b> вузли-елементи вузла elem,
              тобто ті, що відповідають тегам
            </td>
          </tr>
          <tr>
            <td>elem.firstChild</td>
            <td>
              <i>посилання</i> на
              <b>перший дочірній</b>вузол (вузол-елемент або
              текстовий вузол) вузла elem
            </td>
          </tr>
          <tr>
            <td>elem.firstElementChild</td>
            <td>
              <i>посилання</i> на
              <b>перший дочірній</b> вузол-елемент усередині
              elem, тобто той, що відповідає тегу
            </td>
          </tr>
          <tr>
            <td>elem.lastChild</td>
            <td>
              <i>посилання</i> на
              <b>останній дочірній</b> вузол (вузол-елемент
              або текстовий вузол) вузла elem
            </td>
          </tr>
          <tr>
            <td>elem.lastElementChild</td>
            <td>
              <i>посилання</i> на
              <b>останній дочірній</b> вузол-елемент
              усередині elem, тобто той, що відповідає тегу
            </td>
          </tr>
          <tr>
            <td>elem.previousSibling</td>
            <td>
              <i>посилання</i> на
              <b>попередній сусідній</b> вузол відносно
              елемента elem, і це може бути як елемент, так
              і текстовий вузол
            </td>
          </tr>
          <tr>
            <td>elem.previousElementSibling</td>
            <td>
              <i>посилання</i> на
              <b>попередній сусідній</b> вузол-елемент
              відносно елемента elem, тобто той, що
              відповідає тегу
            </td>
          </tr>
          <tr>
            <td>elem.nextSibling</td>
            <td>
              <i>посилання</i> на
              <b>наступний сусідній</b> вузол відносно
              елемента elem, і це може бути як елемент, так
              і текстовий вузол
            </td>
          </tr>
          <tr>
            <td>elem.nextElementSibling</td>
            <td>
              <i>посилання</i> на
              <b>наступний сусідній</b> вузол-елемент
              відносно елемента elem, тобто той, що
              відповідає тегу
            </td>
          </tr>
        </tbody>
      </table>
    </section>

    <section class="m-bottom print-m-bottom-max">
      <h2 class="m-bottom-min">Властивості та атрибути</h2>

      <h3 class="m-bottom-min">Доступ до властивостей</h3>
      <div class="m-bottom">
        <p class="m-bottom-min">
          Під час побудови DOM-дерева деякі стандартні
          HTML-атрибути стають властивостями елементів,
          тобто властивостями DOM-об’єктів. Я
        </p>
        <div class="m-bottom-min print-flex-box">
          <p class="m-bottom-min">
            Якщо в HTML є тег то у JS коді можна прочитати
            значення його атрибутів, отримавши посилання на
            елемент, тобто об'єкт, використовуючи
            querySelector, і звернутися до його властивості.
          </p>
          <div class="bcg-box print-bcg-box">
            <p>
              &#60;a class="link"
              href="&#60;https://goit.global&#62;"
              &#62;GoIT&#60;/a &#62;;<br />
              <br />
              const link =
              document.querySelector(".link");<br />
              console.log(link.href); //
              "&#60;https://goit.global&#62;"
            </p>
          </div>
        </div>
        <div class="m-bottom-min print-flex-box">
          <p class="m-bottom-min">
            Значення атрибутів можна змінювати,
            перевизначивши їм нове значення прямо з JS коду,
            і під час виконання скрипта значення в HTML,
            тобто в DOM-дереві, зміниться.
          </p>
          <div class="bcg-box print-bcg-box">
            <p>
              link.href =
              "[&#60;https://neo.goit.global&#62;]
              <br />
              (&#60;https://neo.goit.global/&#62;)";
            </p>
          </div>
        </div>

        <table>
          <caption>
            Властивості елементів DOM
          </caption>
          <thead>
            <tr>
              <th>Властивість</th>
              <th>Опис</th>
              <th>Приклад</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>textContent</td>
              <td>
                <p class="m-bottom-min">
                  Повертає весь текстовий контент усередині
                  елементів (власних і вкладених елементів).
                </p>
                <p>
                  Неважливо, що буде передано в textContent,
                  дані завжди будуть записані як
                  <b>текст</b>.
                </p>
              </td>
              <td>
                &#60;p class="text"&#62; User: &#60;span
                class="sub"&#62;Max&#60;/span&#62;
                &#60;/p&#62; <br />
                <br />
                const el =
                document.querySelector(".text")<br />
                const nested =
                document.querySelector(".sub")<br />
                <br />
                console.log(el.textContent); // "User:
                Mango"<br />
                console.log(nested.textContent); // "Max"<br />
                <br />
                el.textContent = "User: Poly"; // "User:
                Poly"
              </td>
            </tr>
            <tr>
              <td>classList</td>
              <td>
                <p class="m-bottom-min">
                  Дозволяє прочитати, додати, видалити або
                  перевірити наявність CSS-класу в елемента
                  та зберігає об'єкт із методами для роботи
                  з CSS-класами елемента.
                  <b
                    >(див. методи DOM (Методи властивості
                    classList))</b
                  >
                </p>
                <p>
                  Масив зберігає в собі весь перелік класів
                  DOM-елемента, властивість
                  <b>length</b> (кількість класів в
                  елемента) і властивість
                  <b>value</b> (містить точне значення
                  атрибута class).
                </p>
              </td>
              <td>
                console.log(link.classList); <br />
                // ["link", "is-active", length: 2, value:
                "link is-active"]
              </td>
            </tr>
            <tr>
              <td>style</td>
              <td>
                <p class="m-bottom-min">
                  Використовується для читання та зміни
                  інлайнових стилів.
                </p>
                <p class="m-bottom-min">
                  Повертає об'єкт, який містить список лише
                  всіх
                  <b>інлайнових властивостей елемента</b>, а
                  не увесь CSS.
                </p>
                <p class="m-bottom-min">
                  Під час запису властивості вони
                  записуються в <b>camelCase</b> нотації,
                  замість дефісів (<i>background-color</i>
                  буде <i>backgroundColor</i>).
                </p>
                <p class="border-box">
                  <b>Важливо!</b> На практиці стилізація
                  елементів зазвичай виконується шляхом
                  додавання CSS-класів.
                </p>
              </td>
              <td>
                const button =
                document.querySelector(".btn");<br />
                <br />
                button.style.backgroundColor = "teal";<br />
                button.style.fontSize = "24px";<br />
                button.style.textAlign = "center";<br />
                <br />
                console.log(button.style); // inline styles
                object
              </td>
            </tr>
          </tbody>
        </table>
      </div>

      <h3 class="m-bottom-min">Доступ до атрибутів</h3>
      <div class="m-bottom">
        <p>
          DOM-елементам відповідають HTML-теги, які містять
          текстові атрибути. Доступ до атрибутів
          здійснюється за допомогою методів
          <b>(див. Методи DOM (Методи атрибутів))</b>. Ці
          методи працюють зі значенням, яке знаходиться в
          HTML.
        </p>
      </div>

      <h3 class="m-bottom-min">Власні атрибути</h3>
      <div>
        <div class="m-bottom-min">
          <p class="m-bottom-min">
            Власні атрибути ( <b>data-атрибути</b> )
            дозволяють додати до тегу довільний атрибут і
            отримати його значення в JavaScript. Можна
            зберегти певну інформацію на тезі, наприклад,
            вказати тип дії кнопки, щоб потім у певний
            момент часу мати можливість отримати до неї
            доступ.
          </p>
          <div class="bcg-box">
            <p>
              &#60;button type="button"
              data-action="save"&#62; Save text
              &#60;/button&#62;
              <br />
              &#60;button type="button"
              data-action="close"&#62; Close editor
              &#60;/button&#62;
            </p>
          </div>
        </div>
        <div class="print-flex-box m-bottom-min">
          <p class="m-bottom-min">
            Для <b>отримання</b> значення
            <b>data-атрибута</b> використовується
            властивість <b>dataset</b>, після якої
            <i
              >через крапку пишеться ім'я атрибута без
              data-</i
            >. ( "<i>data-</i>" відкидається, а інша частина
            імені записується як ім'я властивості об'єкта.)
          </p>
          <div class="bcg-box print-bcg-box">
            <p>
              const saveBtn =
              document.querySelector('button[data-action="save"]');<br />

              const closeBtn =
              document.querySelector('button[data-action="close"]');<br />
              <br />
              console.log(saveBtn.dataset.action); //
              "save"<br />
              console.log(closeBtn.dataset.action); //
              "close"
            </p>
          </div>
        </div>

        <div class="print-flex-box m-bottom-min">
          <p class="m-bottom-min">
            Щоб <b>змінити</b> значення існуючого
            data-атрибута або <b>додати</b> новий , треба
            отримати доступ до DOM-елемента, а потім
            змінити/задати значення властивості в об'єкті
            <b>dataset</b>.
          </p>
          <div class="bcg-box print-bcg-box">
            <p>
              /
              <i
                >Змінюємо значення data-action для кнопки
                saveBtn</i
              >
              <br />
              saveBtn.dataset.action = "update";<br />
              <br />
              / <i>Додаємо новий data-атрибут data-role</i
              ><br />
              saveBtn.dataset.role = "admin";
            </p>
          </div>
        </div>

        <div class="print-flex-box m-bottom-min">
          <p class="m-bottom-min">
            Для <b>видалення</b> data-атрибута
            використовується оператор <b>delete</b>:
          </p>
          <div class="bcg-box print-bcg-box">
            <p>
              <b>delete</b> saveBtn.dataset.action; <br />

              console.log(saveBtn.dataset.action); //
              undefined
            </p>
          </div>
        </div>

        <div class="m-bottom-min">
          <p class="m-bottom-min">
            <i>data-атрибути</i> часто використовуються з
            <b>кебаб-кейсом</b> (kebab-case), де слова
            розділяються <i>дефісами</i>.
          </p>
          <p class="m-bottom-min">
            Коли потрібно отримати доступ до цих
            <i>data-атрибутів</i> через властивість
            <i>dataset</i>, атрибути в кебаб-кейсі
            перетворюються в <b>кемел-кейс</b> (camelCase).
            Тобто дефіси видаляються, і
            <i
              >наступна літера після кожного дефіса стає
              великою</i
            >. Наприклад, <b>data-user-role</b> стає
            <b>userRole</b> у JavaScript
          </p>
          <div class="bcg-box">
            <p>
              const userBlock=
              document.querySelector('div[data-user-role="admin"]');<br />
              <br />
              // Додаємо новий data-атрибут
              data-user-status<br />
              element.dataset.userStatus = "online";<br />
              <br />
              console.log(element.dataset.userRole); //
              "admin"<br />
              console.log(element.dataset.userStatus); //
              "online"
            </p>
          </div>
        </div>
      </div>
    </section>

    <section class="m-bottom print-m-bottom-max">
      <h2 class="m-bottom-min">
        Створення та видалення елементів
      </h2>

      <div>
        <p>
          DOM API (Document Object Model Application
          Programming Interface) має широкий функціонал. За
          його допомогою можна:
        </p>
        <ul class="m-bottom-min list-style">
          <li>
            вибирати або змінювати вже існуючі елементи
          </li>
          <li>видаляти елементи</li>
          <li>
            створювати нові елементи й додавати їх у
            документ
          </li>
        </ul>
      </div>

      <h3 class="m-bottom-min">Створення елементів</h3>
      <div class="print-flex-box m-bottom-min">
        <div class="m-bottom-min">
          <p>
            Створення елементу з ім'ям <b>tagName</b> і
            <i>повернення посилання на його об’єкт</i>.
          </p>
          <p class="m-bottom-min">
            <b>tagName</b> — це рядок, що вказує тип
            елемента, який створюється.
          </p>
          <p class="border-box">
            <b>Важливо!</b> Елемент створюється в пам'яті, у
            DOM його ще немає.
          </p>
        </div>
        <div class="bcg-box">
          <p>
            document.createElement(<b>tagName</b>)
            <br /><br />
            const heading = document.createElement("h1");
          </p>
        </div>
      </div>

      <div class="print-flex-box m-bottom-min">
        <div class="m-bottom-min">
          <p class="m-bottom-min">
            Після створення елемента можна звертатися до
            властивостей цього об’єкта і змінювати їх ще до
            того, як вставимо цей елемент у DOM.
          </p>
        </div>
        <div class="bcg-box print-bcg-box">
          <p>
            const heading = document.createElement("h1");<br />
            headding.classList.add("title");<br />
            heading.textContent = "This is a heading";<br />
            console.log(heading); // &#60;h1
            class="title"&#62;This is a heading&#62;/h1&#62;
          </p>
        </div>
      </div>

      <h3 class="m-bottom-min">Додавання елементів</h3>
      <div class="print-flex-box m-bottom-min">
        <div class="m-bottom-min">
          <p class="m-bottom-min">
            Щоб створений елемент відображався на сторінці,
            його необхідно
            <i
              >додати до вже існуючого елемента в
              DOM-дереві</i
            >.
          </p>
          <p class="border-box m-bottom-min">
            <b>Важливо!</b> Зверни увагу! Якщо елемент для
            додавання вже знаходиться в DOM, то він
            видаляється зі свого старого місця й додається у
            нове. Отже, є правило: один і той самий елемент
            не може бути одночасно у двох місцях.
          </p>
        </div>
        <div class="bcg-box print-bcg-box">
          <p>
            elem.append(el1, el2, ...) — додає один або<br />
            декілька елементів
            <b>після всіх дітей</b> елемента elem.
            <br /><br />
            elem.prepend(el1, el2, ...) — додає один або<br />
            декілька елементів
            <b>перед усіма дітьми</b> елемента elem.<br /><br />
            elem.after(el1, el2, ...) — додає один або<br />
            декілька елементів
            <b>після елемента</b> elem.<br /><br />
            elem.before(el1, el2, ...) — додає один або<br />
            декілька елементів
            <b>перед елементом</b> elem.<br />
            <br />
            <b>el</b> — це елементи або рядки, у будь-якому
            поєднанні та кількості. <br />Рядки додаються,
            як текстові вузли.
          </p>
        </div>
      </div>

      <h3 class="m-bottom-min">Видалення елементів</h3>
      <div class="print-flex-box m-bottom-min">
        <div class="m-bottom-min">
          <p class="m-bottom-min">
            Щоб видалити елемент, використовується метод
            <b>element.remove()</b>. Викликається на
            елементі element, який необхідно видалити.
          </p>
        </div>
        <div class="bcg-box print-bcg-box">
          <p>
            &#60;p class="text"&#62;Random text
            content&#60;/p&#62; <br />
            const text = document.querySelector(".text")<br />
            text.remove();<br />
          </p>
        </div>
      </div>

      <h3 class="m-bottom-min">Властивість innerHTML</h3>
      <div class="m-bottom-min">
        <div class="print-flex-box m-bottom-min">
          <div class="m-bottom-min">
            <p class="m-bottom-min">
              Властивість innerHTML зберігає вміст елемента,
              включно з тегами, у вигляді рядка. <br />
              Значення, що повертається, — це завжди
              валідний HTML-код.
            </p>
          </div>
          <div class="bcg-box print-bcg-box">
            <p>
              &#60;p class="text"&#62; Lorem ipsum dolor
              &#60;span class="accent"
              <br />&#62;sit&#60;/span&#62; amet
              &#60;/p&#62;
              <br />
              <br />
              const text =
              document.querySelector('.text');<br />
              console.log(text.innerHTML);<br />
              // Lorem ipsum dolor &#60;span
              class="accent"&#62;sit&#60;/span&#62; amet
            </p>
          </div>
        </div>

        <div class="print-flex-box m-bottom-min">
          <div class="m-bottom-min">
            <p class="m-bottom-min">
              Для зміни значення властивості, в неї можна
              записати рядок з HTML-тегами
            </p>
          </div>
          <div class="bcg-box print-bcg-box">
            <p>
              text.innerHTML = '&#60;span class="accent"
              <br />&#62;New&#60;/span&#62; cool text';
            </p>
          </div>
        </div>

        <p class="m-bottom-min border-box">
          <b>Важливо!</b> Якщо у властивість innerHTML
          записати <i>порожній рядок</i>, то вміст елемента
          буде <i>очищено</i>. Це простий і швидкий спосіб
          видалення всього вмісту.
        </p>

        <div class="print-flex-box m-bottom-min">
          <div class="m-bottom-min">
            <p class="m-bottom-min">
              Однотипна (шаблонна) розмітка створюється із
              масиву даних.
            </p>
            <p class="m-bottom-min">
              Прийом полягає в перебиранні цього масиву та
              створенні одного рядка з HTML-тегами, який
              потім записуємо в innerHTML елемента.
            </p>
          </div>
          <div class="bcg-box print-bcg-box">
            <p>
              &#60;ul class="list"&#62;&#60;/ul&#62;<br />
              const technologies = ["HTML", "CSS",
              "JavaScript", "React", "Node"]; <br />
              const list =
              document.querySelector(".list");<br />
              <br />
              const markup = technologies<br />
              .map((technology) => ` &#60;li
              class="list-item"&#62;${technology}&#60;/li&#62;
              `).join("");<br /><br />

              list.innerHTML = markup;
            </p>
          </div>
        </div>

        <p class="m-bottom-min border-box">
          <b>Важливо!</b> Нове значення для
          element.innerHTML повністю видалить і повторно
          створить усіх нащадків елемента element. Якщо
          елемент спочатку не був порожній, то виникнуть
          додаткові витрати на повторне створення вже
          існуючої розмітки, а це погано. <br />
          Використовуй властивість element.innerHTML для
          <b>додавання тільки у разі</b>, <br />
          — коли елемент element порожній <br />
          — якщо потрібно повністю замінити вміст element
        </p>
      </div>

      <h3 class="m-bottom-min">
        Метод insertAdjacentHTML()
      </h3>

      <div>
        <p class="m-bottom-min">
          <b>Метод insertAdjacentHTML()</b> — це сучасний
          метод для додавання рядка з HTML-тегами перед,
          після або всередину елемента. Він вирішує проблему
          <b>innerHTML</b> з повторною серіалізацією вмісту
          елемента під час додавання розмітки до вже
          існуючої.
        </p>
        <div class="m-bottom-min bcg-box">
          <p>
            element.insertAdjacentHTML(position, string)
          </p>
        </div>
        <p>
          Аргумент <b>position</b> — це рядок, який визначає
          позицію щодо елемента element. Він приймає одне з
          чотирьох значень.
        </p>
        <ul class="list-style">
          <li>
            <b>"beforebegin"</b> — перед element (працюєть,
            коли element вже знаходиться в DOM-дереві)
          </li>
          <li>
            <b>"afterbegin"</b> — всередині element, перед
            усіма дітьми
          </li>
          <li>
            <b>"beforeend"</b> — всередині element, після
            усіх дітей
          </li>
          <li>
            <b>"afterend"</b> — після element (працюєть,
            коли element вже знаходиться в DOM-дереві)
          </li>
        </ul>
        <p>
          Аргумент <b>string</b> — рядок з вілідною
          HTML-розміткою або зміна, що її містить
        </p>
      </div>
    </section>

    <section class="m-bottom print-m-bottom-max">
      <h2 class="m-bottom">Події</h2>

      <div class="m-bottom-min">
        <p>
          <b>Подія</b> — це сигнал від браузера про те, що
          на вебсторінці щось відбулося. Події
          використовуються для реакції на дії користувача й
          виконання коду, пов'язаного з певною подією.
        </p>
        <ul class="m-bottom-min list-style">
          <li>події миші,</li>
          <li>події клавіатури,</li>
          <li>події елементів форм,</li>
          <li>зміни розмірів вікна,</li>
          <li>завантаження зображень,</li>
          <li>буфера обміну,</li>
          <li>зміни стадії CSS анімації</li>
          <li>зміни стадії CSS переходу</li>
          <li>тощо</li>
        </ul>
      </div>

      <h3 class="m-bottom-min">Метод addEventListener()</h3>
      <div>
        <p class="m-bottom-min">
          <b>Слухач події</b> — це механізм, який "слухає"
          або "очікує" на виникнення певної події. Метод
          <b>addEventListener()</b> додає слухача події на
          елемент.
        </p>
        <div class="m-bottom-min bcg-box">
          element.addEventListener(event, handler, options)
        </div>
        <ul class="m-bottom-min list-style">
          <li>
            <b>event</b> — рядок, що містить ім'я події,
            наприклад, "click"
          </li>
          <li>
            <b>handler</b> — колбек-функція, яка буде
            викликана під час настання події
          </li>
          <li>
            <b>options</b> — необов'язковий об'єкт
            параметрів із розширеними налаштуваннями
          </li>
        </ul>

        <div class="m-bottom-min bcg-box">
          <p>
            &#60;button
            class="my-button"&#62;Next&#60;/button&#62;
            <br />
            const button =
            document.querySelector(".my-button");<br />
            button.addEventListener("click", () => {
            console.log("The button was pressed and now the
            next image will appear"); });
          </p>
        </div>
        <p class="m-bottom-min">
          Для колбека можна використовувати не анонімну, а
          окрему функцію, передаючи на неї посилання.
        </p>
        <div class="m-bottom-min bcg-box">
          <p>
            const button =
            document.querySelector(".my-button");<br />
            <br />
            const handleClick = () => { console.log("The
            button was pressed and now the next image will
            appear"); };<br />
            <br />
            button.addEventListener("click", handleClick);
          </p>
        </div>
        <p class="m-bottom-min border-box">
          <b>Важливо!</b>
          На одному елементі може бути будь-яка кількість
          обробників подій, навіть подій одного типу.
          Колбек-функції будуть викликатися в порядку їхньої
          реєстрації в коді.
        </p>
      </div>

      <h3 class="m-bottom-min">
        Метод removeEventListener()
      </h3>
      <div class="m-bottom-min">
        <p class="m-bottom-min">
          Метод <b>removeEventListener()</b> видаляє слухача
          події з елемента. Аргументи аналогічні методу
          addEventListener()
        </p>

        <div class="m-bottom-min bcg-box">
          element.removeEventListener(event, handler,
          options)
        </div>

        <div
          class="m-bottom-min print-flex-box print-m-bottom-max"
        >
          <p class="m-bottom-min">
            Для того щоб мати можливість видаляти слухача
            події з елемента через removeEventListener,
            важливо використовувати ту саму
            функцію-обробник, яка була призначена в
            addEventListener. З цієї причини рекомендовано
            для обробників подій використовувати іменовані
            функції, які можна легко передавати як
            аргументи.
          </p>

          <div class="bcg-box print-bcg-box">
            <p>
              const btn =
              document.querySelector(".my-button");<br />
              <br />
              const handleClick = () => { function's body
              };<br />
              <br />
              btn.addEventListener("click", handleClick);<br />
              btn.removeEventListener("click", handleClick);
            </p>
          </div>
        </div>
      </div>

      <h3 class="m-bottom-min">Об'єкт події</h3>
      <div class="m-bottom-min">
        <div class="m-bottom-min print-flex-box">
          <p>
            Кожна подія — це об'єкт, який містить інформацію
            про деталі події та автоматично передається
            першим аргументом в обробник події. Усі події
            відбуваються з базового класу
            <b>Event</b> (зазвичай оголошують як <b>e</b>,
            <b>evt</b> або <b>event</b>).
          </p>
          <div class="bcg-box print-bcg-box">
            <p>
              const handleClick = event => {
              console.log(event); };<br />
              <br />
              button.addEventListener("click", handleClick);
            </p>
          </div>
        </div>

        <div class="m-bottom-min print-flex-box">
          <div class="m-bottom-min">
            <p>Деякі властивості об'єкта події:</p>
            <ul>
              <li><b>event.type</b> — тип події.</li>
              <li>
                <b>event.currentTarget</b> — елемент, на
                якому виконується обробник події.
              </li>
            </ul>
          </div>
          <div class="bcg-box print-bcg-box">
            <p>
              const btn = document.querySelector(".btn");<br />
              <br />
              const handleClick = (event) => {<br />
              console.log("event: ", event);<br />
              console.log("event type: ", event.type);<br />
              console.log("currentTarget: ",
              event.currentTarget);<br />
              };<br />
              <br />
              btn.addEventListener("click", handleClick);
            </p>
          </div>
        </div>
      </div>

      <h3 class="m-bottom-min">Події клавіатури</h3>
      <div class="">
        <div class="m-bottom-min">
          <p>Існує дві основні події клавіатури:</p>
          <ul class="m-bottom-min">
            <li>
              <b>keydown</b> — подія, що відбувається при
              натисканні клавіші
            </li>
            <li>
              <b>keyup</b> — подія, що відбувається, коли
              клавішу відпустили
            </li>
          </ul>
          <div class="m-bottom-min print-flex-box">
            <div>
              <p class="m-bottom-min">
                На відміну від інших подій, події клавіатури
                обробляються на документі, а не на
                конкретному елементі. Об'єкти подій
                клавіатури походять від базового класу
                <b>KeyboardEvent</b>.
              </p>
              <p class="m-bottom-min">
                Події <b>keydown</b> і
                <b>keyup</b> спрацьовують при натисканні
                <i>будь-якої клавіші</i>, включно зі
                службовими (Ctrl, ShiftAltEscape тощо).
              </p>
            </div>
            <div class="bcg-box print-bcg-box">
              <p>
                document.addEventListener("keydown",
                event<br />
                => { console.log("Keydown: ", event); });<br />
                <br />
                document.addEventListener("keyup", event<br />
                => { console.log("Keyup: ", event); });
              </p>
            </div>
          </div>
          <p class="m-bottom-min">
            <i>На практиці</i> переважно обробляють тільки
            подію <b>keydown</b>, оскільки вона відбувається
            швидше за keyup і
            <i
              >користувач раніше бачить результат
              натискання</i
            >.
          </p>
        </div>
      </div>

      <h3 class="m-bottom-min">Властивості key і code</h3>
      <div>
        <div class="m-bottom-min print-flex-box">
          <div class="m-bottom-min">
            <p class="m-bottom-min">
              Властивість об’єкта події <b>key</b> повертає
              символ, згенерований натисканням клавіші на
              клавіатурі. Ця властивість
              <i
                >враховує стан клавіш-модифікаторів
                (наприклад Shift) і поточну мову</i
              >
            </p>
            <p>
              Властивість об’єкта події <b>code</b> повертає
              код фізичної клавіші на клавіатурі й не
              залежить від мови та стану
              клавіш-модифікаторів.
            </p>
          </div>
          <div class="bcg-box print-bcg-box">
            <p>
              document.addEventListener("keydown", event =>
              { <br />
              console.log("key: ", event.key);<br />
              console.log("code: ", event.code);<br />
              });
            </p>
          </div>
        </div>
        <div class="m-bottom-min print-flex-box">
          <div class="m-bottom-min">
            <p class="">
              Для обробки комбінацій клавіш на об'єкті події
              є властивості:
            </p>
            <ul class="list-style">
              <li>
                ctrlKey - якщо клавіша <b>Ctrl</b> була
                активна (зажата) при настанні події
              </li>
              <li>
                altKey - якщо клавіша <b>Alt</b> була
                активна (зажата) при настанні події
              </li>
              <li>
                shiftkey - якщо клавіша <b>Sgift</b> була
                активна (зажата) при настанні події
              </li>
              <li>
                metaKey - якщо клавіша
                <b>Meta</b> (Win/Command) була активна
                (зажата) при настанні події
              </li>
            </ul>
          </div>
          <div class="bcg-box print-bcg-box">
            <p>
              document.addEventListener("keydown",<br />
              event => {<br />
              if ((event.ctrlKey || event.metaKey) <br />&&
              event.code === "KeyS") {<br />
              console.log("«Ctrl + s» or <br />«Command + s»
              combo");<br />
              }<br />
              });
            </p>
          </div>
        </div>
      </div>
    </section>

    <section>
      <h2 class="m-bottom-min">Події елементів форм</h2>

      <h3 class="m-bottom-min">Подія submit</h3>
      <div>
        <div class="m-bottom-min print-flex-box">
          <div>
            <p class="m-bottom-min">
              Відправлення форми відбувається
              <i
                >при кліку на кнопку з атрибутом
                <b>type="submit"</b></i
              >
              або
              <i>при натисканні клавіші <b>Enter</b></i> під
              час перебування в будь-якому її текстовому
              полі форми
            </p>
            <p class="m-bottom-min">
              Подія <b>submit</b> відбувається безпосередньо
              на формі (тег <b>form</b>), тому обробник
              подій слід встановлювати саме на ній.
            </p>
          </div>
          <div class="bcg-box print-bcg-box">
            <p>
              const form =
              document.querySelector("form");<br />
              <br />
              form.addEventListener("submit", event => {
              <br />// ...<br />
              });
            </p>
          </div>
        </div>
        <div class="m-bottom-min print-flex-box">
          <div>
            <p class="m-bottom-min">
              Метод <b>preventDefault()</b> - скасовує дії
              браузера за замовчуванням (клік на посиланні
              ініціює перехід на нову адресу, зазначену в
              href, а відправлення форми перезавантажує
              сторінку.)
            </p>
          </div>
          <div class="bcg-box print-bcg-box">
            <p>
              const form =
              document.querySelector("form");<br />
              form.addEventListener("submit", event => {<br />
              event.preventDefault();<br />
              });
            </p>
          </div>
        </div>
        <div class="m-bottom-min print-flex-box">
          <div>
            <p class="m-bottom-min">
              Подію submit можна застосувати для валідації
              (перевірки) форми перед відправленням,
              оскільки на об'єкті події існує багато
              корисних властивостей, пов'язаних з елементами
              форми.
            </p>
            <p class="m-bottom-min">
              Властивість <b>elements</b> DOM-елемента форми
              містить об'єкт з посиланнями на всі її
              елементи, які мають атрибут name. Саме тому в
              прикладі ми отримуємо значення полів,
              звертаючись до
              <i>event.target.elements.login.value</i> і
              <i>event.target.elements.password.value</i>.
            </p>
          </div>
          <div class="bcg-box print-bcg-box">
            <p>
              const registerForm =
              document.querySelector(".form");<br />
              registerForm.addEventListener("submit",
              handleSubmit);<br />
              function handleSubmit(event) {<br />
              event.preventDefault();<br />
              cont form = event.target;<br />
              const login = form.elements.login.value;<br />
              const password =
              form.elements.password.value;<br />
              <br />
              if (login === "" || password === "") {<br />
              return console.log("Please fill in all the
              fields!");<br />
              }<br />
              console.log(`Login: ${login.value}, Password:
              ${password.value}`);<br />
              form.reset();<br />
              }
            </p>
          </div>
        </div>
      </div>

      <h3 class="m-bottom-min">Подія change</h3>
      <div class="m-bottom">
        <p class="m-bottom-min">
          Подія <b>change</b> відбувається після зміни
          елемента форми. Для текстових полів або
          <i>textarea</i> подія відбудеться не на кожному
          введенні символу, а після <b>втрати</b>
          <b>фокусу</b>. Для <i>select</i>, чекбоксів і
          радіокнопок, подія change спрацьовує відразу під
          час вибору значення.
        </p>
        <div class="m-bottom-min print-flex-box">
          <div
            class="bcg-box print-bcg-box print-m-left-none"
          >
            &#60;p&#62; Selected option text:<br />
            &#60;span class="text-output"&#62;<br />none<br />&#60;/span&#62;<br />
            &#60;/p&#62;<br />
            &#60;p&#62; Selected option value:<br />
            &#60;span class="value-output"&#62;<br />none<br />&#60;/span&#62;<br />
            &#60;/p&#62;<br />
            &#60;p&#62;<br />
            &#60;select class="pizza-select"&#62;<br />
            &#60;option value="four_meats"&#62;<br />Four
            Meats<br />&#60;/option&#62;<br />
            &#60;option value="vegetarian"&#62;<br />Vegetarian<br />&#60;/option&#62;<br />
            &#60;/select&#62;<br />
            &#60;/p&#62;
          </div>

          <div class="bcg-box print-bcg-box">
            const select =
            document.querySelector(".pizza-select");<br />
            const textOutput =
            document.querySelector(".text-output");<br />
            const valueOutput =
            document.querySelector(".value-output");<br />
            <br />
            select.addEventListener("change", setOutput);<br />
            <br />
            function setOutput(event) {<br />
            const selectedOptionValue =
            event.currentTarget.value;<br />
            const selectedOptionIndex =
            event.currentTarget.selectedIndex;<br />
            const selectedOptionText =<br />
            event.currentTarget.options[selectedOptionIndex].text;<br />
            <br />
            textOutput.textContent = selectedOptionText;<br />
            valueOutput.textContent =
            selectedOptionValue;<br />
            }
          </div>
        </div>
      </div>

      <h3 class="m-bottom-min">Подія input</h3>
      <div class="m-bottom">
        <p>
          Подія <b>input</b> відбувається тільки на
          <i>текстових полях</i> і <i>textarea</i>.
        </p>
        <p class="m-bottom-min">
          Вона створюється щоразу при зміні значення
          елемента, не чекаючи втрати фокусу. На практиці
          input — це найголовніша подія для роботи з
          текстовими полями форми.
        </p>
        <p>
          Різниця між подіями <b>input</b> і
          <b>change</b> на <i>текстових полях</i> і
          <i>textarea</i>
        </p>
        <ul class="list-style">
          <li>
            Подія <b>input</b> - відбувається
            <i>при кожній зміні значення</i> (при введенні
            або видаленні), не залежить від втрати фокусу
          </li>
          <li>
            Подія <b>change</b> - відбувається
            <i>після втрати фокусу за умови</i>, що
            відбулася зміна значення в елементі
          </li>
        </ul>
        <div class="print-flex-box">
          <div
            class="bcg-box print-bcg-box print-m-left-none"
          >
            <p>
              &#60;input type="text" class="text-input"
              /&#62; <br />
              &#60;p&#62;Text field value: <br />&#60;span
              class="output"&#62;&#60;/span&#62;<br />&#60;/p&#62;
            </p>
          </div>
          <div class="bcg-box print-bcg-box">
            <p>
              const textInput =
              document.querySelector(".text-input");<br />
              const output =
              document.querySelector(".output");<br />
              <br />
              textInput.addEventListener("input", (event) =>
              {<br />
              output.textContent =
              event.currentTarget.value;<br />
              });
            </p>
          </div>
        </div>
      </div>

      <h3 class="m-bottom-min">Подія focus і blur</h3>
      <div>
        <div>
          <p class="m-bottom-min">
            Подія <b>focus</b> відбувається
            <i>під час фокусування</i> на елементі. Елемент
            <i>отримує фокус</i> під час
            <i>кліку миші</i> або переходу клавішею
            <i>Tab</i>. Отримуючи фокус, завантажити дані
            для автозаповнення, почати відстежувати зміни
            тощо.
          </p>
          <p class="m-bottom-min">
            Подія <b>blur</b> відбувається
            <i>при втраті фокусу</i>, наприклад, користувач
            клікає в іншому місці екрана. Під час втрати
            фокусу можна перевірити введені дані.
          </p>
          <p class="m-bottom-min">
            Активувати або скасувати фокус можна викликавши
            в коді для елемента однойменні методи
            <b>focus()</b> і <b>blur()</b>.
          </p>
          <p class="m-bottom-min">
            <i>Фокус може бути тільки на одному елементі</i>
            сторінки за одиницю часу. Поточний елемент, на
            якому знаходиться фокус, доступний за
            <i>властивістю</i>
            <b>document.activeElement</b>.
          </p>
          <p class="m-bottom-min border-box">
            <b>Важливо!</b> Більшість елементів не можуть
            отримати фокус. Наприклад, якщо клікнути по
            &#60;div&#62;, то фокусування на ньому не
            відбудеться, тому що це не інтерактивний
            елемент.
          </p>
        </div>
        <div class="print-flex-box">
          <div
            class="bcg-box print-bcg-box print-m-left-none"
          >
            &#60;button<br />type="button"<br />
            data-action="set"<br />&#62;<br />
            Set focus to input <br />
            &#60;/button&#62;<br /><br />
            &#60;button<br />
            type="button"<br />
            data-action="remove"<br />&#62;<br />
            Remove focus from input <br />
            &#60;/button&#62;<br />
            <br />
            &#60;input type="text" class="text-input" /&#62;
          </div>
          <div class="bcg-box print-bcg-box">
            const textInput = document.querySelector(<br />".text-input");<br />
            const setFocusBtn = document.querySelector(<br />'[data-action="set"]');<br />
            const removeFocusBtn =
            document.querySelector(<br />'[data-action="remove"]');<br />
            <br />
            setFocusBtn.addEventListener("click", <br />()
            => { textInput.focus(); });<br />
            <br />
            removeFocusBtn.addEventListener("click",<br />
            () => { textInput.blur(); });<br />
            <br />
            textInput.addEventListener("focus",<br />
            () => { textInput.value = "This input has
            focus"; });<br />
            <br />
            textInput.addEventListener("blur",<br />
            () => { textInput.value = ""; });
          </div>
        </div>
      </div>
    </section>
  </body>
</html>
