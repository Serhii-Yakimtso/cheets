<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0"
    />
    <title>Redux</title>
    <script
      type="text/javascript"
      nonce="1ab1cdd14f524de290f066ee4eb"
      src="//local.adguard.org?ts=1716217930715&amp;type=content-script&amp;dmn=mail-attachment.googleusercontent.com&amp;url=https%3A%2F%2Fmail-attachment.googleusercontent.com%2Fattachment%2Fu%2F0%2F%3Fui%3D2%26ik%3De3835ee7bf%26attid%3D0.1%26permmsgid%3Dmsg-f%3A1799578970630561212%26th%3D18f9638a09b29dbc%26view%3Datt%26disp%3Dsafe%26saddbat%3DANGjdJ8AVZhqFXidKag-4a92zHRwVrTJ4RK9FgUapcDG-suJY8lgIgiNV-YjD0ntMGsF-lyMcBUc6cfjYQzaSYhZcZZqJ3atYegd-0lp8MdFYfxz18vf5tqRZgDykZrMTIBXXjSW2cAmvAkfNTlb7haxiRjullznKoHSOAN9bsDnJfi7CyLkQlVCEBDaCxqd2-j0tDFkH4d9iPwmYrYtVpO9HiKF3v7gx1C0mI5T_SbjKZE270Bd4Z_WrWW6LYvya_q4IODuIB7mePeHmAEouJ-96HbUkCxdX5Gw_EEyH7RFUcnldhzI-SWFqHmPG0FH45sX0ykO-IQbzrX5oBe_KimLfQgoN986uEYOgb_5O-fnLBheXEAusB1qF5lvwIfU_n3ditUhzQP905LTxTCCdcpIdYX3kF_7ywtQJjXwJVMVENcWPK12cq8oUTMb8Gn21_55YCDGdOnDYNLGyynO4oeMJzbjgxRNl2hii2E65NpEgiH3m52vjb1rlYuoaZHBm5GOjD0NxaBDfIYmxrbGZkV0jqJVPHC3KfEaWOGCEb8CjlLfLxI_qFIzYOELQk2fFZFlNZyJJrjkZixaR26IbbTqajIlbOD2kTb9mJuTSsNkmGuws4EX34hKFJt5p9xVhJDARygb-B6BV1npPseLs0RK0-tqXm_ITIM_L0mGrSnF4wWCv52pekDB78vbEIXVYmxHpcAcb1Yy-UFAyIiblys297fJwnGjLAqajip3MUvbxVvRdW9kufh-bEODDQI5Gg7Mpi2dTyR4TTjjeoPZdKaBOBWi3aNTCl9b5GKw2qyOd3mtS5P3-lpOql87lTuc7wwO07iDjaMpIqEDwHMEu-capPPEq5uqzA9eD9t_S53-Ss_MG_uqZSTj9RYznyVJuYn6dCC1njoA1RG078EzitGcG-aXP6DDhdEK6kIUEOOtuVnr54goqHABq_wyNH4mdGHpR9UcddhC_BhmnxUcamLL7zSStbodzkrKIXfawn7KrOjGQOKHQMkzaJ0oWd0&amp;app=chrome.exe&amp;css=3&amp;js=1&amp;rel=1&amp;rji=1&amp;sbe=1"
    ></script>
    <script
      type="text/javascript"
      nonce="1ab1cdd14f524de290f066ee4eb"
      src="//local.adguard.org?ts=1716217930715&amp;name=Adguard%20Assistant&amp;name=Adguard%20Popup%20Blocker&amp;name=AdGuard%20Extra&amp;type=user-script"
    ></script>
    <link rel="stylesheet" href="../../css/reset.css" />
    <link rel="stylesheet" href="../../css/react.css" />
  </head>
  <body>
    <a class="print-home-link" href="../../index.html"
      >На головну</a
    >
    <h1 class="m-bottom center-text">Redux</h1>

    <!-- Redux (vanila) -->
    <section class="print-m-bottom-max">
      <h2 class="m-bottom-min center-text">
        Redux (vanila)
      </h2>

      <!-- Управління станом -->
      <div class="m-bottom">
        <div class="m-bottom print-flex-box">
          <div>
            <p class="">
              Redux це бібліотека керування станом програми,
              що стандартизує зберігання та роботу із її
              станом.
            </p>
            <ul class="m-bottom-min list-style">
              <li>
                <b>Передбачуваність результату</b> - існує
                завжди одне джерело правди, стор (сховище,
                store), що приховує у собі стан програми та
                методи для роботи з ним.
              </li>
              <li>
                <b>Підтримуваність</b> - є набір правил та
                кращих практик про те, як повинен бути
                структурований код, що робить його більш
                одноманітним та зрозумілим.
              </li>
              <li>
                <b>Інструменти розробника</b> - зручне
                розширення браузера в якому надається
                максимум інформації про стан програми в
                режимі реального часу.
              </li>
            </ul>

            <div class="m-bottom-min print-flex-box">
              <div>
                <p class="">
                  <b>Бібліотека Redux</b> - набір функцій
                  для створення стора (сховища, store),
                  роботи зі станом програми (state) та
                  відправлення екшенів (дій, actions).
                </p>
              </div>
              <div class="bcg-box print-bcg-box">
                <p><b>npm install redux</b></p>
              </div>
            </div>
            <div class="m-bottom-min print-flex-box">
              <div>
                <p class="">
                  <b>Бібліотека React Redux</b> - набір
                  компонентів та хуків зв'язуючих
                  компонентів React та Redux стор (store).
                </p>
              </div>
              <div class="bcg-box print-bcg-box">
                <p><b>npm install react-redux</b></p>
              </div>
            </div>

            <p class="m-bottom-min">
              <b>Стора</b> (сховище, store) відповідає за
              централізоване зберігання всього стану та
              надає набір правил та методів для його зміни.
              Компонентам залишається викликати методи для
              оновлення даних та підписатися на оновлення.
              Потік даних у Redux завжди односпрямований,
              від компонентів до стору, та від стора до
              компонентів без посередників.
            </p>

            <p>Алгоритм дії:</p>
            <ul class="m-bottom-min list-style">
              <li>
                Користувач, працюючи з інтерфейсом,
                ініціалізує відправку <b>екшенів</b> (дій,
                actions).
              </li>
              <li>
                <b>Стор</b> (store) викликає всі оголошені
                <b>редюсери</b> (reducers), функції для
                зміни стану, передаючи їм поточний
                <b>стан</b> (state) та <b>екшен</b> (дія,
                action).
              </li>
              <li>
                <b>Стор</b> (store) зберігає оновлений
                <b>стан</b> (state) повернутий з
                <b>редюсерів</b> (reducers).
              </li>
              <li>
                При оновленні <b>стану</b> (state) повторно
                рендеруються залежні від нього компоненти.
              </li>
            </ul>
          </div>
        </div>
      </div>

      <!-- Створення структури для Redux -->
      <div class="m-bottom print-m-bottom-max">
        <h3 class="m-bottom-min">
          Створення структури для Redux
        </h3>

        <!-- Структура файлів проекту -->
        <div class="m-bottom print-flex-box">
          <div>
            <p class="">
              Для відокремлення логіки Redux від коду
              компонентів, необхідно зробити папку
              <b>src/redux</b> з кількома файлами.
            </p>
            <ul class="m-bottom-min">
              <li>
                <b>actions.js</b> - файл оголошення екшенів
                програми
              </li>
              <li>
                <b>reducer.js</b> - файл оголошення
                функцій-редюсерів для оновлення стану
              </li>
              <li>
                <b>constants.js</b> - файл для зберігання
                констант (наприклад значень фільтру статусу)
              </li>
              <li>
                <b>selectors.js</b> - файл оголошення
                функцій-селекторів
              </li>
              <li>
                <b>store.js</b> - файл створення стор Redux
              </li>
            </ul>
            <p class="">
              Якщо в додатку багато різних даних, то підійде
              «<i>feature based</i>» підхід, де під кожну
              сутність створюється окрема папка усередині
              папки redux. Більше файлів, але код логіки
              Redux поділений на сутності та більш
              структурований.
            </p>
          </div>
          <div class="bcg-box print-bcg-box print-fs-14">
            <p>
              src/<br />
                  - components/<br />
              <b>
                    - redux/<br />
                        - actions.js <br />
                        - reducer.js <br />
                        - constants.js<br />
                        - selectors.js<br />
                        - store.js<br />
              </b>
                  - index.js
            </p>
          </div>
          <div class="bcg-box print-bcg-box print-fs-14">
            <p>
              src/<br />
                  - components/<br />
              <b>
                    - redux/<br />
                        - tasks/<br />
                            - actions.js <br />
                            - reducer.js <br />
                            - constants.js<br />
                            - selectors.js<br />
                        - filters/<br />
                            - actions.js <br />
                            - reducer.js <br />
                            - constants.js<br />
                            - selectors.js<br />
                        - store.js<br />
              </b>
                  - index.js
            </p>
          </div>
        </div>

        <!-- Проектування стану -->
        <h4 class="m-bottom-min">Проектування стану</h4>
        <div class="m-bottom print-flex-box">
          <div>
            <p class="m-bottom-min">
              Інтерфейс програми повинен ґрунтуватися на
              його стані. Необхідно спроектувати стан
              програми, яка міститиме найменшу кількість
              значень, достатню для опису всього необхідного
              функціоналу.
            </p>
            <p class="m-bottom-min">
              <b>Стан</b> Redux це завжди <i>об'єкт</i>,
              всередину якого додаються властивості для
              стану програми.
            </p>
            <p>
              Стан об'являється у файлі <b>reducers.js</b>
            </p>
          </div>
          <div class="bcg-box print-bcg-box print-fs-14">
            <p>
              const <b>initialState</b> = {<br />
                  tasks: [<br />
                      { id: 0, text: "Learn HTML & CSS",
              completed: true },<br />
                      { id: 1, text: "Get good at JS",
              completed: true },<br />
                      { id: 2, text: "Master React",
              completed: false },<br />
                  ],<br />
                  filters: {<br />
                      status: "all",<br />
                  },<br />
              };
            </p>
          </div>
        </div>
      </div>

      <!-- Стор (store) -->
      <div class="m-bottom">
        <h3 class="m-bottom-min">Стор (store)</h3>
        <p class="m-bottom-min">
          Стор (store) - об'єкт, який містить повний стан
          програми, методи доступу до стану та відправлення
          екшенів. У програмі може бути лише один стор.
        </p>

        <div class="print-flex-box">
          <div>
            <p class="">
              Для створення стора є функція
              <b>createStore()</b>, яка приймає кілька
              параметрів та повертає новий об'єкт стора.
            </p>
          </div>
          <div>
            <div class="bcg-box print-bcg-box">
              <p>
                <b
                  >createStore(reducer, preloadedState,
                  enhancer)</b
                >
              </p>
            </div>
          </div>
        </div>
        <ul class="m-bottom-min list-style">
          <li>
            <b>reducer</b> - функція із логікою зміни стану
            Redux. Обов'язковий параметр.
          </li>
          <li>
            <b>preloadedState</b> - початковий стан
            програми. Це має бути об'єкт тієї ж форми, що й,
            як мінімум, частина стану. Необов'язковий
            параметр.
          </li>
          <li>
            <b>enhancer</b> - функція розширення можливостей
            стору. Необов'язковий параметр.
          </li>
        </ul>

        <div class="m-bottom print-flex-box">
          <div
            class="bcg-box print-bcg-box print-m-left-none print-fs-14"
          >
            <p>
              <i>// src/redux/store.js</i><br />
              <br />
              <b>import { createStore } from "redux"</b
              >;<br />
              <br />
              <i
                >// Початкове значення стану Redux для
                кореневого<br />
                // редюсера, якщо не передати параметр
                preloadedState.<br
              /></i>
              const <b>initialState</b> = {<br />
                  tasks: [<br />
                      { id: 0, text: "Learn HTML&CSS",
              completed: true },<br />
                      { id: 1, text: "Get good at JS",
              completed: true },<br />
                      { id: 2, text: "Master React",
              completed: false },<br />
                  ],<br />
                  filters: {<br />
                      status: "all",<br />
                  },<br />
              };<br />
              <br />
              <i
                >// Поки що використовуємо редюсер який<br />
                // тільки повертає отриманий стан<br
              /></i>
              const <b>rootReducer</b> = (state =
              <b>initialState</b>, action) => {<br />
                  return state;<br />
              };<br />
              <br />
              export const
              <b>store = createStore(rootReducer)</b>;
            </p>
          </div>

          <div>
            <p class="m-bottom-min">
              Після створення стору необхідно зв'язати його
              з компонентами React, щоб вони могли
              отримувати доступ до стору та його методів.
              Для цього у бібліотеці React Redux є компонент
              <b>Provider</b>, котрий чекає однойменний
              пропс store. Для того щоб будь-який компонент
              у додатку міг використовувати стор, обертаємо
              <b>Provider</b> все <i>дерево компонентів</i>.
            </p>

            <div class="bcg-box print-bcg-box print-fs-14">
              <p>
                <i>// src/main.jsx</i>
                <br />
                import React from 'react';<br />
                import ReactDOM from 'react-dom/client';<br />
                import { App } from './components/App';<br />
                import { store } from "./redux/store";<br />
                <br />
                ReactDOM.createRoot(document.getElementById('root'))<br />
                    .render(<br />
                        &#60;React.StrictMode><br />
                           
                <b>&#60;Provider store={store}></b><br />
                                &#60;App /><br />
                            <b>&#60;/Provider></b><br />
                        &#60;/React.StrictMode><br />
                );
              </p>
            </div>
          </div>
        </div>
      </div>

      <!-- Redux DevTools -->
      <div class="m-bottom print-m-bottom-max">
        <h3 class="m-bottom-min">Redux DevTools</h3>
        <p class="m-bottom-min">
          Інструменти розробника, розширення браузера, яке
          додає зручний візуальний інтерфейс для
          налагодження змін стану програми та стеження за
          потоком даних у Redux, від відправлення дій до
          зміни стану.
        </p>

        <div class="m-bottom print-flex-box">
          <div>
            <p class="">
              Бібліотека Redux DevTools дозволяє
              ініціалізувати логіку Redux DevTools та
              зв'язати її з розширенням в інструментах
              розробника.
            </p>
          </div>
          <div class="bcg-box print-bcg-box">
            <p>
              <b>npm install @redux-devtools/extension</b>
            </p>
          </div>
        </div>

        <div class="m-bottom print-flex-box">
          <div>
            <p class="m-bottom-min">
              Імпортуємо функцію <b>devToolsEnhancer</b> і
              використовуємо її при створенні стора,
              передавши її результат третім аргументом,
              замість початкового стану.
            </p>
            <p class="">
              Після запуску проекту командою
              <b>npm start</b>, у стандартних інструментах
              розробника з'явиться нова вкладка Redux, при
              переході на яку відкриються Redux DevTools зі
              списком відправлених екшенів зліва та
              детальною інформацією про стан та екшени
              праворуч.
            </p>
          </div>
          <div class="bcg-box print-bcg-box print-fs-15">
            <p>
              <i>// src/redux/store.js</i><br />
              <br />
              import { <b>devToolsEnhancer</b> } from
              "@redux-devtools/extension";<br />
              <br />
              <i>// Попередній код</i><br />
              <br />
              <i>
                // Створюємо розширення стора, щоб додати<br />
                інструменти розробника<br />
              </i>
              const <b>enhancer</b> =
              <b>devToolsEnhancer</b>();<br />
              <br />

              export const store = createStore(rootReducer,
              <b>enhancer</b> );
            </p>
          </div>
        </div>
      </div>

      <!-- Підписка на стор -->
      <div class="m-bottom">
        <h3 class="m-bottom-min">Підписка на стор</h3>
        <div class="m-bottom print-flex-box">
          <div>
            <p class="m-bottom-min">
              Щоб отримати дані зі стору, компоненти повинні
              підписатися на необхідні їм частини стану
              Redux. Для цього у бібліотеці React Redux є
              хук
              <b>useSelector(selector)</b>. Аргументом він
              приймає функцію, яка оголошує один параметр
              <b>state</b> - весь об'єкт стану Redux, який
              буде автоматично переданий функції хуком
              useSelector. Ця функція називається
              <i>селектором</i> і повинна повернути тільки
              ту частину стану, яка необхідна компоненту.
            </p>
          </div>
          <div class="bcg-box print-bcg-box print-fs-14">
            <p>
              <i>// Імпортуємо хук</i><br />
              import { <b>useSelector</b> } from
              "react-redux";<br />
              <br />
              const StatusFilter = () => {<br />
                  <i>// Отримуємо необхідну частину стану</i
              ><br />
                  const filter =
              <b
                >useSelector(<br />
                        state => state.filters.status<br />
                    )</b
              >;<br />
              };
            </p>
          </div>
        </div>

        <!-- Функції-селектори -->
        <h4 class="m-bottom-min">Функції-селектори</h4>
        <p class="m-bottom-min">
          Один і той же селектор може використовуватися в
          декількох місцях програми, що призводить до
          дублювання коду.
        </p>

        <div class="m-bottom print-flex-box">
          <div>
            <p class="">
              Щоб уникнути цього, всі функції-селектори
              оголошуються в окремому файлі, наприклад, в
              <b>src/redux/selectors.js</b>, після чого
              <i>імпортуються</i> до <i>компонентів</i>.
            </p>
          </div>
          <div class="bcg-box print-bcg-box print-fs-14">
            <p>
              <i> // src/redux/selectors.js</i><br />
              <br />
              export const
              <b>getTasks = state => state.tasks</b>;<br />
              export const
              <b
                >getStatusFilter = state =>
                state.filters.status</b
              >;
            </p>
          </div>
        </div>
      </div>

      <!-- Екшени (actions) -->
      <div class="m-bottom">
        <h3 class="m-bottom-min">Екшени (actions)</h3>

        <div class="m-bottom-min print-flex-box">
          <div>
            <p class="m-bottom-min">
              <b>Екшени (actions)</b> - це об'єкти, які
              передають дані з компонентів у стор, тим самим
              сигналізуючи про те, яка подія сталася в
              інтерфейсі. Вони являються єдиним джерелом
              інформації для стору.
            </p>
          </div>
          <div class="bcg-box print-bcg-box print-fs-14">
            <p>
              <i>// src/redux/actions.js</i><br />
              const action = {<br />
                  type: "Action type",<br />
                  payload: "Payload value",<br />
              };<br />
            </p>
          </div>
        </div>
        <div class="m-bottom-min print-flex-box">
          <div>
            <p class="m-bottom-min">
              Екшени повинні мати обов'язкову властивість
              <b>type</b> - рядок який описує тип події в
              інтерфейсі.
            </p>
            <p class="m-bottom-min">
              Крім властивості type структура об'єкта може
              бути довільною, проте, дані зазвичай передають
              у необов'язковій властивості <b>payload</b>.
            </p>
            <p>
              Властивість <i>id: "Generated id"</i> буде
              генерувати бєкенд, а без нього можна через
              бібліотеку nanoid
            </p>
            <p class="">
              Даними екшену може бути будь-яке значення крім
              функцій та класів.
            </p>
          </div>
          <div class="bcg-box print-bcg-box print-fs-14">
            <p>
              const addTask = {<br />
                  type: "tasks/addTask",<br />
                  payload: {<br />
                      id: "Generated id",<br />
                      text: "User entered text",<br />
                      completed: false,<br />
                  },<br />
              };
            </p>
          </div>
        </div>
        <p class="m-bottom-min border-box">
          <b
            >Найменування поля type у форматі
            <i>domain/eventName</i>.</b
          >
          <b>Перше</b> це ім'я b
          <b>категорії (сутності)</b> до якої належить екшен
          (<i>tasks та filters</i>), зазвичай збігається з
          ім'ям властивості частини стану Redux, і
          <b>друге</b> це <b>подія</b>, яка описує екшен (<i
            >addTask, deleteTask, toggleCompleted,
            setStatusFilter</i
          >).
        </p>

        <!-- Генератори екшенів -->
        <h4 class="m-bottom-min">Генератори екшенів</h4>
        <div
          class="m-bottom print-flex-box print-m-bottom-max"
        >
          <div>
            <p class="m-bottom-min">
              Екшени це <i>статичні об'єкти</i>, значення
              властивості <b>payload</b> яких неможливо
              задати динамічно.
              <b>Генератори екшенів</b> (Action Creators) -
              <i>функції</i>, які можуть приймати
              <i>аргументи</i>, після чого створюють та
              повертають екшени
              <i>з однаковим значенням властивості type</i>,
              але <i>різними payload</i>. Вони можуть мати
              побічні ефекти, наприклад, заповнювати
              властивості за замовчуванням або генерувати
              унікальний ідентифікатор об'єкта завдання.
            </p>
          </div>
          <div class="bcg-box print-bcg-box print-fs-14">
            <p>
              <i>// src/redux/actions.js</i><br />
              <br />
              import { nanoid } from "nanoid";<br />
              <br />
              export const addTask = text => {<br />
                 return
              <b
                >{ <br />
                       type: "tasks/addTask",<br />
                       payload: {<br />
                           id: nanoid(),<br />
                           completed: false,<br />
                           text,<br />
                       },<br />
                    }</b
              >;<br />
              };
            </p>
          </div>
        </div>

        <!-- Відправлення екшенів -->
        <h4 class="m-bottom-min">Відправлення екшенів</h4>
        <div class="m-bottom print-flex-box">
          <div>
            <p class="m-bottom-min">
              Для того щоб сповістити сторінку про те, що в
              інтерфейсі відбулася якась подія, необхідно
              відправити екшен за допомогою хуку
              <b>useDispatch()</b>. Він повертає посилання
              на функцію надсилання екшенів <b>dispatch</b>
              з об'єкта створеного нами раніше стора Redux.
            </p>
          </div>
          <div class="bcg-box print-bcg-box print-fs-14">
            <p>
              <i>// src/components/TaskForm/TaskForm.jsx</i
              ><br />

              <i>// Імпортуємо хук</i><br />
              import { <b>useDispatch</b> } from
              "react-redux";<br />
              <i>// Імпортуємо генератор екшену</i><br />
              import { addTask } from
              "../../redux/actions";<br />
              <br />
              export const TaskForm = () => {<br />
                  ><br />
                  const
              <b>dispatch = useDispatch()</b>;<br />
              <br />
                  const handleSubmit = event => {<br />
                      event.preventDefault();<br />
                      const form = event.target;<br />
                     
              <b
                >dispatch(addTask(form.elements.text.value))</b
              >;<br />
                      <br />
                      form.reset();<br />
                  };<br />
              <br />
                  return (<br />
                      &#60;form
              onSubmit={handleSubmit}>...&#60;/form><br />

                  );<br />

              };
            </p>
          </div>
        </div>
      </div>

      <!-- Редюсери (reducers) -->
      <div class="m-bottom">
        <h3 class="m-bottom-min">Редюсери (reducers)</h3>
        <div class="m-bottom-min print-flex-box">
          <div>
            <p class="">
              <b>Редюсер (reducer)</b> - це функція, яка
              приймає поточний стан та екшен як аргументи і
              повертає новий стан. Редюсер визначає, як
              змінюється стан програми у відповідь на
              екшени, надіслані на стор.
            </p>
          </div>
          <div class="bcg-box print-bcg-box">
            <p>(state, action) => nextState</p>
          </div>
        </div>
        <p class="m-bottom-min border-box">
          <b>Важливо!</b> Екшени описують тільки те, що
          сталося, а не як змінюється стан програми..
        </p>

        <!-- Кореневий редюсер -->
        <h4 class="m-bottom-min">Кореневий редюсер</h4>
        <div class="print-flex-box">
          <div>
            <p class="m-bottom-min">
              У додатку завжди буде лише <b>один</b>
              <b>кореневий редюсер</b>, який потрібно
              передати до <b>createStore</b>
              під час створення стора. Цей редюсер
              відповідає за обробку всіх відправлених
              екшенів та обчислення нового стану.
            </p>
            <p class="m-bottom-min border-box">
              <b>Важливо!</b> При ініціалізації стора всім
              редюсерам у якості значення стану передається
              <i>undefined</i>. Тому кожному редюсеру
              необхідно вказати значення
              <i>за замовчуванням</i> для параметра
              <b>state</b>, яке стане початковим станом
              програми.
              <b>&#60;product&#62;&#60;/product&#62;</b>.
            </p>
            <p class="m-bottom-min border-box">
              <b>Цікаво!</b> Редюсер розрізняє екшени за
              значенням властивості <b>type</b>. Залежно від
              типу екшену виконуватиметься
              <i>різна логіка</i><br />
            </p>
            <p class=""><b>Правила редюсерів</b></p>
            <ul class="list-style">
              <li>
                Не можна змінювати аргументи (<b>state</b>
                та <b>action</b>). Редюсери мають лише
                обчислювати нове значення стану з
                урахуванням цих аргументів.
              </li>
            </ul>
          </div>
          <div class="bcg-box print-bcg-box print-fs-14">
            <p>
              <i>// src/redux/reducers.js</i><br />
              import { statusFilters } from
              "./constants";<br />
              <br />
              const initialState = {<br />
                      ...<br />
              };<br />
              <br />
              export const rootReducer = (state =
              initialState, action) => {<br />

                  switch (action.type) {<br />

                      case "tasks/addTask": {<br />
                          return {<br />
                            ...state,<br />
                            tasks: [<br />
                                ...state.tasks,<br />
                                action.payload,<br />
                            ],<br />
                          };<br />
                      }<br />
                      default:<br />
                          return state;<br />
                  }<br />
              };
            </p>
          </div>
        </div>

        <ul class="m-bottom-min list-style">
          <li>
            Не можна змінювати стан (<b>state</b>).
            Натомість редюсери повинні робити оновлення,
            копіюючи існуючий стан та вносячи зміни до
            копії.
          </li>
          <li>
            Редюсери <b>не повинні виконувати</b> жодних
            <i>«побічних ефектів»</i>. Наприклад, запуск
            таймера, виконання HTTP-запиту, зміна значення
            поза функцією або її аргументів, генерація
            випадкових чисел чи рядків тощо.
          </li>
        </ul>

        <!-- Композиція редюсерів -->
        <h4 class="m-bottom-min">Композиція редюсерів</h4>
        <div class="m-bottom print-flex-box">
          <div>
            <p class="m-bottom-min">
              Зазвичай редюсери поділяються ґрунтуючись на
              частинах стану Redux які вони оновлюють.
              Розділимо обробку екшенів завдань та зміни
              фільтра на два незалежних редюсера. Кожен
              редюсер відповідатиме лише за свою частину
              стану Redux, тому код оновлення стану буде
              значно простіше.
            </p>
            <p class="m-bottom">
              Тепер у нас є два окремі редюсери, але при
              створенні стора необхідно передати один
              кореневий редюсер, який відповідає за весь
              стан Redux. Ми можемо написати кореневий
              редюсер так, щоб він просто викликав два інші
              редюсери і передавав їм необхідну частину
              стану та екшен. Це і є
              <b>композиція редюсерів</b>.
            </p>

            <div class="border-box m-bottom">
              <p class="m-bottom-min">
                Щоб не створювати кореневий редюсер вручну,
                у бібліотеці Redux є функція
                <b>combineReducers</b>, яка робить те саме,
                але коротше.
              </p>

              <div class="bcg-box">
                <p>
                  import { <b>combineReducers</b> } from
                  "redux";<br />
                  <br />
                  export const <b>rootReducer</b> =
                  <b>combineReducers</b>({<br />
                      tasks: <b>tasksReducer</b>,<br />
                      filters: <b>filtersReducer</b>,<br />
                  });
                </p>
              </div>
            </div>

            <div class="border-box">
              <p class="m-bottom-min">
                <b>Слайси</b> (slices, шматочки) - частина
                стану Redux, що групує інщі дані, які
                відносятся до певного інтерфейсу чи іншим
                даним, пов'язаних спільною логікою. По факту
                - слайси - це властивості стану першого
                рівня вкладеності.
              </p>
              <div class="print-flex-box">
                <p>
                  Можна сказати, що композиція редьюсерів
                  залежить від слайсів
                </p>
                <div class="bcg-box print-bcg-box">
                  <p>
                    const initialState = {<br />
                        <b>tasks</b>: [ {...}, {...} ],<br />
                        <b>filters</b>: {<br />
                            status: "all",<br />
                        },<br />
                    };
                  </p>
                </div>
              </div>
            </div>
          </div>
          <div class="bcg-box print-bcg-box print-fs-14">
            <p>
              <i>// src/redux/reducers.js</i><br />
              <br />
              const tasksInitialState = [<br />
                  ... <i>// дані початкового стану</i><br />
              ];<br />
              <br />
              const <b>tasksReducer</b> = (state =
              tasksInitialState, action) => {<br />
                  switch (action.type) {<br />
                      case "tasks/addTask":<br />
                          return [...state,
              action.payload];<br />
                      case "tasks/deleteTask":<br />
                          return state.filter(task =>
              task.id !== action.payload);<br />
                      case "tasks/toggleCompleted":<br />
                          return state.map(task => {<br />
                              if (task.id !==
              action.payload) {<br />
                                  return task;<br />
                              }<br />
                              return { ...task, completed:
              !task.completed };<br />
                          });<br />
                      default:<br />
                          return state;<br />
                  }<br />
              };<br />
              <br />
              const filtersInitialState = {<br />
                  status: statusFilters.all,<br />
              };<br />
              <br />
              const <b>filtersReducer</b> = (state =
              filtersInitialState, action) => {<br />
                  switch (action.type) {<br />
                      case "filters/setStatusFilter":<br />
                          return {<br />
                              ...state,<br />
                              status: action.payload,<br />
                          };<br />
                      default:<br />
                          return state;<br />
                  }<br />
              };<br />
              <br />
              export const <b>rootReducer</b> = (state = {},
              action) => {<br />
                  return {<br />
                      tasks: tasksReducer(state.tasks,
              action),<br />
                      filters: filtersReducer(state.filters,
              action),<br />
                  };<br />
              };
            </p>
          </div>
        </div>
      </div>

      <!-- Висновки -->
      <div class="m-bottom print-m-bottom-max">
        <h3 class="m-bottom-min">Висновки</h3>
        <div class="m-bottom">
          <div>
            <p>Алгоритм використання Redux</p>
            <ul
              class="list-style"
              style="min-width: max-content"
            >
              <li>Створити <b>Store</b></li>
              <li>Оголосити <b>початковий стан</b></li>
              <li>
                Створити базовий Reducer
                (<b>rootReducer</b>)
              </li>
              <li>
                <b>Provider</b>'ом огорнути <b>App</b> (у
                main.js) та передати <b>store</b>
              </li>
              <li>Створити компонент</li>
              <li>
                Оголосити <b>useSelector</b> у компоненті
                для підписання на зміну частини стану
              </li>
              <li>Оголосити <b>actions</b></li>
              <li>
                <b>dispatch</b> actions із компоненту при
                подіях
              </li>
              <li>
                Обробити <b>actions</b> у <i>reducer</i>'і
              </li>
            </ul>
          </div>
        </div>
      </div>

      <!-- Приклад -->
      <div class="">
        <h3 class="m-bottom-min center-text">Приклад</h3>
        <div class="print-flex-box print-fs-12">
          <div
            class="print-bcg-box"
            style="margin-right: auto"
          >
            <!-- <p>Стан (Store)</p> -->
            <div
              class="bcg-box print-m-left-none"
              style="margin-right: auto; margin-bottom: 8px"
            >
              <p>
                <i>// src/redux/store.js</i><br />

                import { createStore, combineReducers } from
                "redux";<br />
                import { balanceReducer } from
                "./balanceSlice";<br />
                import { localeReducer } from
                "./localeSlice";<br />
                <br />
                const rootReducer = combineReducers({<br />
                    balance: balanceReducer,<br />
                    locale: localeReducer,<br />
                });<br />
                export const store =
                createStore(rootReducer);
              </p>
            </div>

            <!-- <p>balanceSlice</p> -->
            <div
              class="bcg-box print-m-left-none"
              style="margin-right: auto; margin-bottom: 8px"
            >
              <p>
                <i>// src/redux/balanceSlice.js </i><br />
                export const deposit = (value) => {<br />
                    return {<br />
                        type: "balance/deposit",<br />
                        payload: value,<br />
                    };<br />
                };<br />
                export const withdraw = (value) => {<br />
                    return {<br />
                        type: "balance/withdraw",<br />
                        payload: value,<br />
                    };<br />
                };<br />
                export const balanceReducer = (<br />
                        state = {value: 1000 },<br />
                        action<br />
                    ) => {<br />
                        switch (action.type) {<br />
                            case "balance/deposit":<br />
                                return {<br />
                                    ...state,<br />
                                    value: state.value +
                action.payload,<br />
                                };<br />
                            case "balance/withdraw":<br />
                                return {<br />
                                    ...state,<br />
                                    value: state.value -
                action.payload,<br />
                                };<br />
                            default:<br />
                                return state;<br />
                    }<br />
                };
              </p>
            </div>

            <!-- <p>localeSlice.js</p> -->
            <div
              class="bcg-box print-m-left-none"
              style="margin-right: auto"
            >
              <p>
                <i>// src/redux/localeSlice.js </i><br />
                export const changeLang = (newLang) => {<br />
                    return {<br />
                        type: "locale/changeLang",<br />
                        payload: newLang,<br />
                    };<br />
                };<br />
                export const localeReducer = (<br />
                        state = { lang: "uk" },<br />
                        action<br />
                    ) => {<br />
                        switch (action.type) {<br />
                            case "locale/changeLang":<br />
                                return {<br />
                                    ...state,<br />
                                    lang: action.payload,<br />
                                };<br />
                            <br />
                            default:<br />
                                return state;<br />
                    }<br />
                };
              </p>
            </div>

            <!-- <p>main.jsx</p>
          <div class="bcg-box">
            <p>
              <i>// src/main.jsx</i>

              import React from "react";<br />
              import ReactDOM from "react-dom/client";<br />
              import App from "./components/App";<br />
              import "modern-normalize";<br />
              import "./index.css";<br />
              import { Provider } from "react-redux";<br />
              import { store } from "./redux/store";<br />
              <br />
              ReactDOM.createRoot(document.getElementById("root")).render(<br />
                  &#60;React.StrictMode ><br />
                      &#60;Provider store="{store}" ><br />
                          &#60;App /><br />
                      &#60;/Provider ><br />
                  &#60;/React.StrictMode ><br />
              );
            </p>
          </div> -->
          </div>

          <div class="print-bcg-box print-m-left-none">
            <!-- <p>App.jsx</p> -->
            <div
              class="bcg-box print-bcg-box"
              style="margin-bottom: 8px"
            >
              <p>
                <i>// src/components/App/App.jsx</i><br />
                import LangSwitcher from
                "./LangSwitcher";<br />
                import Balance from "./Balance";<br />
                import { useSelector } from
                "react-redux";<br />
                <br />
                export default function App() {<br />
                    const lang = useSelector((state) =>
                state.locale.lang);<br />
                    return (<br />
                        &#60;div><br />
                            &#60;h1>Redux&#60;/h1><br />
                            &#60;Balance /><br />
                            &#60;LangSwitcher /><br />
                            &#60;p>Selected lang:
                {lang}&#60;/p><br />
                        &#60;/div><br />
                    );<br />
                }
              </p>
            </div>

            <!-- <p>Balance</p> -->
            <div
              class="bcg-box print-bcg-box"
              style="margin-bottom: 8px"
            >
              <p>
                <i>// src/components/Balance/Balance.jsx</i
                ><br />

                import { useDispatch, useSelector } from
                "react-redux";<br />
                import { deposit, withdraw } from
                "../redux/balanceSlice";<br />
                import { useState } from "react";<br />
                <br />
                export default function Balance() {<br />
                    const dispatch = useDispatch();<br />
                    const balance = useSelector((state) =>
                state.balance.value);<br />
                    const [value, setValue] =
                useState(0);<br />
                    return (<br />
                        &#60;div><br />
                            &#60;p>Balance:
                {balance}&#60;/p><br />
                            &#60;input<br />
                                type="number"<br />
                                value={value}<br />
                                onChange={(e) =>
                setValue(Number(e.target.value))}<br />
                            /><br />
                            &#60;button onClick={() =>
                dispatch(deposit(value))}><br />
                                Deposit credits<br />
                            &#60;/button><br />
                            &#60;button onClick={() =>
                dispatch(withdraw(value))}><br />
                                Withdraw credits<br />
                            &#60;/button><br />
                        &#60;/div><br />
                    );<br />
                }
              </p>
            </div>

            <!-- <p>LangSwitcher</p> -->
            <div class="bcg-box print-bcg-box">
              <p>
                <i
                  >//
                  src/components/LangSwitcher/LangSwitcher.jsx</i
                ><br />

                import { useDispatch, useSelector } from
                "react-redux";<br />
                import { changeLang } from
                "../redux/localeSlice";<br />
                <br />
                export default function LangSwitcher() {<br />
                    const dispatch = useDispatch();<br />
                    const lang = useSelector((state) =>
                state.locale.lang);<br />
                    return (<br />
                        &#60;div><br />
                            &#60;select<br />
                                value={lang}<br />
                                onChange={(e) =>
                dispatch(<br />
                                   
                changeLang(e.target.value)<br />
                                )}<br />
                            ><br />
                                &#60;option
                value="en">EN&#60;/option><br />
                                &#60;option
                value="uk">UK&#60;/option><br />
                                &#60;option
                value="pl">PL&#60;/option><br />
                            &#60;/select><br />
                        &#60;/div><br />
                    );<br />
                }
              </p>
            </div>
          </div>
        </div>
      </div>
    </section>

    <!-- Redux Toolkit -->
    <section class="print-m-bottom-max">
      <h2 class="m-bottom-min center-text">
        Redux Toolkit
      </h2>

      <!-- Загальне -->
      <div class="m-bottom">
        <p class="m-bottom-min">
          <b>Redux Toolkit</b> - бібліотека для ефективної
          розробки з використанням Redux, яка призначена для
          стандартизації та спрощення написання логіки
          Redux.
        </p>

        <div style="display: flex">
          <div>
            <p><b>Недоліки ванільного Redux</b></p>
            <ul class="list-style">
              <li>
                Надмірно складний процес налаштування стора.
              </li>
              <li>
                Необхідність встановлення стандартного
                набору додаткових бібліотек для розширення
                можливостей Redux.
              </li>
              <li>
                Великий обсяг шаблонного коду створення
                екшенів, редюсерів тощо.
              </li>
            </ul>
          </div>
          <div>
            <p><b>Переваги Redux Toolkit</b></p>
            <ul class="list-style">
              <li>
                Дозволяє зосередитися на написанні основної
                логіки програми, не витрачаючи час на
                налаштування.
              </li>
              <li>
                Містить утиліти для спрощення основних
                завдань. Таких як налаштування стора,
                створення екшенів та редюсерів, іммутабельне
                оновлення даних та багато чого іншого.
              </li>
              <li>
                Надає стандартний набір налаштувань для
                стора і включає в себе бібліотеки, що часто
                використовуються з екосистеми Redux.
              </li>
            </ul>
          </div>
        </div>
      </div>

      <!-- Встановлення -->
      <div class="m-bottom print-m-bottom-max">
        <h3 class="m-bottom-min">Встановлення</h3>
        <div class="print-flex-box">
          <div>
            <p>
              Використовуючи <b>Redux Toolkit</b>,
              <i>немає необхідності</i> додавати в проект
              пакет <b>redux</b>, крім випадків, коли вам
              необхідна функція <b>combineReducers()</b>.
            </p>
            <p>
              <b>@reduxjs/toolkit</b> - написання
              <i>логіки</i> Redux
            </p>
            <p>
              <b>react-redux</b> - зв'язок <i>стора</i> з
              <i>компонентами</i>.
            </p>
          </div>
          <div>
            <div class="m-bottom bcg-box print-bcg-box">
              <p>
                <b>npm install @reduxjs/toolkit </b>
              </p>
            </div>
            <div class="bcg-box print-bcg-box">
              <p>
                <b
                  >npm install @reduxjs/toolkit react-redux
                </b>
              </p>
            </div>
          </div>
        </div>
      </div>

      <!-- configureStore -->
      <div class="m-bottom print-m-bottom-max">
        <h3 class="m-bottom-min">configureStore</h3>
        <div class="m-bottom-min print-flex-box">
          <div>
            <p class="m-bottom-min">
              Функція <b>configureStore(options)</b> обертає
              оригінальний <b>createStore()</b>.
            </p>
            <p class="m-bottom-min">
              Очікує єдиним аргументом
              <i>об'єкт параметрів</i> та налаштовує деякі
              корисні інструменти розробки як частина
              процесу створення стора.
            </p>
            <p>
              На перший погляд, практично одне й теж, проте,
              відразу були налаштовані інструменти
              розробника (Redux DevTools) та деякі інші
              корисні функції, наприклад перевірка поширених
              помилок, таких як мутація стану в редюсерах чи
              використання невалідних значень у стані.
            </p>
          </div>
          <div class="bcg-box print-bcg-box print-fs-15">
            <p>
              <i>// src/redux/store.js</i><br />
              <i
                >//=============== Before
                ==================</i
              ><br />
              import { createStore } from "redux";<br />
              import { devToolsEnhancer } from
              "@redux-devtools/extension";<br />
              import { rootReducer } from "./reducer";<br />
              <br />
              const enhancer = devToolsEnhancer();<br />
              export const store = createStore(rootReducer,
              enhancer);<br />
              <br />
              <i
                >//=============== After
                ==================</i
              ><br />
              import { <b>configureStore</b> } from
              "@reduxjs/toolkit";<br />
              import { <b>rootReducer</b> } from
              "./reducer";<br />
              <br />
              const store = <b>configureStore</b>({<br />
                  reducer: <b>rootReducer</b>,<br />
              });
            </p>
          </div>
        </div>

        <div class="m-bottom-min print-flex-box">
          <div>
            <p>
              Функція <b>configureStore()</b> може
              автоматично створити кореневий редюсер. Для
              цього необхідно передати властивості reducer
              об'єкт тієї ж форми що в
              <b>combineReducers</b>.
            </p>
          </div>
          <div class="bcg-box print-bcg-box print-fs-15">
            <p>
              <i>// src/redux/store.js </i><br />
              import { <b>configureStore</b> } from
              "@reduxjs/toolkit";<br />
              import { <b>tasksReducer</b>,
              <b>filtersReducer</b> } from "./reducers";<br />
              <br />
              export const store =
              <b>configureStore</b>({<br />
                  reducer: {<br />
                      tasks: <b>tasksReducer</b>,<br />
                      filters: <b>filtersReducer</b>,<br />
                  },<br />
              });
            </p>
          </div>
        </div>

        <div class="bcg-box print-bcg-box print-fs-15">
          <p>
            <i>// src/redux/reducers.js</i><br />
            <i
              >//=============== Before
              ================================</i
            ><br />
            import { combineReducers } from "redux";<br />
            import { statusFilters } from "./constants";<br />
            <br />
            const tasksInitialState = [];<br />
            const filtersInitialState = {<br />
                status: statusFilters.all,<br />
            };<br />
            <br />
            const tasksReducer = (state = tasksInitialState,
            action) => { <i>// Reducer code</i> };<br />
            const filtersReducer = (state =
            filtersInitialState, action) => {
            <i>// Reducer code</i> };<br />
            <br />
            export const rootReducer = combineReducers({<br />
                tasks: tasksReducer,<br />
                filters: filtersReducer,<br />
            });<br />
            <br />
            <i
              >//=============== After
              ================================</i
            ><br />
            import { statusFilters } from "./constants";<br />
            <br />
            const tasksInitialState = [];<br />
            const filtersInitialState = {<br />
                status: statusFilters.all,<br />
            };<br />
            <br />
            export const <b>tasksReducer</b> = (state =
            tasksInitialState, action) => {
            <i>// Reducer code</i> };<br />
            <br />
            export const <b>filtersReducer</b> = (state =
            filtersInitialState, action) => {
            <i>// Reducer code</i> };
          </p>
        </div>
      </div>

      <!-- createAction -->
      <div class="print-m-bottom-max">
        <h3 class="m-bottom-min">createAction</h3>
        <div class="m-bottom-min print-flex-box">
          <div>
            <p>
              Функція <b>createAction(type)</b> спрощує
              процес оголошення екшенів. В якості аргументу
              вона приймає
              <i>рядок який описує тип дії</i> та повертає
              <i>генератор екшену</i>.
            </p>
          </div>
          <div class="bcg-box print-bcg-box print-fs-12">
            <p>
              <i>// src/redux/actions.js</i><br />
              <i>//=============== Before ==============</i
              ><br />
              const addTask = text => {<br />
                  return { type: "tasks/AddTask", payload:
              text };<br />
              };<br />
              <br />
              console.log(addTask("Learn Redux
              Toolkit"));<br />
              <i
                >// {type: "tasks/addTask", payload: "Learn
                Redux Toolkit"}</i
              ><br />
              <br />
              <i>//=============== After ===============</i
              ><br />
              import { <b>createAction</b> } from
              "@reduxjs/toolkit";<br />
              <br />
              export const addTask =
              <b>createAction</b
              >(<i>"tasks/AddTask"</i>);<br />
              export const deleteTask =
              <b>createAction</b
              >(<i>"tasks/deleteTask"</i>);<br />
              export const toggleCompleted =
              <b>createAction</b
              >(<i>"tasks/toggleCompleted"</i>);
              <br />
              <br />
              console.log(addTask("Learn Redux
              Toolkit"));<br />
              <i
                >// {type: "tasks/addTask", payload: "Learn
                Redux Toolkit"}</i
              >
            </p>
          </div>
        </div>

        <!-- Отримання типу екшену -->
        <div class="m-bottom-min">
          <h4 class="m-bottom-min">
            Отримання типу екшену
          </h4>
          <div class="m-bottom-min print-flex-box">
            <p>
              Для отримання типу екшену у генератора екшену
              є властивість
              <b>type</b> та метод <b>toString()</b> функції
            </p>
            <div class="bcg-box print-bcg-box print-fs-12">
              <p>
                import { createAction } from
                "@reduxjs/toolkit";<br />
                <br />
                const addTask =
                createAction("tasks/AddTask");<br />
                <br />
                console.log(addTask.<b>type</b>);
                <i>// "tasks/AddTask"</i><br />
                console.log(addTask.<b>toString()</b>);
                <i>// "tasks/AddTask"</i>
              </p>
            </div>
          </div>
          <div class="print-flex-box">
            <p>
              У редюсер імпортуються екшени та
              використовується їх властивість type для
              заміни рядків всередині інструкції
              <b>switch</b>.
            </p>
            <div class="bcg-box print-bcg-box print-fs-12">
              <p>
                <i>// src/redux/reducers.js</i><br />
                import { addTask, deleteTask,
                toggleCompleted } from "./actions";<br />
                <br />
                export const tasksReducer = (state =
                tasksInitialState, <b>action</b>) => {<br />
                    switch (<b>action.type</b>) {<br />
                        case <b>addTask.type</b>:<br />
                            return [...state,
                action.payload];<br />
                        case <b>deleteTask.type</b>:<br />
                            return state.filter(task =>
                task.id !== action.payload);<br />
                        case
                <b>toggleCompleted.type</b>:<br />
                            return state.map(task => {<br />
                                if (task.id !==
                action.payload) {<br />
                                    return task;<br />
                                }<br />
                                return { ...task, completed:
                !task.completed };<br />
                            });<br />
                        default:<br />
                            return state;<br />
                    }<br />
                };
              </p>
            </div>
          </div>
        </div>

        <!-- Вміст payload -->
        <div>
          <div>
            <h4 class="m-bottom-min">Вміст payload</h4>

            <div class="m-bottom print-flex-box">
              <div>
                <p class="m-bottom-min">
                  За замовчуванням <i>генератори</i> екшенів
                  приймають <i>один аргумент</i>, який стає
                  значенням властивості <b>payload</b>. Якщо
                  потрібно написати додаткову логіку
                  створення значення payload, наприклад,
                  додати унікальний ідентифікатор,
                  createAction можна передати
                  <i
                    >другий, необов'язковий аргумент –
                    функцію створення екшену</i
                  >.
                </p>
                <p>
                  Аргументи генератора екшену будуть
                  передані функції <b>prepareAction</b>, яка
                  повинна повернути
                  <i>об'єкт із властивістю</i>
                  <b>payload</b>. Властивість
                  <b>type</b> буде
                  <i>додано автоматично</i>.
                </p>
              </div>
              <div>
                <div
                  class="m-bottom-min bcg-box print-bcg-box print-fs-12"
                >
                  <p>
                    createAction(type, <b>prepareAction</b>)
                  </p>
                </div>
                <div
                  class="bcg-box print-bcg-box print-fs-12"
                >
                  <p>
                    <i>// src/redux/actions.js</i><br />
                    import { createAction, nanoid } from
                    "@reduxjs/toolkit";<br />
                    <br />
                    export const addTask =
                    createAction("tasks/addTask",
                    <b
                      >text => {<br />
                          return {<br />
                              payload: {<br />
                                  text,<br />
                                  id: nanoid(),<br />
                                  completed: false,<br />
                              },<br />
                          };<br />
                      }</b
                    >
                    );
                  </p>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- createReducer -->
      <div>
        <h3 class="m-bottom-min">createReducer</h3>
        <div class="m-bottom-min print-m-bottom-max">
          <div class="print-flex-box">
            <p>
              Будь-який редюсер отримує <i>стан Redux</i> і
              <i>екшен</i>, перевіряє
              <i>тип екшену</i> всередині інструкції
              <b>switch</b> і виконує відповідну логіку
              оновлення стану для даного екшену. До того ж,
              редюсер визначає початкове значення стану та
              повертає отриманий стан, якщо не повинен
              обробляти екшен. Функція
              <b>createReducer()</b> спрощує процес
              оголошення редюсерів.
            </p>
            <div>
              <div
                class="m-bottom-min bcg-box print-bcg-box print-fs-15"
              >
                <p>
                  createReducer(initialState,
                  builderCallback)
                </p>
              </div>
              <div
                class="m-bottom-min bcg-box print-bcg-box print-fs-15"
              >
                <p>
                  createReducer({}, builder => {<br />
                      builder.addCase(actionType, (state,
                  action) => {});<br />
                  });
                </p>
              </div>
              <div
                class="m-bottom-min bcg-box print-bcg-box print-fs-15"
              >
                <p>addCase(action, reducer)</p>
              </div>
            </div>
          </div>
          <div class="print-flex-box">
            <div>
              <ul class="m-bottom-min list-style">
                <li>
                  <b>initialState</b> - початковий стан
                  редюсера.
                </li>
                <li>
                  <b>builderCallback</b> - функція
                  зворотнього виклику, за допомогою якої
                  визначається редюсер для кожного екшена.
                </li>
              </ul>

              <p>
                Функція зворотнього виклику
                <b>builderCallback</b> <i>оголошує</i> один
                параметр <b>builder</b> -
                <i>об'єкт із методами</i>, за допомогою яких
                (<b>addCase</b>) ми реєструємо редюсери для
                екшенів. Тобто кожен <b>case</b> з
                <b>switch</b> стає викликом <b>addCase</b>,
                для якого написаний власний міні-редюсер.
              </p>
            </div>
            <div class="bcg-box print-bcg-box print-fs-15">
              <p>
                <i>// src/redux/reducers.js</i><br />
                import { createReducer } from
                "@reduxjs/toolkit";<br />
                import { statusFilters } from
                "./constants";<br />
                import { addTask, deleteTask,
                toggleCompleted } from "./actions";<br />
                <br />
                const tasksInitialState = [];<br />
                <i
                  >//=============== Before
                  ========================</i
                ><br />
                const tasksReducer = (state =
                tasksInitialState, action) => {<br />
                    switch (action.type) {<br />
                        case addTask.type:<br />
                        // case logic<br />
                        case deleteTask.type:<br />
                        // case logic<br />
                        case toggleCompleted.type:<br />
                        // case logic<br />
                        default:<br />
                            return state;<br />
                    }<br />
                };<br />
                <br />
                <i
                  >//=============== After
                  ========================</i
                ><br />
                export const tasksReducer =
                <b
                  >createReducer(tasksInitialState, builder
                  => {</b
                ><br />
                    <b>builder</b><br />
                        .<b>addCase</b>(addTask, (state,
                action) => {<br />
                            return [...state,
                action.payload];<br />
                        })<br />
                        .<b>addCase</b>(deleteTask, (state,
                action) => {<br />
                            return state.filter(task =>
                task.id !== action.payload);<br />
                        })<br />
                        .<b>addCase</b>(toggleCompleted,
                (state, action) => {<br />
                            return state.map(task => {<br />
                                if (task.id !==
                action.payload) {<br />
                                    return task;<br />
                                }<br />
                                return {<br />
                                    ...task,<br />
                                    completed:
                !task.completed,<br />
                                };<br />
                            });<br />
                      });<br />
                });<br />
                <br />
                export const filtersReducer =
                createReducer(filtersInitialState, builder
                => {<br />
                    builder.addCase(setStatusFilter, (state,
                action) => {<br />
                        return {<br />
                            ...state,<br />
                            status: action.payload,<br />
                        };<br />
                    });<br />
                });
              </p>
            </div>
          </div>
        </div>

        <!-- Бібліотека Immer -->
        <div class="m-bottom">
          <h4 class="m-bottom-min">Бібліотека Immer</h4>
          <div class="print-flex-box">
            <p>
              Redux Toolkit «під капотом» використовує
              бібліотеку Immer, яка значно спрощує логіку
              роботи зі станом, дозволяючи писати код
              оновлення стану в редюсері так, ніби ми
              безпосередньо змінювали стан. Насправді
              редюсери отримують копію стану, а Immer
              перетворює всі мутації на еквівалентні
              операції оновлення.
            </p>
            <div class="bcg-box print-bcg-box">
              <p>
                <i>// src/redux/reducers.js</i><br />
                <br />
                export const tasksReducer =
                createReducer(tasksInitialState, builder =>
                {<br />
                    builder<br />
                        .addCase(addTask, (state, action) =>
                {<br />
                           
                <i
                  >// ✅ Immer замінить це на операцію
                  оновлення</i
                ><br />
                            state.push(action.payload);<br />
                        })<br />
                        .addCase(deleteTask, (state, action)
                => {<br />
                           
                <i
                  >// ✅ Immer замінить це на операцію
                  оновлення</i
                ><br />
                            const index =
                state.findIndex(task => task.id ===
                action.payload);<br />
                            state.splice(index, 1);<br />
                        })<br />
                        .addCase(toggleCompleted, (state,
                action) => {<br />
                           
                <i
                  >// ✅ Immer замінить це на операцію
                  оновлення</i
                ><br />
                            for (const task of state) {<br />
                                if (task.id ===
                action.payload) {<br />
                                    task.completed =
                !task.completed;<br />
                                }<br />
                            }<br />
                        });<br />
                });<br />
                <br />
                export const filtersReducer =
                createReducer(filtersInitialState, builder
                => {<br />
                    builder.addCase(setStatusFilter, (state,
                action) => {<br />
                       
                <i
                  >// ✅ Immer замінить це на операцію
                  оновлення</i
                ><br />
                        state.status = action.payload;<br />
                    });<br />
                });
              </p>
            </div>
          </div>
        </div>

        <!-- Зміна або оновлення -->
        <div class="m-bottom">
          <h4 class="m-bottom-min">Зміна або оновлення</h4>
          <div class="print-flex-box">
            <p>
              Іноді код іммутабельного оновлення стану
              лаконічніший, ніж його альтернатива, що
              «змінює». Наприклад, у редюсері обробки екшену
              видалення завдання. У такому разі необхідно
              обов'язково повернути новий стан.
            </p>
            <div class="bcg-box print-bcg-box">
              <p>
                <i>// src/redux/reducers.js</i><br />
                <br />
                export const tasksReducer =
                createReducer(tasksInitialState, builder =>
                {<br />
                   builder.addCase(deleteTask, (state,
                action) => {<br />
                      <i>// ❌ Не правильно</i><br />
                      // state.filter(task => task.id !==
                action.payload)<br />
                      <i>// ✅ Правильно</i><br />
                      return state.filter(task => task.id
                !== action.payload);<br />
                   });<br />
                });
              </p>
            </div>
          </div>
        </div>

        <!-- Зміна чи повернення -->
        <div>
          <h4 class="m-bottom-min">Зміна чи повернення</h4>
          <div class="print-flex-box">
            <p>
              Один із підводних каменів бібліотеки Immer
              полягає в тому, що в коді одного редюсера
              можна лише або мутувати стан, або повернути
              оновлений, але не те й інше водночас.
            </p>
            <div class="bcg-box print-bcg-box">
              <p>
                <i>// src/redux/reducers.js</i><br />
                <br />
                const reducer = createReducer([], builder =>
                {<br />
                    builder.addCase(doSomething, (state,
                action) => {<br />
                       
                <i
                  >// ❌ Так робити не можна, буде
                  згенеровано виняток</i
                ><br />
                        state.push(action.payload);<br />
                        return state.map(value => value *
                2);<br />
                    });<br />
                });
              </p>
            </div>
          </div>
        </div>
      </div>

      <!-- createSlice -->
      <div>
        <h3 class="m-bottom-min">createSlice</h3>
        <div class="m-bottom print-m-bottom-max">
          <div class="m-bottom-min print-flex-box">
            <div>
              <p class="m-bottom-min">
                При проектуванні структура стану Redux
                ділиться на <b>слайси (slice, частина)</b>,
                за кожен із яких відповідає окремий редюсер
              </p>
              <p>
                Для кожного слайсу створюється стандартний
                набір сутностей: типи екшенів, генератори
                екшенів та редюсер. Редюсери визначають
                початковий стан слайсу, список екшенів, що
                впливають на нього та операції оновлення
                стану.
              </p>
            </div>
            <div class="bcg-box print-bcg-box">
              <p>
                const appState = {<br />
                    <b>tasks</b>: [],<br />
                    <b>filters</b>: {},<br />
                };
              </p>
            </div>
          </div>

          <div class="m-bottom-min print-flex-box">
            <div>
              <p class="m-bottom-min">
                Функція <b>createSlice()</b> це надбудова
                над <b>createAction()</b> та
                <b>createReducer()</b>, яка стандартизує та
                ще більше спрощує оголошення слайсу. Вона
                <i>приймає параметри налаштувань</i>,
                створює і
                <i
                  >повертає типи екшенів, генератори екшенів
                  та редюсер</i
                >.
              </p>
              <p>
                Властивість <b>name</b> визначає ім'я
                слайсу, яке додаватиметься під час створення
                екшенів, як приставка до імен редюсерів,
                оголошених у властивості <b>reducers</b>.
                Так ми отримаємо екшени з типами
                <b>tasks/addTask</b>,
                <b>tasks/deleteTask</b> та
                <b>tasks/toggleCompleted</b>.
              </p>
            </div>
            <div class="bcg-box print-bcg-box">
              <p>
                import { createSlice } from
                "@reduxjs/toolkit";<br />
                <br />
                const <b>tasksSlice</b> =
                <b>createSlice</b>({<br />
                    <i>// Ім'я слайсу</i><br />
                    <b>name</b>: "tasks",<br />
                    <i>// Початковий стан редюсера слайсу</i
                ><br />
                    initialState: [],<br />
                    <i>// Об'єкт редюсерів</i><br />
                    <b>reducers</b>: {<br />
                        <b>addTask</b>(state, action) {},<br />
                        <b>deleteTask</b>(state, action)
                {},<br />
                        <b>toggleCompleted</b>(state,
                action) {},<br />
                    },<br />
                });<br />
                <br />
                <i>// Генератори екшенів</i><br />
                const {
                <b>addTask, deleteTask, toggleCompleted</b>
                } = tasksSlice.actions;<br />
                <br />
                <i>// Редюсер слайсу</i><br />
                const tasksReducer =
                <b>tasksSlice</b>.<b>reducer</b>;<br />
              </p>
            </div>
          </div>

          <div class="m-bottom-min print-flex-box">
            <p>
              Функція <b>createSlice()</b> у своїй
              реалізації використовує <b>createReducer</b> і
              бібліотеку <b>Immer</b>, тому можна писати
              логіку оновлення стану так, як якби ми
              безпосередньо змінювали його.
            </p>
            <div class="bcg-box print-bcg-box">
              <p>
                import { createSlice } from
                "@reduxjs/toolkit";<br />
                <br />
                const tasksSlice = createSlice({<br />
                    name: "tasks",<br />
                    initialState: [],<br />
                    reducers: {<br />
                        addTask(state, action) {<br />
                            state.push(action.payload);<br />
                        },<br />
                        deleteTask(state, action) {<br />
                            const index =
                state.findIndex(task => task.id ===
                action.payload);<br />
                            state.splice(index, 1);<br />
                        },<br />
                        toggleCompleted(state, action) {<br />
                            for (const task of state) {<br />
                                if (task.id ===
                action.payload) {<br />
                                    task.completed =
                !task.completed;<br />
                                    break;<br />
                                }<br />
                            }<br />
                        },<br />
                    },<br />
                });<br />
                <br />
                const { addTask, deleteTask, toggleCompleted
                } = tasksSlice.actions;<br />
                const tasksReducer = tasksSlice.reducer;
              </p>
            </div>
          </div>
        </div>

        <!-- Вміст payload -->
        <div class="m-bottom print-m-bottom-max">
          <h4 class="m-bottom-min">Вміст payload</h4>
          <div class="m-bottom-min print-flex-box">
            <p>
              <i>Генератор екшену</i> <b>addTask</b> очікує
              лише рядок з текстом завдання, після чого
              змінює значення <b>payload</b> використовуючи
              функцію підготовки екшену. Ось як це виглядає
              зараз у нашому коді.
            </p>
            <div class="bcg-box print-bcg-box">
              <p>
                <i>// src/redux/actions.js</i><br />
                <br />
                import { createAction, nanoid } from
                "@reduxjs/toolkit";<br />
                <br />
                export const <b>addTask</b> =
                createAction(<i>"tasks/addTask"</i>, text =>
                {<br />
                    return {<br />
                        payload: {<br />
                            text,<br />
                            id: nanoid(),<br />
                            completed: false,<br />
                        },<br />
                    };<br />
                });
              </p>
            </div>
          </div>
          <div class="m-bottom-min print-flex-box">
            <p>
              Щоб зробити те саме при створенні слайсу,
              властивості в об'єкті редюсерів, в нашому
              випадку <b>addTask</b>, необхідно передати не
              функцію, а об'єкт із двома властивостями -
              <b>reducer</b> та <b>prepare</b>.
            </p>
            <div class="bcg-box print-bcg-box">
              <p>
                import { createSlice, nanoid } from
                "@reduxjs/toolkit";<br />
                <br />
                const tasksSlice = createSlice({<br />
                    name: "tasks",<br />
                    initialState: tasksInitialState,<br />
                    reducers: {<br />
                        <b>addTask</b>: {<br />
                            <b>reducer</b>(state, action)
                {<br />
                               
                state.push(action.payload);<br />
                            },<br />
                            <b>prepare</b>(text) {<br />
                                return {<br />
                                    payload: {<br />
                                        text,<br />
                                        id: nanoid(),<br />
                                        completed: false,<br />
                                    },<br />
                                };<br />
                            },<br />
                        },<br />
                        // Код решти редюсерів<br />
                    },<br />
                });
              </p>
            </div>
          </div>
        </div>

        <!-- Файли слайсів -->
        <div class="m-bottom print-m-bottom-max">
          <h4 class="m-bottom-min">Файли слайсів</h4>
          <div class="m-bottom-min print-flex-box">
            <p>
              Нам більше не потрібний файл
              <i>reducer.js</i>, тому що під кожен слайс ми
              створимо окремий файл. Для слайсу завдань це
              буде файл <b>tasksSlice.js</b>.
            </p>
            <div class="bcg-box print-bcg-box print-fs-14">
              <p>
                <i>// src/redux/tasksSlice.js</i><br />
                <br />
                import { createSlice } from
                "@reduxjs/toolkit";<br />
                <br />
                const tasksSlice = createSlice({<br />
                    name: "tasks",<br />
                    initialState: [],<br />
                    reducers: {<br />
                        addTask: {<br />
                            reducer(state, action) {<br />
                               
                state.push(action.payload);<br />
                            },<br />
                            prepare(text) {<br />
                                return {<br />
                                    payload: {<br />
                                        text,<br />
                                        id: nanoid(),<br />
                                        completed: false,<br />
                                    },<br />
                                };<br />
                            },<br />
                        },<br />
                        deleteTask(state, action) {<br />
                            const index =
                state.findIndex(task => task.id ===
                action.payload);<br />
                            state.splice(index, 1);<br />
                        },<br />
                        toggleCompleted(state, action) {<br />
                              for (const task of state) {<br />
                                  if (task.id ===
                action.payload) {<br />
                                      task.completed =
                !task.completed;<br />
                                      break;<br />
                                  }<br />
                              }<br />
                        },<br />
                        <br />
                });<br />
                <i
                  >// Експортуємо генератори екшенів та
                  редюсер</i
                ><br />
                export const { addTask, deleteTask,
                toggleCompleted } = tasksSlice.actions;<br />
                export const tasksReducer =
                tasksSlice.reducer;
              </p>
            </div>
          </div>
          <div class="bcg-box print-bcg-box print-fs-14">
            <p>
              <i>// src/redux/filtersSlice.js</i><br />
              <br />
              import { createSlice } from
              "@reduxjs/toolkit";<br />
              import { statusFilters } from
              "./constants";<br />
              <br />
              const filtersSlice = createSlice({<br />
                  name: "filters",<br />
                  initialState: {<br />
                  status: statusFilters.all,<br />
              },<br />
                  reducers: {<br />
                      setStatusFilter(state, action) {<br />
                          state.status = action.payload;<br />
                      },<br />
                  },<br />
              });<br />
              <br />
              <i
                >// Експортуємо генератори екшенів та
                редюсер</i
              ><br />
              export const { setStatusFilter } =
              filtersSlice.actions;<br />
              export const filtersReducer =
              filtersSlice.reducer;<br />
            </p>
          </div>
        </div>

        <!-- Створення стора -->
        <div>
          <h4 class="m-bottom-min">Створення стора</h4>
          <div class="m-bottom print-flex-box">
            <p>
              У файлі створення стора необхідно змінити код
              імпорту редюсерів.
            </p>
            <div class="bcg-box print-bcg-box">
              <p>
                <i>// src/redux/store.js</i><br />
                <br />
                import { configureStore } from
                "@reduxjs/toolkit";<br />
                <i
                  >//=============== Before
                  ========================</i
                ><br />
                // import { tasksReducer, filtersReducer }
                from "./reducer";<br />
                <br />
                <i
                  >//=============== After
                  ========================</i
                ><br />
                import { tasksReducer } from
                "./tasksSlice";<br />
                import { filtersReducer } from
                "./filtersSlice";<br />
                <br />
                export const store = configureStore({<br />
                    reducer: {<br />
                        tasks: tasksReducer,<br />
                        filters: filtersReducer,<br />
                    },<br />
                });
              </p>
            </div>
          </div>
        </div>

        <!-- Генератори екшенів -->
        <div>
          <h4 class="m-bottom-min">Генератори екшенів</h4>
          <div class="m-bottom-min print-flex-box">
            <p>
              Генератори екшенів тепер створюються
              автоматично для кожного слайсу. Це означає, що
              нам більше не потрібно вручну оголошувати їх в
              окремому файлі <b>createAction()</b>. Ми
              можемо видалити файл <i>actions.js</i> та
              оновити імпорти генераторів екшенів у файлах
              компонентів. Структура файлів проекту тепер
              буде виглядати так.
            </p>
            <div class="bcg-box print-bcg-box print-fs-14">
              <p>
                src/<br />
                    - components/<br />
                <b>
                      - redux/<br />
                          - constants.js<br />
                          - selectors.js<br />
                          - tasksSlice.js <br />
                          - filtersSlice.js <br />
                          - store.js<br />
                </b>
                    - index.js
              </p>
            </div>
          </div>
          <div class="print-flex-box">
            <p>
              Імпорти генераторів екшенів імпортуються з
              відповідного файлу слайсу.
            </p>
            <div class="bcg-box print-bcg-box print-fs-14">
              <p>
                <i
                  >//=============== Before
                  ========================</i
                ><br />
                // import { deleteTask, toggleCompleted }
                from "redux/actions";<br />
                <br />
                <i
                  >//=============== After
                  ========================</i
                ><br />
                import { deleteTask, toggleCompleted } from
                "redux/tasksSlice";
              </p>
            </div>
          </div>
        </div>
      </div>
    </section>

    <!-- localstorage -->
    <section>
      <div>
        <h2 class="m-bottom-min">
          Збереження і читання localstorage
        </h2>
        <div class="m-bottom print-flex-box">
          <div>
            <p class="m-bottom-min">
              Для запису даних <b>localstorage</b> та
              читання із нього викорустовується бібліотека
              <b>Redux Persist</b>.
            </p>
          </div>
          <div class="bcg-box print-bcg-box">
            <p>npm install redux-persist</p>
          </div>
        </div>

        <div class="m-bottom print-flex-box">
          <div>
            <p class="m-bottom-min">
              Файл <b>store.js</b> імпортуються
              <b>persistStore</b> та
              <b>persistReducer</b> та посилання на
              localstorage - <b>storage</b>
            </p>
          </div>
          <div class="bcg-box print-bcg-box">
            <p>
              <i>//store.js</i><br />
              <br />
              import {<br />
                  <b>persistStore</b>,<br />
                  <b>persistReducer</b>,<br />
              } from "redux-persist";<br />
              <br />
              import <b>storage</b> from
              "redux-persist/lib/storage";
            </p>
          </div>
        </div>

        <div class="m-bottom print-flex-box">
          <div>
            <p class="m-bottom-min">
              Необхідно налаштувати <b>store</b>, за
              допомогою <b>persistReducer</b>, передавши
              йому першим аргументом об'єкт конфігурації, а
              другим - безпосередньо редьюсер.
            </p>
          </div>
          <div class="bcg-box print-bcg-box">
            <p>
              import balanceReducer from
              "./balanceSlice";<br />
              <br />
              const pBalanceReducer =
              <b>persistReducer</b>(<br />
                  balancePersistConfig,<br />
                  <b>balanceReducer</b><br />
              );<br />
            </p>
          </div>
        </div>

        <div class="m-bottom print-flex-box">
          <div>
            <p class="m-bottom-min">
              Об'єкт конфігурації
              (<b>balancePersistConfig</b>) має дві основні
              властивості <b>key</b> (ім'я ключа у
              localstorage) та <b>storage</b>. Властивість
              <b>whitelist</b> приймає масив властивостей із
              <i>слайсу</i>, які необхідно зберегти у
              <i>localstorage</i>.
              <i
                >Без <b>whitelist</b> - збережеться повністю
                весь слайс</i
              >.
            </p>
          </div>
          <div class="bcg-box print-bcg-box">
            <p>
              const <b>balancePersistConfig</b> = {<br />
                  <b>key</b>: <i>"balanceValue"</i>,<br />
                  <b>storage</b>,<br />
                  <b>whitelist</b>: <i>["value"]</i>,<br />
              };
            </p>
          </div>
        </div>

        <div class="m-bottom print-flex-box">
          <div>
            <p class="m-bottom-min">
              У слайс, замість старого редьюсера, необхідно
              повернути новий
            </p>
          </div>
          <div class="bcg-box print-bcg-box">
            <p>
              export const store = configureStore({<br />
                  reducer: {<br />
                      balance: <b>pBalanceReducer</b>,<br />
                  },<br />
              });
            </p>
          </div>
        </div>

        <div class="m-bottom print-flex-box">
          <div>
            <p class="m-bottom-min">
              В кінці необхідно виконати стандартні
              налаштування бібліотеки та створити зміну
              <b>persistor</b> із функції
              <b>persistStore</b> (імпортується), передавши
              у неї наш <b>store</b>
            </p>
          </div>
          <div class="bcg-box print-bcg-box">
            <p>
              export const <b>persistor</b> =
              <b>persistStore</b>(store);
            </p>
          </div>
        </div>

        <div class="m-bottom print-flex-box">
          <div>
            <p class="m-bottom-min">
              Необхідно огорнути додаток за допомогою
              <b>PersistGate</b> із обов'зковим пропсом
              <b>persistor</b>. Додатково можна передати
              пропс <b>loading</b> (loading = {}).
            </p>
          </div>
          <div class="bcg-box print-bcg-box">
            <p>
              <i>//main.jsx</i><br />
              import { PersistGate } from
              "redux-persist/integration/react";<br />
              import App from "./components/App/App";<br />
              import { store, persistor } from
              "./redux/store";<br />
              <br />
              ReactDOM.createRoot(document.getElementById("root")).render(<br />
                  &#60;React.StrictMode><br />
                      &#60;Provider store={store}><br />
                          &#60;PersistGate
              persistor={persistor}><br />
                              &#60;App /><br />
                          &#60;/PersistGate><br />
                      &#60;/Provider><br />
                  &#60;/React.StrictMode><br />
              );
            </p>
          </div>
        </div>

        <!-- фінал -->
        <div class="m-bottom print-flex-box">
          <div>
            <p class="m-bottom-min">
              Фінальний вигляд файл <b>store.js</b> має
            </p>
            <p class="border-box m-bottom-min">
              В action не можна передавати функції, але
              бібліотека redax-persist їх передає. Для
              виключення помилок із redux необхідно неохідно
              імпортувати усі action`и та додати властивість
              <b>middleware</b> із налаштуваннями у
              <b>store</b>
            </p>
            <div
              class="bcg-box print-bcg-box print-m-left-none"
            >
              <p>
                <b
                  >import {<br />
                      persistStore,<br />
                      persistReducer,<br />
                      FLUSH,<br />
                      REHYDRATE,<br />
                      PAUSE,<br />
                      PERSIST,<br />
                      PURGE,<br />
                      REGISTER,<br />
                  } from "redux-persist";<br
                /></b>
                <br />
                export const <b>store</b> =
                configureStore({<br />
                    reducer: {<br />
                        balance: pBalanceReducer,<br />
                    },<br />
                   
                <b
                  >middleware: (getDefaultMiddleware) =><br />
                          getDefaultMiddleware({<br />
                              serializableCheck: {<br />
                                  ignoredActions: [<br />
                                      FLUSH,<br />
                                      REHYDRATE,<br />
                                      PAUSE,<br />
                                      PERSIST,<br />
                                      PURGE,<br />
                                      REGISTER<br />
                                  ],<br />
                          },<br />
                      })</b
                >,<br />
                });<br />
                <br />
                export const persistor =
                persistStore(store);
              </p>
            </div>
          </div>
          <div class="bcg-box print-bcg-box print-fs-15">
            <p>
              <i>//store.js</i><br />
              <br />
              import { configureStore } from
              "@reduxjs/toolkit";<br />
              import {<br />
                  persistStore,<br />
                  persistReducer,<br />
                  FLUSH,<br />
                  REHYDRATE,<br />
                  PAUSE,<br />
                  PERSIST,<br />
                  PURGE,<br />
                  REGISTER,<br />
              } from "redux-persist";<br />
              import storage from
              "redux-persist/lib/storage";<br />
              import balanceReducer from
              "./balanceSlice";<br />
              <br />
              const balancePersistConfig = {<br />
                  key: "balanceValue",<br />
                  storage,<br />
                  whitelist: ["value"],<br />
              };<br />
              <br />
              const pBalanceReducer = persistReducer(<br />
                  balancePersistConfig,<br />
                  balanceReducer<br />
              );<br />
              <br />
              export const store = configureStore({<br />
                  reducer: {<br />
                      balance: pBalanceReducer,<br />
                  },<br />
                  middleware: (getDefaultMiddleware) =><br />
                      getDefaultMiddleware({<br />
                          serializableCheck: {<br />
                              ignoredActions: [<br />
                                  FLUSH,<br />
                                  REHYDRATE,<br />
                                  PAUSE,<br />
                                  PERSIST,<br />
                                  PURGE,<br />
                                  REGISTER<br />
                              ],<br />
                      },<br />
                  }),<br />
              });<br />
              <br />
              export const persistor = persistStore(store);
            </p>
          </div>
        </div>
      </div>
    </section>
  </body>
</html>
