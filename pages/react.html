<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0"
    />
    <title>React</title>
    <link
      href="https://fonts.googleapis.com/css2?family=Tinos:ital,wght@0,400;0,700;1,400;1,700&display=swap"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="../../css/styles.css" />
  </head>
  <body>
    <header class="header">
      <nav class="nav">
        <a class="nav-link button" href="../../index.html"
          >На головну</a
        >
        <a class="nav-link button" href="#main"
          >До початку секції</a
        >
      </nav>
    </header>

    <main>
      <!-- title -->
      <section class="title-section main-section">
        <div class="container">
          <h1 class="center-text">React</h1>
        </div>
      </section>

      <section class="main-section">
        <div class="container">
          <h2 class="m-bottom-min center-text">
            Додаткові бібліотеки
          </h2>

          <table>
            <thead>
              <tr>
                <th>Опис</th>
                <th>Термінал</th>
                <th>Імпорт</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>Типізація пропсів</td>
                <td>npm install --save-dev prop-types</td>
                <td>import PropTypes from 'prop-types';</td>
              </tr>
              <tr>
                <td>Композиціонування класів</td>
                <td>npm install clsx</td>
                <td>import clsx from "clsx";</td>
              </tr>
              <tr>
                <td>
                  Нормалізація стилів (імпортується в
                  <b>main.jsx</b>)
                </td>
                <td>npm install modern-normalize</td>
                <td>import "modern-normalize";</td>
              </tr>
              <tr>
                <td>Набір іконок</td>
                <td>npm install react-icons</td>
                <td>
                  import { HiUser } from "react-icons/hi";
                </td>
              </tr>
              <tr>
                <td>Робота та налагодження форм</td>
                <td>npm install formik</td>
                <td>
                  import { Formik, Form, Field, ErrorMessage
                  } from "formik";
                </td>
              </tr>
              <tr>
                <td>Валідація Formik</td>
                <td>npm install yup</td>
                <td>import * as Yup from "yup";</td>
              </tr>
              <tr>
                <td>HTTP-запити</td>
                <td>npm install axios</td>
                <td>import axios from "axios";</td>
              </tr>
              <tr>
                <td>Маршрутизація в React</td>
                <td>npm install react-router-dom</td>
                <td>
                  import { BrowserRouter } from
                  "react-router-dom";<br />
                  import { Routes, Route, NavLink } from
                  "react-router-dom";<br />
                  import { useParams } from
                  "react-router-dom";<br />
                  import { useNavigate } from
                  "react-router-dom";<br />
                  import { useSearchParams } from
                  "react-router-dom";<br />
                  import { useLocation } from
                  "react-router-dom";
                </td>
              </tr>
              <tr>
                <td>React Redux</td>
                <td>npm install react-redux</td>
                <td></td>
              </tr>
              <tr>
                <td>Redux Toolkit</td>
                <td>npm install @reduxjs/toolkit</td>
                <td></td>
              </tr>
              <tr>
                <td></td>
                <td></td>
                <td></td>
              </tr>
              <tr>
                <td></td>
                <td></td>
                <td></td>
              </tr>
              <tr>
                <td></td>
                <td></td>
                <td></td>
              </tr>
            </tbody>
          </table>
        </div>
      </section>

      <!-- Зміст -->
      <section id="main" class="main-section">
        <div class="container">
          <h2 class="m-bottom-min">Зміст</h2>

          <ul>
            <li>
              <a href="#common">Створення проекту </a>
            </li>
            <li>
              <a href="#components">Компоненти </a>
            </li>
            <li>
              <a href="#styles">Стилі </a>
            </li>
            <li>
              <a href="#events">Обробка подій </a>
            </li>
            <li>
              <a href="#life-cycle"
                >Життєвий цикл компонента
              </a>
            </li>
            <li>
              <a href="#forms">Форми </a>
            </li>
            <li>
              <a href="#http-request">HTTP-запити </a>
            </li>
            <li>
              <a href="#redux">Redux </a>
            </li>
            <li>
              <a href="#http-redux"
                >Асинхронність в Redux
              </a>
            </li>
            <li>
              <a href="#register-login"
                >Реєстрація та логін користувача
              </a>
            </li>
            <li>
              <a href="#hooks">React's hooks</a>
            </li>
          </ul>
        </div>
      </section>

      <!-- Загальні налаштування -->
      <section id="common" class="main-section">
        <div class="container">
          <h2 class="m-bottom center-text">
            Створення проекту
          </h2>

          <section class="section">
            <h3 class="m-bottom-min">
              Загальні налаштування
            </h3>

            <ol class="m-bottom-min">
              <li class="m-bottom-min">
                <p>
                  Створити порожній репозиторій (проєкт) на
                  GitHub.
                </p>
              </li>
              <li class="m-bottom-min">
                <p>
                  Клонувати цей репозиторій на свій
                  комп'ютер.
                </p>
              </li>
              <li class="m-bottom-min">
                <div class="flex">
                  <p>
                    В терміналі запустити створення
                    React-проєкту.
                  </p>
                  <div class="bcg-box">
                    <b>npm create vite@latest </b>
                  </div>
                </div>
              </li>
              <li class="m-bottom-min">
                <p>
                  <b>Prettier</b> - додати файл налаштувань
                  у корінь проєкту.
                </p>
              </li>
              <li class="m-bottom-min">
                <div class="flex">
                  <p>
                    Налаштуваня файлу
                    <b>espnt.config.js</b>
                  </p>
                  <div class="bcg-box fs-11">
                    import js from "@eslint/js";<br />
                    import globals from "globals";<br />
                    import react from
                    "eslint-plugin-react";<br />
                    import reactHooks from
                    "eslint-plugin-react-hooks";<br />
                    import reactRefresh from
                    "eslint-plugin-react-refresh";<br />
                    <br />
                    export default [<br />
                        {<br />
                            files: ["**/*.{js,jsx}"],<br />
                            ignores: ["dist"],<br />
                            languageOptions: {<br />
                                ecmaVersion: 2020,<br />
                                globals: globals.browser,<br />
                                parserOptions: {<br />
                                    ecmaVersion:
                    "latest",<br />
                                    ecmaFeatures: { jsx:
                    true },<br />
                                    sourceType: "module",<br />
                                },<br />
                            },<br />
                            settings: { react: { version:
                    "18.3" } },<br />
                            plugins: {<br />
                                react,<br />
                                "react-hooks":
                    reactHooks,<br />
                                "react-refresh":
                    reactRefresh,<br />
                            },<br />
                            rules: {<br />
                               
                    ...js.configs.recommended.rules,<br />
                               
                    ...react.configs.recommended.rules,<br />
                               
                    ...react.configs["jsx-runtime"].rules,<br />
                               
                    ...reactHooks.configs.recommended.rules,<br />
                               
                    <span class="fs-14"
                      ><b>"react/prop-types": 0,</b></span
                    ><br />
                                "react/jsx-no-target-blank":
                    "off",<br />
                               
                    "react-refresh/only-export-components":
                    [<br />
                                    "warn",<br />
                                    { allowConstantExport:
                    true },<br />
                                ],<br />
                            },<br />
                        },<br />
                    ];
                  </div>
                </div>
              </li>
              <li class="m-bottom-min">
                <div class="flex">
                  <p>
                    Змінити налаштування файлу
                    <b>vite.config.js</b> на
                  </p>
                  <div class="bcg-box fs-11">
                    import { defineConfig } from "vite";<br />
                    import react from
                    "@vitejs/plugin-react-swc";<br />
                    <br />
                    // https://vitejs.dev/config/<br />
                    export default defineConfig({<br />
                        plugins: [react()],<br />
                    <span class="fs-14"
                      ><b>
                            build: {<br />
                               sourcemap: true,<br />
                            }<br /></b
                    ></span>
                    });
                  </div>
                </div>
              </li>
              <li class="m-bottom-min">
                <p>
                  Створити папку <b>components</b> у папці
                  <b>src</b>. Перенести туди файліи
                  <b>App.jsx</b> та <b>App.css</b>,
                  створивши для них власну папку.
                  Скорегувати шлях (import) до файлу
                  <b>App.jsx</b> у файлі
                  <b>main.jsx</b>
                </p>
              </li>
              <li class="m-bottom-min">
                <p>
                  Внести скидання стилів та їх загальні
                  налаштування у файлі <b>index.css</b>
                </p>
              </li>
              <li>
                <div class="flex">
                  <p>
                    Для правильної роботи додатка з
                    маршрутизацією після розгортання на
                    Vercel, додати файл налаштувань
                    <b>vercel.json</b> в
                    <i>кореневу папку</i>
                    проекту.
                  </p>
                  <div class="bcg-box fs-14">
                    <b
                      >{<br />
                          "rewrites":  [<br />
                              {"source": "/(.*)",
                      "destination": "/"}<br />
                          ]<br />
                      }</b
                    >
                  </div>
                </div>
              </li>
            </ol>

            <!-- Нормалізація стилів -->
            <section class="sub-section new-page">
              <h4 class="m-bottom-min">
                Нормалізація стилів
              </h4>

              <div class="m-bottom-min flex">
                <p>
                  Необхідно встановити через термінал
                  залежності в проекті для нормалізатора
                </p>

                <div>
                  <p class="bcg-box">
                    <b>npm install modern-normalize</b>
                  </p>
                </div>
              </div>

              <div class="m-bottom flex">
                <p class="m-bottom-min">
                  Після цього в файлі
                  <b>main.jsx</b> ми
                  <i>імпортуємо</i>
                  стилі нормалізації. Це додасть стилі з
                  файлу нормалізації до проекту.
                </p>

                <div class="bcg-box">
                  <p>
                    import React from "react"; <br />
                    import ReactDOM from
                    "react-dom/client";<br />
                    <b>import "modern-normalize"</b>;<br />
                  </p>
                </div>
              </div>

              <div class="m-bottom flex">
                <p class="m-bottom-min">
                  Крім стандартизації зовнішнього вигляду
                  елементів, корисно скинути або додати
                  деякі глобальні стилі для елементів. Це
                  можна зробити в файлі
                  <b>index.css</b>.
                </p>

                <div class="bcg-box flex">
                  <p>
                    <i>/* src/index.css */ </i> <br />
                    body {<br />
                        font-family: sans-serif;<br />
                        line-height: 1.5;<br />
                    }<br />
                    <br />
                    <br />
                  </p>
                  <p>
                    h1,<br />
                    h2,<br />
                    h3,<br />
                    h4,<br />
                    h5,<br />
                    h6,<br />
                    p {<br />
                        margin: 0;<br />
                    }<br />
                  </p>
                  <p>
                    ul,<br />
                    ol {<br />
                        margin: 0;<br />
                        padding: 0;<br />
                    }<br />
                    <br />
                    img {<br />
                        display: block;<br />
                        max-width: 100%;<br />
                    }
                  </p>
                </div>
              </div>
            </section>
          </section>
        </div>
      </section>

      <!-- Компоненти -->
      <section id="components" class="main-section">
        <div class="container">
          <h2 class="m-bottom center-text">Компоненти</h2>

          <p>
            Інтерфейс користувача складається з невеликих
            елементів, таких як кнопки, текст і зображення.
            React дозволяє об'єднувати їх у багаторазово
            використовувані компоненти — основні будівельні
            блоки React-застосунків, за допомогою яких
            інтерфейс розділяється на незалежні частини.
          </p>

          <!-- Оголошення компонента -->
          <section class="section">
            <h3 class="m-bottom-min">
              Оголошення компонента
            </h3>

            <div class="m-bottom flex">
              <div>
                <p class="m-bottom-min">
                  В коді компонент — це функція, яка отримує
                  об'єкт властивостей (
                  <b>props</b> ), і повертає React-елементи
                  (HTML розмітку).
                </p>
                <p class="border-box">
                  <b>Важливо!</b> Ім'я компонента
                  обов'язково повинно починатися з великої
                  літери. Назви компонентів з маленької
                  літери зарезервовані для HTML-елементів.
                  Якщо ви спробуєте назвати компонент
                  product, а не Product, під час рендеру
                  React проігнорує його та відрендерить тег
                  <b>&#60;product&#62;&#60;/product&#62;</b
                  >.
                </p>
              </div>
              <div>
                <p class="bcg-box">
                  const Product = () => {<br />
                      return (<br />
                          &#60;div&#62;<br />
                             
                  &#60;h3&#62;Cookies&#60;/h3&#62;<br />
                              &#60;p&#62;Price: 999
                  credits&#60;/p&#62;<br />
                          &#60;/div&#62;<br />
                      );<br />
                  }
                </p>
              </div>
            </div>
          </section>

          <!-- Імпорт та експорт компонентів -->
          <section class="section">
            <h3 class="m-bottom-min">
              Імпорт та експорт компонентів
            </h3>

            <div class="m-bottom-min flex">
              <div>
                <p class="m-bottom-min">
                  Для кожного компонента створюється окремий
                  файл, тому необхідно експортувати
                  компонент із його файлу.
                </p>
                <p class="m-bottom-min border-box">
                  <b>Важливо!</b> Ім'я
                  <b>файлу компонента</b> (Product.jsx)
                  збігається з назвою самого
                  <b>компонента</b> (Product). Це
                  неофіційний стандарт.
                </p>
                <p class="border-box">
                  <b>Важливо!</b> У модулях можна
                  використовувати експорт за замовчуванням
                  (<b>export default</b>) або іменований
                  експорт (<b>export const</b>). Так як
                  компонент — це головна сутність модуля, то
                  використовується для нього експорт за
                  замовчуванням (<b>export default</b>).
                </p>
              </div>
              <div>
                <p class="bcg-box">
                  <i> // src/Product.jsx </i> <br />
                  const Product = () => {<br />
                      return (<br />
                          &#60;div&#62;<br />
                             
                  &#60;h3&#62;Tacos&#60;/h3&#62;<br />
                              &#60;p&#62;Price: 999
                  credits&#60;/p&#62;<br />
                          &#60;/div&#62;<br />
                      );<br />
                  }
                  <br />
                  export default Product;
                </p>
              </div>
            </div>

            <div class="m-bottom-min flex">
              <div>
                <p class="m-bottom-min">
                  Імпорт компоненту <b>Product</b> в
                  компоненті
                  <b>App</b>
                </p>
                <p class="m-bottom-min border-box">
                  <b>Важливо!</b> Всі <i>компоненти</i> і
                  <i>файли стилів</i> для них зберігаються у
                  <i>папці</i> <b>components</b>, всередині
                  <i>папки</i> <b>src</b>.
                </p>
                <p>
                  Усі компоненти створюються в окремих
                  файлах
                  <b>*.jsx</b>, які компонентами-батьками
                  вищого рівня імпортуються у єдиний файл
                  <b>App.jsx</b>, що в свою чергу
                  імпортується у головний файл
                  <b>main.jsx</b>, який і відрендерить
                  розмітку.
                </p>
              </div>
              <div class="bcg-box">
                <p>
                  <i>// src/App.jsx</i> <br />
                  import Product from './Product';<br />
                  <br />
                  export default function App() {<br />
                      return (<br />
                          &#60;div&#62;<br />
                              &#60;h2&#62;Best
                  selling&#60;/h2&#62;<br />
                              &#60;Product /&#62;<br />
                              &#60;Product /&#62;<br />
                          &#60;/div&#62;<br />
                      );<br />
                  }
                </p>
              </div>
            </div>
          </section>

          <!-- JSX — опис UI -->
          <section class="section">
            <h3 class="m-bottom-min">JSX — опис UI</h3>

            <div class="m-bottom-min flex">
              <p>
                Синтаксис JSX дуже схожий на HTML, але має
                деякі особливості, які слід враховувати.
                Якщо
                <b>тег</b> <i>порожній</i> або
                <i>самозакриваючийся</i>, його обов'язково
                треба закрити за допомогою <b>/></b>.
              </p>
              <div>
                <p class="bcg-box">
                  &#60;img src="" alt="" <b>/</b>&#62;
                  <br />
                  &#60;input type="text" <b>/</b>&#62;
                </p>
              </div>
            </div>

            <div class="m-bottom-min flex">
              <p>
                Під час рендерингу
                <b>компонента</b> також використовується
                синтаксис JSX, тому обов'язково треба
                закрити тег компонента зі зворотним слешем
                (/) перед закриваючою дужкою тега.
              </p>
              <div class="bcg-box">
                <p>
                  &#60;App <b>/</b>&#62; <br />
                  &#60;Product <b>/</b>&#62;
                </p>
              </div>
            </div>

            <div class="m-bottom-min flex">
              <p>
                Деякі атрибути мають інші назви в порівнянні
                з HTML. Наприклад,
                <i>атрибут</i> <b>for</b> тега
                <i>label</i> в JSX називається
                <b>htmlFor</b>.
              </p>

              <div class="bcg-box">
                <p>
                  &#60;label <b>htmlFor</b>="login"&#62;
                  <br />
                      &#60;input id="login" /&#62;
                  <br />
                  &#60;/label&#62;
                </p>
              </div>
            </div>

            <div class="m-bottom-min flex new-page">
              <div>
                <p class="m-bottom-min">
                  У будь-яких двох або більше сусідніх тегів
                  повинен бути спільний батько, інакше
                  виникне помилка.
                </p>
                <p>
                  Компонент повинен
                  <i>повертати лише одне значення</i>, тому
                  існує правило <b>спільного батька</b>.
                </p>
              </div>
              <div class="bcg-box print-fs-12">
                <p>
                  <i> // src/components/Product.jsx </i
                  ><br />
                  export const Product = () => {<br />
                      return (<br />
                          <b>&#60;div&#62;</b><br />
                             
                  &#60;h3&#62;Tacos&#60;/h3&#62;<br />
                              &#60;p&#62;Price: 999
                  credits&#60;/p&#62;<br />
                          <b>&#60;/div&#62;</b><br />
                      ); <br />
                  }
                </p>
              </div>
            </div>

            <div class="m-bottom-min flex">
              <div>
                <p class="m-bottom-min">
                  Якщо зайвий обгортальний тег не потрібен в
                  розмітці, використовуються
                  <b>фрагменти</b>. Синтаксис виглядає як
                  <i>тег без імені</i>.
                </p>
                <p class="border-box">
                  <b>Цікаво!</b> Насправді замість
                  "порожнього" тега <b> &#60;&#62;</b
                  ><b>&#60;/&#62;</b>, React вставляє
                  вбудований компонент Fragment. Цей
                  вбудований компонент при рендері
                  розкривається, підставляючи свій вміст.
                </p>
              </div>
              <div>
                <p class="bcg-box print-fs-12">
                  ...<br />
                      <b> &#60;&#62;</b> <br />
                          &#60;h3&#62;Tacos&#60;/h3&#62;<br />
                          &#60;p&#62;Price: 999
                  credits&#60;/p&#62;<br />
                      <b>&#60;/&#62;</b> <br />...
                </p>
              </div>
            </div>

            <div class="m-bottom-min flex">
              <div>
                <p class="m-bottom-min">
                  У межах JSX можна використовувати
                  будь-який валідний вираз, заключаючи його
                  у
                  <i>фігурні дужки</i>. Все інше буде
                  розглядатися як текст.
                </p>
                <p>
                  Значення <i>атрибутів</i> вказуються в
                  <b>подвійних лапках</b>, якщо це звичайний
                  <i>рядок</i>, та у <b>фігурних дужках</b>,
                  якщо значення
                  <i>відрізняється від рядка</i> або
                  знаходиться в <i>змінній</i>.
                </p>
              </div>
              <div>
                <p class="bcg-box print-fs-12">
                  <i> // src/components/Product.jsx</i
                  ><br />
                  export const Product = () => {<br />
                  const price = 999;<br />
                  const imgUrl =
                  "&#60;https://img.com/photos/photo.jpeg?dpr=2&h=480&w=640>";
                  <br />
                      return (<br />
                          &#60;><br />
                              &#60;h3>Tacos&#60;/h3><br />
                              &#60;img src={imgUrl}
                  alt="Tacos With Lime" width="640" /><br />
                              &#60;p>Price: {price}
                  credits&#60;/p><br />
                          &#60;/><br />
                      ); <br />
                  }
                </p>
              </div>
            </div>
          </section>

          <!-- Властивості компонента (props) -->
          <section class="section">
            <h3 class="m-bottom-min">
              Властивості компонента (props)
            </h3>

            <div>
              <p class="m-bottom-min">
                Компоненти приймають довільні властивості
                (налаштування,
                <b>пропси</b>) і повертають розмітку, яку
                потрібно відрендерити в DOM.
              </p>
              <p class="m-bottom-min">
                Без пропсів компонент завжди повертає
                однакову розмітку
              </p>
            </div>

            <div class="m-bottom-min flex">
              <p class="m-bottom-min">
                Пропсом може бути текст кнопки, зображення,
                URL, будь-які дані для компонента. Пропси
                можуть бути рядками або результатом
                JS-виразу. Пропси передаються в компонент в
                місці його використання, аналогічно
                аргументам функції.
              </p>
              <div class="bcg-box print-fs-12">
                <p>
                  <i> // src/components/App.jsx</i><br />
                  import { Product } from './Product';<br />
                  export default function App() {<br />
                      return (<br />
                          &#60;div><br />
                              &#60;h2>Best
                  selling&#60;/h2><br />
                              &#60;Product
                  <b>name="Tacos With Lime"</b> /><br />
                              &#60;Product
                  <b>name="Fries and Burger"</b>
                  /><br />
                          &#60;/div><br />
                      ); <br />
                  }
                </p>
              </div>
              <div class="bcg-box print-fs-12">
                <p>
                  <i> // src/components/Product.jsx</i
                  ><br />
                  export const Product = props => {<br />
                      return (<br />
                          &#60;div><br />
                              &#60;h3>
                  <b>{props.name}</b>&#60;/h3><br />
                              &#60;p>Price: 999
                  credits&#60;/p><br />
                          &#60;/div><br />
                      ); <br />
                  }
                </p>
              </div>
            </div>

            <p class="m-bottom-min">
              Будь-який компонент, в тому числі Product,
              оголошує один параметр — <i>props</i>, це
              завжди буде <i>об'єкт</i>, що містить
              <i>усі передані пропси</i>.
            </p>

            <div class="m-bottom flex">
              <p class="m-bottom-min">
                Пропси використовуються для передачі
                динамічних значень для компонента,
                наприклад, для використання в JSX-розмітці,
                використовуючи синтаксис
                <b>{}</b>
              </p>
              <div class="bcg-box print-fs-12">
                <p>
                  <i> // src/components/App.jsx </i><br />
                  ...<br />
                      &#60;div><br />
                          &#60;Product<br />
                             
                  <b
                    >name="Tacos With Lime"<br />
                               
                    imgUrl="https://images.com/photo-4.jpeg<br />
                                price={10.99}</b
                  ><br />
                          /><br />
                          &#60;Product<br />
                             
                  <b
                    >name="Fries and Burger"<br />
                               
                    imgUrl="https://images.com/photo-7.jpeg<br />
                                price={14.29}</b
                  ><br />
                          /><br />
                      &#60;/div><br />
                  ...
                </p>
              </div>
              <div class="bcg-box print-fs-12">
                <p>
                  <i> // src/components/Product.jsx</i
                  ><br />
                  export const Product = props => {<br />
                      return (<br />
                          &#60;div><br />
                              &#60;h3>
                  <b>{props.name}</b>&#60;/h3><br />
                              &#60;img <br />
                                  src=<b>{props.imgUrl}</b
                  ><br />
                                  alt=<b>{props.name}</b
                  ><br />
                                  width="480"<br />
                              /><br />
                              &#60;p>Price:
                  <b>{props.price}</b>
                  credits&#60;/p><br />
                          &#60;/div><br />
                      );<br />
                  };
                </p>
              </div>
            </div>

            <section class="sub-section new-page">
              <h4 class="m-bottom-min">
                <b>Деструктуризація</b>
              </h4>

              <div class="flex">
                <p>
                  <b>props</b> – це об'єкт, отже можна
                  деструктуризувати його у підписі функції.
                  Це робить код чистішим і читабельнішим.
                </p>
                <div class="bcg-box">
                  <p>
                    export const Product = (<b
                      >{ name, imgUrl, price }</b
                    >
                    ) => {<br />
                        return (<br />
                            &#60;div><br />
                                &#60;h3>
                    <b>{name}</b>&#60;/h3><br />
                                &#60;img src=<b>{imgUrl}</b>
                    alt=<b>{name}</b> width="480" /><br />
                                &#60;p>Price:
                    <b>{price}</b> credits&#60;/p><br />
                            &#60;/div><br />
                        );<br />
                    };<br />
                  </p>
                </div>
              </div>
            </section>

            <section class="sub-section">
              <h4 class="m-bottom-min">
                Значення пропсів за замовчуванням
              </h4>

              <div class="flex">
                <div>
                  <p class="m-bottom-min">
                    Якщо компонент очікує яке-небудь
                    значення, а його не передати — під час
                    звернення до властивості об'єкта
                    <i>props</i> отримаємо <b>undefined</b>.
                  </p>
                  <p class="m-bottom-min">
                    Щоб вказати значення властивостей за
                    замовчуванням, використовується
                    синтаксис значень за замовчуванням
                    <i>під час деструктуризації</i>
                    пропсів.
                  </p>
                  <p class="border-box">
                    <b>Важливо!</b>
                    Значення за замовчуванням не потрібно
                    задавати всім пропсам; абсолютна
                    більшість це обов'язкові значення для
                    правильної роботи компонента. Проте,
                    наприклад, значення зображення за
                    замовчуванням може бути корисним.
                  </p>
                </div>
                <div class="bcg-box print-fs-12">
                  <p>
                    <i>// src/components/Product.jsx</i>
                    <br />
                    const Product = ({<br />
                        name,<br />
                       
                    <b
                      >imgUrl =
                      "https://image.com/photo-5.jpg"</b
                    >,<br />
                        price,<br />
                    }) => { <br />
                        return (<br />
                            &#60;div><br />
                                &#60;h3>{name}&#60;/h3><br />
                                &#60;img <br />
                                    src={imgUrl} <br />
                                    alt={name} <br />
                                    width="480" <br />
                                /><br />
                                &#60;p>Price: {price}
                    credits&#60;/p><br />
                            &#60;/div><br />
                        );<br />
                    }
                  </p>
                </div>
              </div>
            </section>

            <section class="sub-section">
              <h4 class="m-bottom-min">Підсумок</h4>

              <ul>
                <li>
                  пропси використовуються для передачі даних
                  від батька до дитини;
                </li>
                <li>
                  пропси передаються лише вниз по дереву від
                  батьківського компонента;
                </li>
                <li>
                  пропси доступні лише для читання, їх не
                  можна змінити.
                </li>
              </ul>
            </section>
          </section>

          <!-- Умовний рендеринг -->
          <section class="section">
            <h3 class="m-bottom-min">Умовний рендеринг</h3>

            <p class="m-bottom">
              <b>Умовний рендеринг</b> в React — це
              механізм, який дозволяє відображати різний
              контент або компоненти на основі <b>умови</b>.
            </p>

            <section class="sub-section">
              <h4 class="m-bottom-min">Оператор &&</h4>

              <div class="m-bottom-min flex">
                <p>
                  Логічний оператор
                  <b>&&</b> використовується для рендера
                  розмітки лише у випадку, якщо умова
                  виконується, тобто приводиться до
                  <b>true</b>.
                </p>
                <div>
                  <p class="bcg-box">
                    {умова && розмітка}<br />
                  </p>
                </div>
              </div>

              <div class="flex">
                <div>
                  <p class="m-bottom-min">
                    <i>Зліва</i> ставиться умова рендеру,
                    <i>справа</i> JSX розмітка, що буде
                    відрендерена якщо умова зліва
                    наближається до true. В іншому випадку
                    результатом виразу буде false -
                    значення, яке не рендериться.
                  </p>
                  <p class="m-bottom-min">
                    У JSX вираз обгортається в <b>{}</b>,
                    щоб відобразити його результат.
                  </p>
                  <p class="border-box">
                    Якщо за умови нічого не повинно бути
                    відрендерено, можна повернути
                    <b>null</b>, <b>undefined</b> або
                    <b>false</b>. Ці значення
                    <i>не будуть відображені</i>.
                  </p>
                </div>
                <div class="bcg-box print-fs-12">
                  <p>
                    const Mailbox = ({ username, messages })
                    => {<br />
                        return (<br />
                            &#60;><br />
                                &#60;p>Hello
                    {username}&#60;/p><br />
                               
                    <b
                      >{messages.length > 0 && (<br />
                                      &#60;p><br />
                                          You have
                      {messages.length} messages<br />
                                      &#60;/p><br />
                                  )}</b
                    ><br />
                            &#60;/><br />
                        );<br />
                    };
                  </p>
                </div>
              </div>
            </section>

            <section class="sub-section">
              <h4 class="m-bottom-min">
                Тернарний оператор
              </h4>

              <div class="flex">
                <p>
                  Використовується, якщо в результаті
                  перевірки умови потрібно відобразити
                  <b>різну розмітку</b>.
                </p>
                <div class="bcg-box">
                  <p>
                    умова ? вміст_якщо_умова_true :
                    вміст_якщо_умова_false<br />
                  </p>
                </div>
              </div>
            </section>
          </section>

          <!-- Колекції -->
          <section class="section new-page">
            <h3 class="m-bottom-min">Колекції</h3>

            <div class="m-bottom flex">
              <div>
                <p class="m-bottom-min">
                  Для того щоб відрендерити колекцію
                  елементів, використовується масив даних і
                  метод map(), що для кожного елемента
                  колекції повертає розмітку.
                </p>

                <p class="">
                  В JSX цей вираз обгортається у фігурні
                  дужки {}.
                </p>
              </div>
              <div class="bcg-box">
                <p>
                  &#60;div><br />
                  <b
                    >    {[1, 2, 3].map(item => {<br />
                            return
                    &#60;div>{item}&#60;/div>;<br />
                        })}</b
                  ><br />
                  &#60;/div>
                  <br />
                </p>
              </div>
            </div>

            <section class="sub-section">
              <h4 class="m-bottom-min">Ключі елементів</h4>

              <div class="m-bottom-min flex">
                <div>
                  <p class="m-bottom-min">
                    <b>Ключ (key)</b> — це спеціальний проп,
                    який потрібно задати під час створення
                    елементів колекції.
                  </p>

                  <p class="m-bottom-min">
                    React використовує ключі, щоб визначити,
                    які з елементів в колекції необхідно
                    оновити, уникнувши перестворення всіх
                    елементів колекції при змінах.
                  </p>

                  <p>Ключі повинні бути:</p>
                  <ul class="m-bottom-min">
                    <li>
                      <i>унікальними</i> — ключ елемента
                      повинен бути унікальним лише всередині
                      однієї колекції. Глобально унікальні
                      ключі не мають сенсу;
                    </li>
                    <li>
                      <i>стабільними</i> — ключ елемента не
                      повинен змінюватися з часом, зі зміною
                      порядку елементів або після оновлення
                      сторінки.
                    </li>
                  </ul>

                  <p>Для ключа не можна використовувати:</p>
                  <ul class="">
                    <li>
                      <b>індекси масиву</b> унікальні, проте
                      вони не стабільні — при видаленні або
                      перетасовці елементів індекси
                      змінюються (<i
                        >вікористовувати лише, якщо всі інщі
                        варіанти не підходять</i
                      >);
                    </li>
                    <li>
                      <b>дата і час</b> унікальні, але не
                      стабільні, оскільки постійно
                      збільшуються. Таким чином, при кожному
                      рендері створюються нові ключі;
                    </li>
                    <li>
                      <b>випадкові числа</b> не є
                      унікальними або стабільними.
                    </li>
                  </ul>
                </div>
                <div class="bcg-box">
                  <p>
                    const favouriteBooks = [<br />
                        { id: "id-1", name: "JS for
                    beginners" },<br />
                        { id: "id-2", name: "React basics"
                    },<br />
                        { id: "id-3", name: "React Router"
                    }<br />
                    ];<br />
                    <br />
                    const BookList = ({ books }) => {<br />
                        return (<br />
                            &#60;ul><br />
                                {books.map((book) => {<br />
                                    return <br />
                                        &#60;li
                    <b>key={book.id}</b>>
                    {book.name}&#60;/li>;<br />
                                })}<br />
                            &#60;/ul><br />
                        );<br />
                    };<br />
                    <br />
                    const App = () => {<br />
                        return (<br />
                            &#60;><br />
                                &#60;h2>Books of the
                    week&#60;/h2><br />
                                &#60;BookList
                    books={favouriteBooks} /><br />
                            &#60;/><br />
                        );<br />
                    };
                  </p>
                </div>
              </div>

              <p class="border-box">
                Найкращий спосіб задати ключ —
                використовувати статичний рядок, який
                <i>ідентифікує елемент списку</i> серед
                інших. Найчастіше використовуються id
                об'єктів, створених базою даних, – постійні,
                незмінні значення. Також підходить будь-яке
                унікальне значення якої-небудь властивості
                об'єкта.
              </p>
            </section>
          </section>

          <!-- Властивість props.children -->
          <section class="section">
            <h3 class="m-bottom-min">
              Властивість props.children
            </h3>
            <div class="m-bottom-min flex">
              <div>
                <p class="m-bottom-min">
                  Щоб відобразити компонент із вмістом між
                  відкриваючим і закриваючим тегами
                  необхідно використати службовий пропс и
                  <b>props.children</b>.
                </p>
                <p class="border-box">
                  Значенням props.children може бути
                  будь-що, включаючи теги та інші компоненти
                  будь-якої складності.
                </p>
              </div>
              <div class="bcg-box">
                <i>// Оголошення</i><br />
                const Card = ({ children }) => {<br />
                    return &#60;div>{children}&#60;/div>
                ;<br />
                };<br />
                <br />
                <i>// Використання</i><br />
                &#60;Card>Text between opening and closing
                tag&#60;/Card ><br />
              </div>
            </div>

            <div class="bcg-box" style="width: max-content">
              <p>
                <i>// Оголошення</i><br />
                const Card = ({ children }) => {<br />
                    return &#60;div>{children}&#60;/div>;<br />
                };<br /><br />
                <i>// Використання</i><br />
                &#60;Card><br />
                    &#60;h2>Card title&#60;/h2><br />
                    &#60;p>Text between opening and closing
                tag&#60;/p><br />
                &#60;/Card>
              </p>
            </div>
          </section>

          <!-- Рендер додатка в DOM -->
          <section class="section new-page">
            <h3 class="m-bottom-min">
              Рендер додатка в DOM
            </h3>

            <div class="m-bottom-min flex">
              <div>
                <p>
                  Щоб відрендерити всі компоненти додатка в
                  DOM, у файлі
                  <b>main.jsx</b> використовують методи
                  createRoot(container) та render(element),
                  які працюють разом.
                </p>

                <ul>
                  <li>
                    метод <b>createRoot</b> приймає
                    посилання на існуючий DOM-елемент,
                    наприклад, <i>div#root</i> з
                    <i>index.html</i>, і створює корінь, в
                    який буде рендеритися додаток;
                  </li>
                  <li>
                    метод <b>render</b> приймає посилання на
                    компонент, який потрібно відрендерити.
                    Завжди рендериться App — кореневий
                    компонент додатка.
                  </li>
                </ul>
              </div>
              <div class="bcg-box">
                <p>
                  <i>// src/main.jsx </i><br />
                  import React from "react";<br />
                  import ReactDOM from
                  "react-dom/client";<br />
                  import App from "./App.jsx";<br />
                  <br />
                  ReactDOM.<b>createRoot</b>(document.getElementById("root"))<br />
                      .<b>render</b>(<br />
                          &#60;React.StrictMode><br />
                              &#60;App /><br />
                          &#60;/React.StrictMode><br />
                      );
                </p>
              </div>
            </div>

            <p>
              <b>&#60;React.StrictMode></b> — вбудований
              компонент, який дозволяє виявляти потенційні
              проблеми в компонентах додатка та попереджати
              про них під час розробки. Він не впливає на
              виконання додатка у продакшені, але допомагає
              знаходити та виправляти проблеми під час
              розробки. Його основні функції:
            </p>

            <ul class="m-bottom-min">
              <li>
                сповіщення про використання застарілих
                методів і функцій в React, які можуть бути
                вилучені в майбутніх версіях;
              </li>
              <li>
                виявлення побічних ефектів під час
                рендерингу компонентів, що може призвести до
                непередбачуваної поведінки;
              </li>
              <li>
                сповіщення про потенційні проблеми в
                render-методах, такі як виклик нечистих
                функцій під час рендерингу;
              </li>
              <li>
                виявлення помилок у функціях обробки подій
                та їх інших частинах життєвого циклу
                компонентів.
              </li>
            </ul>

            <p class="m-bottom-min border-box">
              <b>Важливо!</b> Достатньо використовувати лише
              один виклик render для того, щоб відрендерити
              найвищий компонент в ієрархії (App), що
              призведе до рендеру всіх інших компонентів
              додатка.
            </p>

            <p class="border-box">
              <b>Цікаво!</b> Односторінковий застосунок (SPA
              - Single Page Application) — cучасний підхід,
              сайт, на якому користувач ніколи не переходить
              на інші HTML-сторінки. Інтерфейс, замість
              запиту HTML-документів з сервера,
              перемальовується у браузері, на одній і тій
              самій сторінці, без перезавантаження.
            </p>
          </section>

          <!-- Типізація пропсів -->
          <section class="section">
            <h3 class="m-bottom-min">Типізація пропсів</h3>

            <div class="flex">
              <div>
                <p class="m-bottom-min">
                  Перевірка типів отриманих компонентом
                  пропсів допомагає виявити помилки
                  (наприклад, очікуємо у пропсі масив, але
                  передали число або інше неприпустиме
                  значення).
                </p>

                <p class="m-bottom-min">
                  Пакет <b>prop-types</b> надає низку
                  валідаторів для перевірки коректності
                  отриманих типів даних під час виконання
                  коду, повідомляючи про невідповідності в
                  консолі.
                </p>

                <div
                  class="m-bottom-min bcg-box center-element center-text"
                  style="max-width: fit-content"
                >
                  <p>npm install --save-dev prop-types</p>
                </div>

                <p>
                  Для опису пропсів компонента необхідно
                  описати їх типи, що він отримує, в
                  спеціальній властивості
                  <b>propTypes</b>.
                </p>
              </div>
              <div class="bcg-box">
                <p>
                  <i> // src/components/Product.jsx </i
                  ><br />
                  import PropTypes from 'prop-types';<br /><br />
                  const Product = ({<br />
                      name,<br />
                      imgUrl =
                  "https://dummyimage.com/image-1.jpg",<br />
                      price,<br />
                  }) => (<br />
                      &#60;div><br />
                          &#60;img src={imgUrl} alt={name}
                  width="480" /><br />
                          &#60;h3>{name}&#60;/h3><br />
                          &#60;p>Price: {price}
                  credits&#60;/p><br />
                      &#60;/div><br />
                  );<br />
                  <br />
                  // Опис типів пропсів компонента <br />
                  <b
                    >Product.propTypes = {<br />
                        name:
                    PropTypes.string.isRequired,<br />
                        imgUrl: PropTypes.string,<br />
                        price:
                    PropTypes.number.isRequired,<br />
                    };<br
                  /></b>
                  <br />
                  export default Product;<br />
                </p>
              </div>
            </div>
          </section>
        </div>
      </section>

      <div class="next-page"></div>

      <!-- Стилі -->
      <section id="styles" class="main-section">
        <div class="container">
          <h2 class="m-bottom center-text">Стилі</h2>

          <!-- Вбудовані стилі -->
          <section class="section">
            <h3 class="m-bottom-min">Вбудовані стилі</h3>
            <div class="m-bottom flex">
              <div>
                <p class="m-bottom-min">
                  Для стилізації за допомогою вбудованих
                  стилів використовується атрибут
                  <b>style</b>, який у React приймає
                  <i>не рядок, а об'єкт стилів</i>.
                </p>

                <ul>
                  <li>
                    <i>імена властивостей</i>, що
                    складаються з <i>двох і більше слів</i>,
                    наприклад background-color, обов'язково
                    повинні бути записані в
                    <b>camelCase</b> нотації (<b
                      >backgroundColor</b
                    >
                    ), як при зверненні до властивостей
                    об'єкта style у DOM-елемента.
                  </li>
                  <li>
                    до <i>числових значень</i> більшості
                    властивостей буде автоматично додано
                    суфікс <b>px</b>. Якщо необхідно
                    використовувати одиниці відмінні від px,
                    або значення складається з кількох
                    частин, воно вказується як рядок.
                  </li>
                </ul>
              </div>

              <div class="bcg-box">
                <div class="bcg-box">
                  <p>
                    <i>// src/components/App.jsx </i><br />
                    export const App = () => {<br />
                        return (<br />
                            &#60;p<br />
                               
                    <b
                      >style={{<br />
                                      padding: "12px
                      16px",<br />
                                      borderRadius: 4,<br />
                                      fontSize: 16,<br />
                                      color: "white",<br />
                                  }}</b
                    ><br />
                            ><br />
                                text<br />
                            &#60;/p><br />
                        );<br />
                    };<br /><br /><br />
                  </p>
                </div>
                <p class="center-text">
                  <b
                    >Стилі описанні безпосередньо <br />в
                    атрибуті тега</b
                  >
                </p>
              </div>

              <div class="bcg-box">
                <div class="bcg-box">
                  <p>
                    <i>// src/components/App.jsx </i><br />

                    <b
                      >const alertStyles = {<br />
                          padding: "12px 16px",<br />
                          borderRadius: 4,<br />
                          fontSize: 16,<br />
                          color: "white",<br />
                      }</b
                    >;<br /><br />
                    export const App = () => {<br />
                        return (<br />
                            &#60;><br />
                                &#60;p<br />
                                   
                    <b>style={alertStyles}</b><br />       
                        >text&#60;/p><br />
                            &#60;/><br />
                        );<br />
                    };
                  </p>
                </div>
                <p class="center-text">
                  <b>
                    Опис стилів винесений у <br />окрему
                    змінну
                  </b>
                </p>
              </div>
            </div>

            <!-- Динамічні стилі -->
            <section class="sub-section">
              <h4 class="m-bottom-min">Динамічні стилі</h4>

              <p class="m-bottom-min">
                Динамічні стилі - вбудовані стилі, які
                змінюються при виконанні умови.
              </p>
              <div class="flex">
                <div>
                  <div class="m-bottom-min bcg-box">
                    <p>
                      <i> // src/components/App.jsx </i
                      ><br />
                      import { Alert } from "./Alert";<br />
                      <br />
                      const App = () => {<br />
                          return (<br />
                              &#60;><br />
                                  &#60;Alert
                      variant="error"> Text &#60;/Alert><br />
                                  &#60;Alert
                      variant="success">Text&#60;/Alert><br />
                              &#60;/><br />
                          );<br />
                      };<br />
                    </p>
                  </div>

                  <div class="border-box m-bottom-min">
                    <p><b>Підсумок:</b></p>
                    <ul>
                      <li>
                        слабка масштабованість та повторне
                        використання стилів;
                      </li>
                      <li>
                        обмежені можливості (псевдокласи,
                        псевдоелементи, адаптивні
                        властивості);
                      </li>
                      <li>
                        погана продуктивність при
                        відмальовуванні великої кількості
                        елементів;
                      </li>
                      <li>
                        відсутність зручних інструментів
                        розробника;
                      </li>
                      <li>
                        немає підтримки в популярних
                        інструментах, наприклад
                        autoprefixer.
                      </li>
                    </ul>
                  </div>

                  <div class="border-box">
                    <p>
                      <b>Важливо!</b>
                      На практиці вбудовані стилі
                      використовуються тільки для динамічно
                      обчислюваних значень властивостей, у
                      парі із зовнішніми таблицями стилів.
                    </p>
                  </div>
                </div>

                <div class="bcg-box">
                  <p>
                    <i>// src/components/Alert.jsx </i
                    ><br />
                    const alertStyles = {<br />
                        color: "white",<br />
                    };<br />
                    <br />
                    const getBgColor = variant => {<br />
                        switch (variant) {<br />
                            case "success":<br />
                                return "green";<br />
                            case "error":<br />
                                return "red";<br />
                            default:<br />
                                throw new Error("Text
                    default");<br />
                        }<br />
                    };<br />
                    <br />
                    export const Alert = ({ variant,
                    children }) => {<br />
                        return (<br />
                            &#60;p<br />
                                style={{<br />
                                    ...alertStyles,<br />
                                    backgroundColor:
                    getBgColor(variant),<br />
                                }}<br />
                            >{children}&#60;/p><br />
                        );<br />
                    };<br />
                  </p>
                </div>
              </div>
            </section>
          </section>

          <!-- Ванільний CSS -->
          <section class="section new-page">
            <h3 class="m-bottom-min">Ванільний CSS</h3>

            <div class="m-bottom-min flex">
              <div>
                <p class="m-bottom-min">
                  Стилі компонента винести до окремої
                  таблиці стилів. Стилі кожного компонента
                  оголошуються в окремому CSS-файлі з
                  розширенням
                  <b>*.css</b>. Ім'я файлу складається з
                  <i>імені компонента</i> та
                  <i>розширення</i> (Alert.css).
                </p>
                <p class="border-box">
                  <b>Важливо!</b> Всередині файлу стилів
                  можна написати будь-який валідний CSS код.
                  Хорошою практикою буде писати CSS тільки
                  для HTML-розмітки компонента до якого
                  належить цей файл стилів.
                </p>
              </div>

              <div class="bcg-box">
                <p>
                  <i> /* src/components/Alert.css */ </i
                  ><br /><br />
                  .alert {<br />
                      margin: 8px;<br />
                      padding: 12px 16px;<br />
                      border-radius: 4px;<br />
                      background-color: gray;<br />
                      color: white;<br />
                  }
                </p>
              </div>
            </div>

            <div class="m-bottom flex">
              <div>
                <p class="m-bottom-min">
                  Стилі компонента
                  <b
                    >імпортуються у файл оголошення
                    компонента</b
                  >, після чого CSS-класи описані у таблиці
                  стилів доступні для використання.
                </p>
                <p>
                  У React HTML-атрибуту class відповідає
                  JSX-атрибут <b>className</b>, куди можна
                  передати рядок з перерахуванням усіх
                  класів елемента.
                </p>
              </div>
              <div class="bcg-box">
                <p>
                  <i>// src/components/Alert.jsx </i><br />
                  <b>import "./Alert.css"</b>;<br />
                  <br />
                  const Alert = ({ children }) => {<br />
                      return &#60;p
                  className="alert">{children} &#60;/p>;<br />
                  };
                </p>
              </div>
            </div>

            <!-- Композиція класів -->
            <section class="sub-section">
              <h4 class="m-bottom-min">
                Композиція класів
              </h4>

              <p class="m-bottom-min">
                Процес обчислення
                <i>фінального значення атрибуту</i>
                <b>className</b> залежить від розробника та
                поточного завдання. Наприклад,
                використовуємо масив рядків та метод join
                щоб отримати рядок класів.
              </p>

              <div class="flex">
                <div class="bcg-box">
                  <p>
                    <i> // src/components/Alert.jsx </i
                    ><br />
                    import "./Alert.css";<br />
                    <br />
                    const Alert = ({ variant, children }) =>
                    {<br />
                        const classNames = ["alert",
                    variant];<br />
                    <br />
                        return <br />
                            &#60;p
                    className={classNames.join(" ")}><br />
                                {children}<br />
                            &#60;/p>;<br />
                    };
                  </p>
                </div>
                <div class="bcg-box flex" style="gap: 16px">
                  <div>
                    <p>
                      <i> /* src/components/Alert.css */ </i
                      ><br />

                      .alert {<br />
                          margin: 8px;<br />
                          padding: 12px 16px;<br />
                          border-radius: 4px;<br />
                          color: white;<br />
                      }<br />

                      <br />
                      .alert.is-outlined {<br />
                          outline: 1px solid black;<br />
                      }<br />
                      <br />
                      .alert.is-elevated {<br />
                          box-shadow: <br />
                              rgb(0 0 0 / 20%) 0px 3px,<br />
                              rgb(0 0 0 / 14%) 0px 4px,<br />
                              rgb(0 0 0 / 12%) 0px 1px;<br />
                      }
                    </p>
                  </div>
                  <div>
                    <p>
                      <i>// src/components/Alert.jsx </i
                      ><br />
                      import "./Alert.css";<br />
                      <br />
                      const Alert = ({<br />
                          variant,<br />
                          outlined,<br />
                          elevated,<br />
                          children<br />
                      }) => {<br />
                          const classNames = ["alert",
                      variant];<br />
                      <br />
                          if (outlined) {<br />
                             
                      classNames.push("is-outlined");<br />
                          }<br />
                      <br />
                          if (elevated) {<br />
                             
                      classNames.push("is-elevated");<br />
                          }<br />
                      <br />
                          return <br />
                              &#60;p
                      className={classNames.join(" ")}>
                      <br />
                                  {children}<br />
                             &#60;/p>;<br />
                      };
                    </p>
                  </div>
                </div>
              </div>
            </section>

            <!-- Бібліотека clsx -->
            <section class="sub-section new-page">
              <h4 class="m-bottom-min">Бібліотека clsx</h4>
              <div class="m-bottom-min flex">
                <p class="m-bottom-min">
                  Бібліотека <b>clsx</b> дозволяє виріити
                  більшість завдань, пов'язаних з безліччю
                  класів, що задаються згідно з певними
                  умовами.
                </p>
                <div class="bcg-box">
                  <p>
                    <i>// у терміналі</i> <br />
                    <b>npm install clsx</b>
                  </p>
                </div>
              </div>

              <div class="m-bottom-min flex">
                <p>
                  <b>Функції clsx</b> можна передати список
                  виразів як набір аргументів. Вирази що
                  приводяться до <b>true</b>, результат яких
                  це рядок або число, буде додано у
                  фінальний рядок класів.
                </p>
                <div class="bcg-box print-fs-12">
                  <p>
                    <b>import clsx from "clsx"</b>;<br />
                    <br />
                    const className = <b>clsx</b>(<br />
                    <b>
                          "first",<br />
                          10,<br />
                          undefined && "second",<br />
                          true && "third",<br />
                          false ? "fourth" : "fifth"<br />
                    </b>
                    );<br />
                    <br />
                    console.log(className); <br />
                        // "first 10 third fifth"
                  </p>
                </div>
                <div class="bcg-box print-fs-12">
                  <i> // src/components/Alert.jsx </i><br />
                  import clsx from "clsx";<br />
                  import "./Alert.css";<br />
                  <br />
                  const Alert = ({ variant, outlined,
                  elevated, children }) => {<br />
                      return (<br />
                          &#60;p<br />
                              className={<b>clsx</b>(<br />
                  <b>
                                    "alert",<br />
                                    variant,<br />
                                    outlined &&
                    "is-outlined",<br />
                                    elevated &&
                    "is-elevated"<br />
                  </b>
                              )}<br />
                          ><br />
                              {children}<br />
                          &#60;/p><br />
                      );<br />
                  };
                </div>
              </div>

              <div class="flex">
                <div>
                  <p class="m-bottom-min">
                    Можна комбінувати варіативну та об'єктну
                    форму функції clsx. Спочатку передаються
                    класи, які будуть завжди, після чого в
                    об'єкті налаштувань перераховуємо
                    динамічні значення класів залежно від
                    якихось обчислень.
                  </p>
                  <p class="border-box m-bottom-min">
                    <b>Важливо!</b> Варто пам'ятати, що
                    класи з однаковими назвами, в залежності
                    від підключення компонентів, що на них
                    посилаються, можуть перевизначати
                    властивості одне одного.
                  </p>

                  <p><b>Підсумок</b>:</p>
                  <ul>
                    <li>слабка масштабованість;</li>
                    <li>
                      обмежене повторне використання стилів;
                    </li>
                    <li>
                      для динамічних значень необхідно
                      використовувати вбудовані стилі;
                    </li>
                    <li>
                      проблема глобального простору імен;
                    </li>
                    <li>
                      необхідність використовувати якусь
                      конвенцію іменування селекторів класу.
                    </li>
                  </ul>
                </div>
                <div class="bcg-box print-fs-12">
                  <p>
                    <i> // src/components/Alert.jsx </i
                    ><br />
                    import clsx from "clsx";<br />
                    import "./Alert.css";<br />
                    <br />
                    const Alert = ({ variant, outlined,
                    elevated, children }) => {<br />
                        return (<br />
                            &#60;p<br />
                                className={clsx("alert",
                    variant, {<br />
                                    "is-outlined":
                    outlined,<br />
                                    "is-elevated":
                    elevated,<br />
                                })}<br />
                            ><br />
                                {children}<br />
                            &#60;/p><br />
                        );<br />
                    };<br />
                  </p>
                </div>
              </div>
            </section>

            <!-- Повторне використання стилів -->
            <section class="sub-section">
              <h4 class="m-bottom-min">
                Повторне використання стилів
              </h4>
              <div class="m-bottom flex">
                <div>
                  <p class="m-bottom-min">
                    Не рекомендується використовувати одні й
                    ті самі CSS-класи в різних компонентах,
                    для цього є композиція компонентів.
                  </p>
                  <p>
                    Наприклад, замість використання базового
                    CSS-класу <b>.button</b> у компонентах
                    <b>&#60;LoginButton></b> та
                    <b>&#60;FollowButton></b>, краще
                    створити компонент
                    <b>&#60;Button></b> зі своїми власними
                    стилями, які можуть відображатись у
                    кількох варіантах. Тоді компоненти
                    <b>&#60;LoginButton></b> та
                    <b>&#60;FollowButton></b> можуть
                    використовувати компонент
                    <b>&#60;Button></b>, а не просто
                    CSS-клас.
                  </p>
                </div>
                <div class="bcg-box print-fs-12">
                  <p>
                    <i> // Button.jsx </i><br />
                    const Button = ({ variant, children })
                    => {<br />
                       
                    <i
                      >// Базові стилі кнопки з кількома
                      варіантами відображення</i
                    ><br />
                        return <br />
                            &#60;button
                    className={clsx("button",
                    variant)}>{children}&#60;/button>;<br />
                    };<br />
                    <br />
                    <i>// LoginButton.jsx</i><br />
                    const LoginButton = () => {<br />
                       
                    <i>// Унікальна логіка кнопки логіна</i
                    ><br />
                        return &#60;Button
                    variant="primary">Login&#60;/Button>;<br />
                    };<br />
                    <br />
                    <i>// FollowButton.jsx</i><br />
                    const FollowButton = () => {<br />
                       
                    <i
                      >// Унікальна логіка кнопки
                      підписки</i
                    ><br />
                        return &#60;Button
                    variant="secondary">Follow&#60;/Button>;<br />
                    };
                  </p>
                </div>
              </div>
            </section>

            <!-- CSS-модулі -->
            <section class="sub-section new-page">
              <h4 class="m-bottom-min">CSS-модулі</h4>
              <div class="m-bottom-min flex">
                <div>
                  <p class="m-bottom-min">
                    CSS-модулі - це не офіційна
                    специфікація, вони не імплементовані в
                    браузери. Це процес, що запускається на
                    стадії складання проекту, в результаті
                    виконання якого імена класів замінюються
                    на унікальні. Це дозволяє
                    використовувати одне і те ж ім'я класу в
                    різних CSS-файлах, не турбуючись про
                    конфлікти імен.
                  </p>
                  <p>
                    Vite за замовчуванням підтримує
                    CSS-модулі. Необхідно створbти файли
                    стилів з розширенням
                    <b>*.module.css</b>.
                  </p>
                </div>
                <div class="bcg-box">
                  <p>
                    <i
                      >/* src/components/Alert.module.css */ </i
                    ><br />
                    .alert {<br />
                        margin: 8px;<br />
                        padding: 12px 16px;<br />
                        border-radius: 4px;<br />
                        background-color: gray;<br />
                        color: white;<br />
                    }
                  </p>
                </div>
              </div>

              <div class="m-bottom-min flex">
                <div>
                  <p class="m-bottom-min">
                    <b>Імпорт CSS-модуля</b> нагадує імпорт
                    файлу JavaScript модуля. У CSS-модулі є
                    експорт за замовчуванням - об'єкт
                    відповідності оригінального та
                    згенерованих імен класів.
                  </p>
                  <p class="border-box">
                    <b>Важливо!</b> Селектори тегів за
                    замовчуванням будуть у глобальній
                    області видимості, CSS-модулі генерують
                    <b
                      >лише унікальні імена селекторів
                      класу</b
                    >.
                  </p>
                </div>
                <div class="bcg-box">
                  <p>
                    <i> // src/components/Alert.jsx </i
                    ><br />
                    <i>// Синтаксис імпорту CSS-модуля </i
                    ><br />
                    <b
                      >import css from
                      "./Alert.module.css"</b
                    >;<br />
                    <br />
                    <i
                      >// Отримуємо об'єкт відповідності
                      імен класів </i
                    ><br />
                    console.log(css); // { alert:
                    "Alert_alert_ax7yz" }<br />
                    <br />
                    const Alert = ({ children }) => {<br />
                        return &#60;p
                    className={<b>css.alert</b>}>{children}&#60;/p>;<br />
                    };
                  </p>
                </div>
              </div>

              <div class="m-bottom-min flex">
                <div>
                  <p class="m-bottom-min">
                    Композиція селекторів - це одна з
                    ключових можливостей CSS-модулів, яка
                    дозволяє створювати клас, наслідуючи
                    стилі іншого класу, але не дублюючи їх.
                  </p>
                  <p class="m-bottom-min border-box">
                    <b>Важливо!</b> Властивість
                    <b>composes</b> має передувати іншим
                    правилам, щоб можна було перевизначити
                    стилі.
                  </p>
                  <p class="m-bottom-min border-box">
                    <b>Важливо!</b> До властивостей об'єкта
                    зазвичай звертаються як
                    <b>css.alert</b>, але можна
                    використовувати квадратні дужки,
                    наприклад <b>css["alert"]</b>. Це
                    корисно у випадку коли ім'я властивості
                    зберігається у змінній, як у нас у
                    пропсі variant.
                  </p>
                  <p class="border-box">
                    <b>Важливо!</b> Імена класи, що
                    складаються з декількох слів записують у
                    <b>camelCase</b> нотації.
                  </p>
                </div>
                <div class="bcg-box">
                  <p>
                    <i>
                      /* src/components/Alert.module.css */ </i
                    ><br />
                    .alert {<br />
                        padding: 12px 16px;<br />
                        background-color: gray;<br />
                    }<br />
                    <br />
                    .success {<br />
                        composes: alert;<br />
                        background-color: green;<br />
                    }<br />
                    <br />
                    .error {<br />
                        composes: alert;<br />
                        background-color: red;<br />
                    }
                  </p>
                </div>
              </div>
            </section>

            <!-- Бібліотека React Icons -->
            <section class="sub-section">
              <h4 class="m-bottom-min">
                Бібліотека React Icons
              </h4>

              <div class="m-bottom-min flex">
                <p class="m-bottom-min">
                  React Icons
                  (<i>https://react-icons.github.io/react-icons/</i>)
                  - це набір іконок, спеціально створений
                  для використання в React-додатках.
                </p>
                <div class="bcg-box">
                  <p>npm install react-icons</p>
                </div>
              </div>

              <div class="m-bottom-min flex">
                <p class="m-bottom-min">
                  Бібліотеку необхідно імпортувати у
                  компонент, та підставити назву подтрібної
                  іконки у код
                </p>
                <div class="bcg-box">
                  <p>
                    <b
                      >import { HiUser } from
                      "react-icons/hi"; </b
                    ><br />
                    <br />
                    const UserMenu = ({ name }) => {<br />
                        return &#60;p>
                    <b>&#60;HiUser /></b>
                    {name}&#60;/p><br />
                    };
                  </p>
                </div>
              </div>

              <div class="flex">
                <div>
                  <p class="m-bottom-min">
                    Можна налаштувати зовнішній вигляд
                    іконок, використовуючи стилі React,
                    передаючи власні класи або інші
                    параметри.
                  </p>
                  <ul>
                    <li>
                      колір іконки вказується в додатковому
                      класі CSS-властивістю
                      <b>color</b>;
                    </li>
                    <li>
                      розмір іконки визначається числом в
                      атрибуті
                      <b>size</b>, це кількість пікселів (за
                      замовчуванням - <b>16px</b>).
                    </li>
                  </ul>
                </div>
                <div class="bcg-box">
                  <p>
                    <b
                      >import { HiUser } from
                      "react-icons/hi"; </b
                    ><br />
                    <br />
                    const UserMenu = ({ name }) => {<br />
                        return <br />
                            &#60;p><br />
                                &#60;HiUser
                    <b>className="my-icon" size="24"</b>
                    /> {name}<br />
                            &#60;/p><br />
                    };
                  </p>
                </div>
              </div>
            </section>
          </section>
        </div>
      </section>

      <!-- Обробка подій -->
      <section id="events" class="main-section">
        <div class="container">
          <h2 class="m-bottom center-text">
            Обробка подій
          </h2>

          <!-- Загальне -->
          <section class="section">
            <h3 class="m-bottom-min">Загальне</h3>

            <div class="m-bottom-min flex">
              <div>
                <p class="m-bottom-min">
                  <b>Обробники подій</b> - це власні
                  функції, які будуть викликані відповідно
                  до взаємодій, таких як клікання,
                  наведення, фокусування на полях введення
                  форм і таке інше.
                </p>
                <p>
                  Щоб додати обробник подій до JSX-елементу,
                  потрібно передати йому проп, який описує
                  тип події. Значенням пропа повинно бути
                  посилання на функцію зворотного виклику,
                  яка буде викликана при настанні події. Для
                  цього необхідно:
                </p>
                <ul>
                  <li>
                    об'явити функцію всередині компонента
                    (<b>handleClick</b>);
                  </li>
                  <li>
                    задати в середині функції логіку
                    (<b>alert</b>);
                  </li>
                  <li>
                    додати пропс до JSX-коду
                    (<b>onClick={handleClick}</b>).
                  </li>
                </ul>
              </div>

              <div class="bcg-box">
                <p>
                  const App = () => {<br />
                      const <b>handleClick</b> = () => {<br />
                          <b>alert</b>("I'm a button!");<br />
                      };<br />
                  <br />
                      return (<br />
                          &#60;button
                  <b>onClick={handleClick}</b>><br />
                              Click me!<br />
                          &#60;/button>;<br />
                      )<br />
                  };
                </p>
              </div>
            </div>

            <div class="m-bottom-min">
              <p>Основні моменти:</p>
              <ul>
                <li>
                  <i>пропи</i> подій визначаються в React та
                  мають ім'я в стилі <b>camelCase</b>,
                  починаючи з префікса <b>on</b>, після чого
                  йде назва події (<b
                    >onClick, onSubmit, onChange</b
                  >);
                </li>
                <li>
                  <i>функції обробників подій</i>
                  визначаються всередині компонентів
                  (<b>handleClick</b>);
                </li>
                <li>
                  за конвенцією ім'я обробника подій
                  починається з
                  <b>handle</b>,
                  <i>за яким слідує назва події</i>
                  (<b>onClick={handleClick}</b>).
                </li>
              </ul>
            </div>

            <div class="flex">
              <div>
                <p class="m-bottom-min">
                  Можна визначити обробник подій
                  безпосередньо всередині JSX як анонімну
                  інлайн-функцію.
                </p>
                <p class="border-box">
                  <b>Важливо!</b> Встроєні обробники подій
                  зручні для коротких функцій. Але великі
                  інлайн-функції в JSX можуть ускладнити
                  читабельність розмітки компонента.
                </p>
              </div>

              <div class="bcg-box">
                <p>
                  const App = () => {<br />
                      return (<br />
                              &#60;button onClick={<b
                    >() => alert("I'm a button!")</b
                  >} ><br />
                                  Click me!<br />
                              &#60;/button>;<br />
                      ) <br />
                  };
                </p>
              </div>
            </div>
          </section>

          <!-- Посилання на функцію -->
          <section class="section">
            <h3 class="m-bottom-min">
              Посилання на функцію
            </h3>

            <p class="m-bottom-min">
              Функції, які передаються обробникам подій,
              повинні бути передані як посилання, а не
              викликані.
            </p>

            <div class="flex">
              <div>
                <p class="m-bottom-min">
                  У <i>першому</i> прикладі функція
                  <b>handleClick</b> передається як обробник
                  подій <b>onClick</b>. Це говорить React
                  запам'ятати її і викликати лише тоді, коли
                  користувач клікає кнопку.
                </p>
                <p class="m-bottom-min">
                  У другому прикладі <b>дужки ()</b> в кінці
                  <b>handleClick()</b>
                  викликає функцію безпосередньо під час
                  рендерингу, не дочекавшись події кліку.
                </p>
              </div>

              <div class="bcg-box">
                <p>
                  <i>// ✅ Передача функції (правильно)</i
                  ><br />
                  &#60;button onClick={<b>handleClick</b>}>
                  <br />
                  <br />
                  <i>// ❌ Виклик функції (неправильно)</i
                  ><br />
                  &#60;button
                  onClick={<b>handleClick()</b>}>
                </p>
              </div>
            </div>
          </section>

          <!-- Об'єкт події -->
          <section class="section">
            <h3 class="m-bottom-min">Об'єкт події</h3>

            <div class="flex">
              <div>
                <p class="m-bottom-min">
                  Callback-функція, яка передається як
                  обробник події, незалежно від її типу,
                  гарантовано отримає один аргумент -
                  <b>об'єкт події</b> браузера.
                </p>
                <p class="border-box">
                  <b>Цікаво!</b> Для подій браузера у React
                  створюється об'єкт-обгортка
                  <b>SyntheticEvent</b>, призначення якоі
                  полягає в уникненні проблем, пов'язаних з
                  кросбраузерністю. З точки зору розробника,
                  використання SyntheticEvent не
                  відрізняється від роботи з нативними
                  подіями.
                </p>
              </div>

              <div class="bcg-box">
                <p>
                  const App = () => {<br />
                      const
                  <b
                    >handleClick = evt =>
                    console.log(evt)</b
                  >;<br />
                  <br />
                      return (<br />
                          &#60;><br />
                              &#60;button
                  <b>onClick={handleClick}</b>>First
                  button&#60;/button><br />
                              &#60;button
                  <b>onClick={evt => console.log(evt)}</b
                  >><br />
                                  Second button<br />
                              &#60;/button><br />
                          &#60;/><br />
                      );<br />
                  };
                </p>
              </div>
            </div>
          </section>

          <!-- Читання props -->
          <section class="section new-page">
            <h3 class="m-bottom-min">Читання props</h3>

            <div class="flex">
              <p class="m-bottom-min">
                Обробники подій оголошуються всередині
                компонента, отже, вони
                <b>мають доступ до пропсів компонента</b>.
              </p>
              <div class="bcg-box">
                <p>
                  const Button = ({ <b>message</b>, children
                  }) => {<br />
                      return (<br />
                          &#60;button onClick={() =>
                  alert(<b>message</b>)}> {children}
                  &#60;/button><br />
                      );<br />
                  };<br />
                  <br />
                  const App = () => {<br />
                      return (<br />
                          &#60;><br />
                              &#60;Button
                  <b>message="Playing music!"</b>> Play
                  music &#60;/Button><br />
                          &#60;/><br />
                      );<br />
                  }
                </p>
              </div>
            </div>
          </section>

          <!-- Стан компонента -->
          <section class="section">
            <h3 class="m-bottom-min">Стан компонента</h3>

            <p class="m-bottom-min">
              Компонентам потрібно змінювати те, що
              відображається на екрані внаслідок взаємодії з
              користувачем (введення даних в форму повинно
              оновлювати поле вводу, клікання в слайдері
              зображень).
            </p>

            <p class="m-bottom-min">
              <b>Стан (state)</b> - вид пам'яті, що
              специфічний для компонента.
            </p>

            <p class="m-bottom-min">
              <b>Пропси (props)</b> - це дані, які
              передаються компоненту ззовні, а
              <b>стан (state)</b> - це його внутрішні
              динамічні дані.
            </p>

            <p class="m-bottom-min">
              Коли стан або пропси компонента змінюються,
              відбувається оновлення та повторний рендер
              JSX. Іншими словами, стан - це реактивні дані,
              які контролюють те, що відображається в
              інтерфейсі.
            </p>

            <p class="m-bottom-min">
              Зміна стану компонента ніколи не впливає на
              його батьків чи сусідів, а тільки на його
              дочірні елементи.
            </p>

            <p>Отже:</p>
            <ul class="m-bottom-min">
              <li>
                у стані зберігається мінімально необхідний
                набір даних, на основі яких можна обчислити
                все необхідне для рендеру інтерфейсу;
              </li>
              <li>
                у стані може зберігатися будь-який тип
                даних;
              </li>
              <li>
                стан може змінюватися відповідно до дій
                користувача;
              </li>
              <li>
                під час зміни стану компонент повертає
                оновлену розмітку і змінює інтерфейс.
              </li>
            </ul>

            <div class="m-bottom-min border-box">
              <p><b>Важливо!</b></p>
              <ul class="m-bottom-min">
                <li>
                  Локальні змінні не зберігаються між
                  рендерами. Коли React рендерить компонент
                  вдруге, він рендерить його з нуля — не
                  враховує жодних змін у локальних змінних.
                </li>
                <li>
                  Зміни локальних змінних не викликають
                  повторних рендерів. React не усвідомлює
                  необхідності повторного рендерингу
                  компонента з новими даними.
                </li>
              </ul>
              <p>
                Для оновлення компонента новими даними
                потрібно:
              </p>
              <ul>
                <li>зберегти дані між рендерами;</li>
                <li>
                  заставити React рендерити компонент з
                  новими даними (повторний рендеринг).
                </li>
              </ul>
            </div>

            <p>
              Станом компонента можна керувати за допомогою
              <b>хука</b> <b>useState</b>.
            </p>
          </section>
        </div>
      </section>

      <!-- Життєвий цикл -->
      <section id="life-cycle" class="main-section">
        <div class="container">
          <h2 class="m-bottom center-text">
            Життєвий цикл компонента
          </h2>

          <!-- Життєвий цикл -->
          <section class="section">
            <h3 class="m-bottom-min">Життєвий цикл</h3>
            <p class="m-bottom-min">
              Життєвий цикл компонентів складається з
              кількох етапів -
              <b>монтування, оновлення та розмонтування</b>.
            </p>

            <p>Приклад, компонент модального вікна.</p>
            <ul class="m-bottom-min">
              <li>
                <b>Монтування</b> - момент, коли компонент
                вперше з'являється на екрані. Іншими
                словами, модальне вікно відкривається, і
                його HTML поміщається в DOM.
              </li>
              <li>
                <b>Оновлення</b> викликається зміною стану
                <i>state</i> самого компонента або
                <i>props</i>, які йому передаються.
              </li>
              <li>
                <b>Розмонтування</b> - відбувається при
                закритті модального вікна - його HTML
                видаляється з DOM.
              </li>
            </ul>

            <p class="m-bottom-min">
              За допомогою <b>ефектів</b> можна виконувати
              код тільки тоді, коли це необхідно, тобто не
              кожен раз, коли компонент рендериться.
            </p>

            <p>
              Життєвий цикл компоненту керується за
              допомогою
              <b>хуку useEffect</b>
            </p>
          </section>

          <!-- Робота з LocalStorage -->
          <section class="section">
            <h3 class="m-bottom-min">
              Робота з LocalStorage
            </h3>

            <!-- Запис -->
            <section class="section">
              <h4 class="m-bottom-min">Запис</h4>

              <div class="m-bottom flex">
                <div>
                  <p class="m-bottom-min">
                    У ефект необхідно додати код запису в
                    локальне сховище. Ключ - це довільний
                    рядок, а значення - це стан.
                  </p>
                  <div class="border-box">
                    <p class="m-bottom-min">
                      <b>Важливо!</b> Якщо необхідно додати
                      складні типі даних, такі як об'єкт чи
                      масив, треба перетворити збережене
                      значення у рядок за допомогою
                      <b>JSON.stringify</b>.
                    </p>
                    <div class="bcg-box">
                      <p>
                        window.localStorage.setItem("key",
                        JSON.stringify({}));
                      </p>
                    </div>
                  </div>
                </div>

                <div class="bcg-box">
                  <p>
                    const App = () => {<br />
                        const [clicks, setClicks] =
                    useState(0);<br />
                    <br />
                        useEffect(() => {<br />
                           
                    <b
                      >window.localStorage.setItem("saved-clicks",
                      clicks)</b
                    >;<br />
                        }, [clicks]);<br />
                    <br />
                        return (<br />
                            &#60;div><br />
                                &#60;button onClick={() =>
                    setClicks(clicks + 1)}><br />
                                    You clicked {clicks}
                    times<br />
                                &#60;/button><br />
                                &#60;button onClick={() =>
                    setClicks(0)}>Reset&#60;/button><br />
                            &#60;/div><br />
                        );<br />
                    };
                  </p>
                </div>
              </div>
            </section>

            <!-- Читання -->
            <section class="section">
              <h4 class="m-bottom-min">Читання</h4>
              <div class="m-bottom-min flex">
                <p>
                  <b>Ефекти</b> виконуються
                  <b>асинхронно</b>,
                  <i>після монтування компонента</i>. Щоб
                  <i>синхронно</i> прочитати значення з
                  локального сховища, ще до монтування, в
                  хук <b>useState</b> необхідно передати
                  початкове значення стану. Замість
                  початкового значення треба передати
                  <b>посилання на функцію</b>, яка повертає
                  початкове значення.
                </p>
                <div>
                  <p class="bcg-box">
                    const [] = useState(() => {<br />
                        return 0;<br />
                    });
                  </p>
                </div>
              </div>

              <div class="m-bottom-min flex">
                <div class="bcg-box print-m-left-none">
                  <p>
                    const [clicks, setClicks] = useState(()
                    => {<br />
                       
                    <i>// Зчитуємо значення за ключем</i
                    ><br />
                        const savedClicks =
                    window.localStorage.getItem(<br />
                            "saved-clicks"<br />
                        );<br />
                    <br />
                       
                    <i>// Якщо там щось є, повертаємо це</i>
                    <br />
                       
                    <i
                      >// значення як початкове значення
                      стану</i
                    ><br />
                        if (savedClicks !== null) {<br />
                            return savedClicks;<br />
                        }<br />
                    <br />
                       
                    <i
                      >// У протилежному випадку
                      повертаємо</i
                    >
                    <br />
                       
                    <i
                      >// яке-небудь значення за
                      замовчуванням</i
                    ><br />
                        return 0;<br />
                    });<br />
                  </p>
                </div>

                <p>або</p>

                <div class="bcg-box print-m-left-none">
                  <p>
                    const [obj, setObj] = useState(() =>
                    {<br />
                       
                    <i>// Зчитуємо значення за ключем</i
                    ><br />
                        const savedObject =
                    window.localStorage.getItem("key");<br />
                    <br />
                       
                    <i
                      >// Якщо там щось є, парсимо і
                      повертаємо</i
                    ><br />
                       
                    <i
                      >// це значення як початкове значення
                      стану</i
                    ><br />
                        if (savedObject !== null) {<br />
                            return
                    JSON.parse(savedObject);<br />
                        }<br />
                    <br />
                       
                    <i
                      >// У протилежному випадку
                      повертаємо</i
                    ><br />
                       
                    <i
                      >// яке-небудь значення за
                      замовчуванням</i
                    ><br />
                        return {};<br />
                    });<br />
                  </p>
                </div>
              </div>

              <div class="m-bottom-min new-page">
                <div class="border-box flex">
                  <p>
                    <b>Важливо!</b> Якщо необхідно отримати
                    складні типи даних, такі як об'єкт чи
                    масив, треба зробити розбір значення за
                    допомогою <b>JSON.parse</b>. В іншому
                    випадку, замість об'єкта чи масиву до
                    стану запишуться їх стрічне
                    представлення.
                  </p>

                  <div>
                    <p class="bcg-box">
                      <b>JSON.parse(savedObject)</b>
                    </p>
                  </div>
                </div>
              </div>

              <p class="m-bottom-min">
                Повний код прикладу
              </p>

              <div class="bcg-box">
                <p>
                  const App = () => {<br />
                     
                  <b
                    >const [clicks, setClicks] = useState(()
                    => {<br />
                            const savedClicks =
                    window.localStorage.getItem("saved-clicks");<br />
                            if (savedClicks !== null) {<br />
                                return savedClicks;<br />
                            }<br />
                            return 0;<br />
                        })</b
                  >;<br />
                  <br />
                     
                  <b
                    >useEffect(() => {<br />
                           
                    window.localStorage.setItem("saved-clicks",
                    clicks);<br />
                        }, [clicks])</b
                  >;<br />
                  <br />
                      return (<br />
                          &#60;div><br />
                              &#60;button onClick={() =>
                  setClicks(clicks + 1)}> You clicked
                  {clicks} times &#60;/button><br />
                              &#60;button onClick={() =>
                  setClicks(0)}>Reset&#60;/button><br />
                          &#60;/div><br />
                      );<br />
                  };
                </p>
              </div>
            </section>
          </section>
        </div>
      </section>

      <!-- Форми -->
      <section id="forms" class="main-section">
        <div class="container">
          <h2 class="m-bottom center-text">Форми</h2>

          <!-- Загальне -->
          <section class="section">
            <h3 class="m-bottom-min">Загальне</h3>

            <div class="m-bottom flex">
              <div>
                <p class="m-bottom-min">
                  Для обробки відправки форми, елементу
                  форми передається колбек-функція в пропс
                  <b>onSubmit</b>.
                </p>
                <p>
                  Колбек-функція отримає єдиний аргумент -
                  об'єкт події відправки форми.
                  Використовуючи його, ми завдаємо
                  запобігання типової поведінці HTML-форми
                  за допомогою методу
                  <b>preventDefault</b>.
                </p>
              </div>
              <div class="bcg-box">
                <p>
                  const LoginForm = () => {<br />
                     
                  <b
                    >const handleSubmit = (evt) => {<br />
                            evt.preventDefault();<br />
                            console.log(evt);<br />
                        };</b
                  ><br />
                  <br />
                      return (<br />
                          &#60;form
                  <b>onSubmit={handleSubmit}</b>><br />
                              &#60;input type="text"
                  name="login" /><br />
                              &#60;input type="password"
                  name="password" /><br />
                              &#60;button
                  type="submit">Login&#60;/button><br />
                          &#60;/form><br />
                      );<br />
                  };
                </p>
              </div>
            </div>
          </section>

          <!-- Неконтрольована форма -->
          <section class="section">
            <h3 class="m-bottom-min">
              Неконтрольована форма
            </h3>

            <div class="m-bottom flex">
              <div>
                <p class="m-bottom-min">
                  Якщо значення полів форми потрібні лише в
                  момент її відправки, то така форма
                  називається
                  <b>неконтрольованою</b>.
                </p>
                <p>
                  Доступ до значень елементів отримуємо
                  через властивість <b>elements</b>, яка
                  <i
                    >зберігає посилання на інтерактивні
                    елементи форми</i
                  >:
                </p>
                <ul>
                  <li>
                    властивість <b>elements</b> зберігає
                    об'єкт із властивостями, імена яких
                    збігаються зі значеннями
                    <i>атрибутів <b>name</b></i> елементів
                    форми,
                  </li>
                  <li>
                    значенням кожної властивості буде
                    <i>посилання на DOM-елемент поля</i>,
                  </li>
                  <li>
                    щоб отримати доступ до значень полів,
                    звертаємося до властивості
                    <b>value</b>,
                  </li>
                  <li>
                    щоб
                    <i>скинути значення полів форми</i> в
                    початкові, використовується вбудований
                    DOM-метод
                    <b>reset</b>
                    елемента form.
                  </li>
                </ul>
              </div>
              <div class="bcg-box">
                <p>
                  const LoginForm = () => {<br />
                      const handleSubmit = (evt) => {<br />
                          evt.preventDefault();<br />
                         
                  <b>const form = evt.target</b>;<br />
                         
                  <b
                    >const { login, password } =
                    form.elements</b
                  >;<br />
                  <br />
                         
                  <i>// Посилання на DOM-елементи</i><br />
                          console.log(<b>login, password</b>
                  );<br />
                          <i>// Значення полів</i><br />
                          console.log(<b
                    >login.value, password.value</b
                  >)<br />
                         
                  <i
                    >// Скидаємо значення полів після
                    відправки</i
                  ><br />
                          <b>form.reset()</b>;<br />
                      };<br />
                  <br />
                      return (<br />
                          &#60;form
                  onSubmit={handleSubmit}><br />
                              &#60;input type="text"
                  <b>name</b>="login" /><br />
                              &#60;input type="password"
                  <b>name</b>="password" /><br />
                              &#60;button
                  type="submit">Login&#60;/button><br />
                          &#60;/form><br />
                      );<br />
                  };
                </p>
              </div>
            </div>

            <!-- Використання форми -->
            <section class="sub-section">
              <h4 class="m-bottom-min">
                Використання форми
              </h4>

              <div class="flex">
                <div>
                  <p class="m-bottom-min">
                    На практиці <b>форма</b> це окремий
                    компонент, який в більшості випадків
                    повинен турбуватися тільки про
                    <i>збір значень своїх полів</i>. Те, що
                    з цими значеннями потрібно зробити,
                    передається формі у вигляді
                    <i
                      >пропса від батьківського
                      компонента</i
                    >, де форма рендериться.
                  </p>
                  <p class="m-bottom-min">
                    Використовуємо
                    <i>форму в компоненті</i> <b>App</b> і
                    передаємо їй <i>пропс</i>
                    <b>onLogin</b>, значенням якого буде
                    колбек-функція, що приймає один параметр
                    - об'єкт даних користувача.
                  </p>
                  <p>
                    У компоненті форми деструктуризуємо
                    пропс onLogin, це функція, тому
                    викликаємо її при сабміті форми і
                    передаємо їй значення полів.
                  </p>
                </div>
                <div class="bcg-box">
                  <p>
                    const App = () => {<br />
                    <br />
                       
                    <i
                      >// Колбек-функція для обробки сабміту
                      форми</i
                    ><br />
                       
                    <b
                      >const handleLogin = (userData) =>
                      {</b
                    ><br />
                           
                    <i
                      >// Виконуємо необхідні операції з
                      даними</i
                    ><br />
                           
                    <b>console.log(userData)</b>;<br />
                        };<br />
                        return (<br />
                           
                    <i
                      >// Передаємо колбек як пропс форми</i
                    >
                    <br />
                            &#60;LoginForm
                    <b>onLogin={handleLogin}</b> /><br />

                        );<br />
                    };<br />
                  </p>
                </div>
              </div>

              <div class="flex new-page">
                <p class="border-box">
                  <b>Уважно!</b> Зверніть увагу на те, що в
                  пропс onLogin ми передаємо дані полів
                  форми, а не об'єкт події. Об'єкт події
                  використовується лише всередині форми для
                  скасування типової поведінки і роботи з її
                  елементами. Передавати об'єкт події в
                  пропс - це антипаттерн.
                </p>
                <div class="bcg-box">
                  <p>
                    <i>// ...продовження...</i><br />
                    const LoginForm = ({ <b>onLogin</b> })
                    => {<br />
                       
                    <b>const handleSubmit = (evt) => {</b
                    ><br />
                            <b>evt.preventDefault();</b
                    ><br />
                            <b>const form = evt.target;</b
                    ><br />
                           
                    <b
                      >const { login, password } =
                      form.elements;</b
                    ><br />
                            <br />
                           
                    <i>// Викликаємо пропс onLogin</i><br />
                            onLogin({<br />
                               
                    <b
                      >login: login.value,<br />
                                  password:
                      password.value,<br />
                              });</b
                    ><br />
                            <br />
                            form.reset();<br />
                        };<br />
                        return (<br />
                            &#60;form
                    <b>onSubmit={handleSubmit}</b>><br />
                                &#60;input type="text"
                    name="login" /><br />
                                &#60;input type="password"
                    name="password" /><br />
                                &#60;button
                    type="submit">Login&#60;/button><br />
                            &#60;/form><br />
                        );<br />
                    };
                  </p>
                </div>
              </div>
            </section>

            <!-- Контрольовані елементи -->
            <section class="sub-section">
              <h4 class="m-bottom-min">
                Контрольовані елементи
              </h4>

              <div class="flex">
                <div>
                  <p class="m-bottom-min">
                    Якщо значення елементів форми потрібно
                    отримати кожен раз у момент зміни поля і
                    зробити щось динамічно, вони мають бути
                    <b>контрольовані</b>. Значення таких
                    полів
                    <i>зберігаються в стані компонента</i>.
                  </p>
                  <p class="m-bottom-min">
                    <b>Приклад.</b>
                    <i
                      >компонент
                      <b>SearchBar</b> складається з
                      текстового поля. При введенні тексту в
                      поле необхідно відобразити це значення
                      в абзаці.</i
                    >
                  </p>
                  <p class="border-box m-bottom-min">
                    <b>Важливо!</b> Контрольовані елементи
                    використовуються не тільки як частина
                    форми, але і без неї. Наприклад, для
                    створення полів пошуку, фільтрів та
                    інших динамічних елементів інтерфейсу.
                    Елементи всередині однієї форми повинні
                    бути або всі контрольовані, або всі
                    неконтрольовані, перемішувати їх не
                    можна.
                  </p>
                  <p class="border-box">
                    <b>Важливо!</b> Для
                    <i>контрольованого</i> елемента форми
                    обовзяково необхідно передавати атрибути
                    <b>value</b> і <b>onChange</b>.
                  </p>
                </div>
                <div class="bcg-box">
                  <p>
                    const SearchBar = () => {<br />
                       
                    <b
                      >const [inputValue, setInputValue] =
                      useState("");</b
                    ><br />
                        <br />
                       
                    <b
                      >const handleChange = (evt) => {<br />
                             
                      setInputValue(evt.target.value);<br />
                          };</b
                    ><br />
                        <br />
                        return (<br />
                            &#60;div><br />
                                &#60;input<br />
                                    type="text"<br />
                                   
                    <b>value={inputValue}</b><br />
                                   
                    <b>onChange={handleChange}</b><br />
                                /><br />
                               
                    &#60;p>{<b>inputValue</b>}&#60;/p><br />
                            &#60;/div><br />
                        );<br />
                    };
                  </p>
                </div>
              </div>
            </section>

            <!-- Елемент select -->
            <section class="sub-section">
              <h4 class="m-bottom-min">Елемент select</h4>

              <p class="m-bottom-min">
                Селект складається з самого елемента
                <b>select</b> та вкладеного набору
                <b>option</b>, у яких необхідно вказати
                атрибут <b>value</b>.
              </p>

              <p>
                Якщо селект використовується поза формою, то
                ми працюємо з ним як з
                <b>контрольованим елементом</b>:
              </p>

              <ul class="m-bottom-min">
                <li>
                  зберігаємо поточне значення в стані;
                </li>
                <li>
                  передаємо значення стану як атрибут value;
                </li>
                <li>змінюємо стан при події onChange.</li>
              </ul>

              <p class="border-box m-bottom-min">
                <b>Важливо!</b> Якщо селект є частиною
                <b>неконтрольованої форми</b>, то спочатку
                ми задаємо йому атрибут <b>name</b>, а потім
                отримуємо значення селекта
                <i>під час сабміту форми</i> через її
                властивість
                <b
                  >evt.target.elements.<i>selectName</i>.value</b
                >, де <b><i>selectName</i></b> - це значення
                атрибута <i>name</i>.
              </p>

              <div class="flex new-page">
                <div class="bcg-box print-m-left-none">
                  <p>
                    const LangSwitcher = () => {<br />
                        const <i>selectId</i> = useId();<br />
                       
                    <b
                      >const [lang, setLang] =
                      useState("uk")</b
                    >;<br />
                    <br />
                        return (<br />
                            &#60;div><br />
                                &#60;label
                    htmlFor={<i>selectId</i>}>Choose
                    language&#60;/label><br />
                                &#60;select<br />
                                    id={<i>selectId</i>}<br />
                                    <b>value={lang}</b
                    ><br />
                                   
                    <b
                      >onChange={(evt) =>
                      setLang(evt.target.value)}</b
                    ><br />
                                ><br />
                                    &#60;option
                    <b>value</b
                    >="uk">Ukrainian&#60;/option><br />
                                    &#60;option
                    <b>value</b
                    >="en">English&#60;/option><br />
                                &#60;/select><br />
                            &#60;/div><br />
                        );<br />
                    };
                  </p>
                </div>
                <div class="bcg-box">
                  <p>
                    const App = () => {<br />
                        const [<b>lang</b>,
                    <b>setLang</b>] = useState("uk");<br />
                        <br />
                        return (<br />
                            &#60;><br />
                                &#60;p>Selected language:
                    {<b>lang</b>}&#60;/p><br />
                                &#60;LangSwitcher
                    <b><i>value</i></b
                    >={<b>lang</b>} <b><i>onSelect</i></b
                    >={<b>setLang</b>} /><br />
                            &#60;/><br />
                        );<br />
                    };<br />
                    <br />
                    const LangSwitcher = ({
                    <b><i>value</i></b
                    >, <b><i>onSelect</i></b> }) => {<br />
                        const selectId = useId();<br />
                        <br />
                        return (<br />
                            &#60;div><br />
                                &#60;label
                    htmlFor={selectId}>Choose
                    language&#60;/label><br />
                                &#60;select <br />
                                    id={selectId}<br />
                                    value={<b
                      ><i>value</i></b
                    >}<br />
                                    onChange={(evt) =>
                    <b><i>onSelect</i></b
                    >(evt.target.value)} ><br />
                                    &#60;option
                    value="uk">Ukrainian&#60;/option><br />
                                    &#60;option
                    value="en">English&#60;/option><br />
                                &#60;/select><br />
                            &#60;/div><br />
                        );<br />
                    };
                  </p>
                </div>
              </div>
            </section>

            <!-- Радіо-кнопки -->
            <section class="sub-section">
              <h4 class="m-bottom-min">Радіо-кнопки</h4>

              <div class="flex">
                <div>
                  <p>
                    <b>Радіо-кнопки</b> є альтернативою
                    <i>select</i>, оскільки в групі може
                    бути обрано <i>лише один варіант</i>.
                    Головне:
                  </p>
                  <ul class="m-bottom-min">
                    <li>
                      групування радіо-кнопок відбувається
                      за допомогою однакового значення
                      атрибута
                      <b>name</b>;
                    </li>
                    <li>
                      значення кожної опції зберігається у
                      атрибуті
                      <b>value</b>.
                    </li>
                    <li>
                      обране значення
                      <i>зберігається</i> в <b>стані</b>.
                    </li>
                  </ul>
                  <p class="border-box">
                    <b>Важливо!</b> Для визначення, чи
                    обрано опцію чи ні, атрибуту
                    <b>checked</b> необхідно передати
                    <b>true</b> чи <b>false</b> (атрибуту
                    <b>checked</b> передається
                    <i
                      >результат порівняння стану і значення
                      атрибута value</i
                    >
                    конкретної радіо-кнопки).
                  </p>
                </div>
                <div class="bcg-box">
                  <p>
                    const App = () => {<br />
                        const [<b>coffeeSize</b>,
                    <b>setCoffeeSize</b>] =
                    useState("sm");<br />
                        const <b>handleSizeChange</b> =
                    (evt) => {<br />
                           
                    <b>setCoffeeSize</b
                    >(evt.target.value);<br />
                        };<br />
                        return (<br />
                            &#60;><br />
                                &#60;h2>Select coffee
                    size&#60;/h2><br />
                                &#60;label><br />
                                    &#60;input<br />
                                        type="radio"<br />
                                       
                    <b>name="coffeeSize"</b><br />
                                        <b>value="sm"</b
                    ><br />
                                       
                    <b>checked={coffeeSize === "sm"}</b
                    ><br />
                                       
                    <b>onChange={handleSizeChange}</b><br />
                                    /><br />
                                    Small<br />
                                &#60;/label><br />
                                &#60;label><br />
                                    &#60;input<br />
                                        type="radio"<br />
                                       
                    <b>name="coffeeSize"</b><br />
                                        <b>value="md"</b
                    ><br />
                                       
                    <b>checked={coffeeSize === "md"}</b
                    ><br />
                                       
                    <b>onChange={handleSizeChange}</b><br />
                                    /><br />
                                    Meduim<br />
                                &#60;/label><br />
                            &#60;/><br />
                        );<br />
                    };<br />
                  </p>
                </div>
              </div>
            </section>

            <!-- Чекбокси -->
            <section class="sub-section new-page">
              <h4 class="m-bottom-min">Чекбокси</h4>

              <div class="flex">
                <div>
                  <p class="m-bottom-min">
                    <b>Чекбокси</b>,на відміну від
                    радіо-кнопок, дозволяють
                    <b>обрати багато з багатьох</b>.
                    Чекбокс, так само, як і радіо-кнопка,
                    може знаходитися в двох станах: обраний
                    або ні.
                  </p>

                  <p class="border-box m-bottom-min">
                    <b>Важливо!</b> При роботі з
                    <i>групою чекбоксів</i> їх значення
                    зберігаються в властивості <b>value</b>,
                    як і в разі з радіо-кнопками, а
                    <b
                      >обрані значення зберігаються в стані
                      як масив чи об'єкт</b
                    >. Це потрібно в більш складних формах.
                  </p>

                  <p>
                    <b>Приклад</b>. Кнопка має бути активною
                    лише тоді, коли чекбокс обраний, і
                    користувач не зможе пройти далі, не
                    прийнявши умови використання.
                  </p>
                </div>
                <div class="bcg-box">
                  <p>
                    const App = () => {<br />
                        const
                    <b
                      >[hasAccepted, setHasAccepted] =
                      useState(false)</b
                    >;<br />
                        const <b>handleChange</b> = (evt) =>
                    {<br />
                            <b>setHasAccepted</b>(<evt
                      class="target b"
                      >checked</evt
                    >);<br />
                        };<br />
                        return (<br />
                            &#60;div><br />
                                &#60;label><br />
                                    &#60;input<br />
                                        type="checkbox"<br />
                                        name="terms"<br />
                                       
                    <b>checked={hasAccepted}</b><br />
                                       
                    <b>onChange={handleChange}</b><br />
                                    /><br />
                                    I accept terms and
                    conditions<br />
                                &#60;/label><br />
                                &#60;button type="button"
                    disabled={<b>hasAccepted</b>}><br />
                                        Proceed<br />
                                &#60;/button><br />
                            &#60;/div><br />
                        );<br />
                    };
                  </p>
                </div>
              </div>
            </section>
          </section>

          <!-- Контрольована форма -->
          <section class="section">
            <!-- Контрольована форма -->
            <h3 class="m-bottom-min">
              Контрольована форма
            </h3>

            <div class="m-bottom flex">
              <div>
                <p class="m-bottom-min">
                  Якщо значення полів форми є не лише
                  необхідними у момент її відправлення, а й
                  <i>кожного разу при зміні значень</i>,
                  наприклад, для додавання валідації полів,
                  то таку форму називають
                  <b>контрольованою</b>.
                </p>
                <p class="m-bottom-min">
                  Дані всіх елементів контрольованої форми
                  зберігаються у стані та передаються як
                  значення їх атрибута <b>value</b>.
                </p>
                <p class="m-bottom-min border-box">
                  <b>Цікаво!</b> імена властивостей об'єкта
                  стану (<b>login</b> та <b>password</b>)
                  збігаються зі значеннями атрибутів name
                  елементів форми. Це використається пізніше
                  для оптимізації обробки значень.
                </p>
                <div class="border-box m-bottom-min">
                  <p>
                    <b>Цікаво!</b> Якщо уважно погляднути на
                    функції оновлення стану, можна помітити,
                    що вони практично ідентичні:
                  </p>
                  <ul class="m-bottom-min">
                    <li>отримують <i>об'єкт події</i>;</li>
                    <li>
                      викликають функцію зміни стану
                      <b>setValues</b>;
                    </li>
                    <li>
                      використовують
                      <b>evt.target.value</b>, щоб отримати
                      значення поля;
                    </li>
                    <li>
                      різниця лише в
                      <i>властивості об'єкта</i>, яка
                      оновлюється.
                    </li>
                  </ul>
                  <p>Їх можна замінити на:</p>
                  <div class="bcg-box">
                    <p>
                      const handleChange = (evt) => {<br />
                          setValues({<br />
                              ...values,<br />
                              [evt.target.name]:
                      evt.target.value,<br />
                          });<br />
                      };
                    </p>
                  </div>
                </div>
                <p class="border-box">
                  <b>Важливо!</b> Складні контрольовані
                  форми, особливо з валідацією, зазвичай
                  створюються не вручну, а за допомогою
                  бібліотек.
                </p>
              </div>

              <div class="bcg-box print-fs-10">
                <p>
                  const LoginForm = () => {<br />
                      const [<b>values, setValues</b>] =
                  useState({<br />
                          <b><i>login</i></b
                  >: "",<br />
                          <b><i>password</i></b
                  >: "",<br />
                      });<br />
                      <br />
                      const <b>handleLoginChange</b> = (evt)
                  => {<br />
                          <b>setValues</b>({<br />
                              ...<b>values</b>,<br />
                              <b><i>login</i></b
                  >: evt.target.<b>value</b>,<br />
                          });<br />
                      };<br />
                      <br />
                      const handlePwdChange = (evt) => {<br />
                          <b>setValues</b>({<br />
                              ...<b>values</b>,<br />
                              <b><i>password</i></b
                  >: evt.target.<b>value</b>,<br />
                          });<br />
                      };<br />
                      <br />
                      return (<br />
                          &#60;form><br />
                              &#60;input<br />
                                  type="text"<br />
                                  name="<b>login</b>"<br />
                                 
                  <b>value={values.login}</b><br />
                                 
                  <b>onChange={handleLoginChange}</b><br />
                              /><br />
                              &#60;input<br />
                                  type="password"<br />
                                  name="<b>password</b>"<br />
                                 
                  <b>value={values.password}</b><br />
                                 
                  <b>onChange={handlePwdChange}</b><br />
                              /><br />
                              &#60;button
                  type="submit">Login&#60;/button><br />
                          &#60;/form><br />
                      );<br />
                  };
                </p>
              </div>
            </div>

            <section class="sub-section new-page">
              <h4 class="m-bottom-min">Відправка форми</h4>

              <div class="m-bottom flex">
                <div>
                  <p class="m-bottom-min">
                    Щоб отримати значення полів
                    контрольованої форми під час
                    відправлення, необхідно створити
                    функцію, (наприклад
                    <b>handleSubmit</b>), в якій звернутися
                    до стану форми.
                  </p>
                  <p class="m-bottom-min">
                    Саму Функцію передати як значення
                    <i>вбудованного атрибута</i>
                    <b>onSubmit</b> елемента <b>form</b>.
                  </p>
                  <p class="border-box">
                    <b>Важливо!</b> Часто, після отримання
                    значень із форми, стан необхідно
                    очистити.
                  </p>
                </div>
                <div class="bcg-box">
                  <p>
                    const <b>handleSumit</b> = (evt) => {<br />
                        evt.preventDefault();<br />
                        <br />
                        <i>// Значення полів</i><br />
                        <b><i>console.log(values)</i></b
                    >;<br />
                        <i>// Очищаємо форму</i><br />
                       
                    <b
                      ><i
                        >setValues({<br />
                                login: "",<br />
                                password: "",<br />
                            })</i
                      ></b
                    >;<br />
                    };<br />
                    <br />
                    &#60;form onSubmit={<b>handleSumit</b>}>
                  </p>
                </div>
              </div>

              <div class="flex">
                <p class="">
                  Ось повний код прикладу форми для входу.
                </p>
                <div class="bcg-box">
                  <p>
                    const LoginForm = () => {<br />
                        const [values, setValues] =
                    useState({<br />
                            login: "",<br />
                            password: "",<br />
                        });<br />
                        <br />
                        const handleChange = (evt) => {<br />
                            setValues({<br />
                                ...values,<br />
                                [evt.target.name]:
                    evt.target.value,<br />
                            });<br />
                        };<br />
                        <br />
                        const handleSumit = (evt) => {<br />
                            evt.preventDefault();<br />
                            <br />
                            console.log(values);<br />
                            <br />
                            setValues({<br />
                                login: "",<br />
                                password: "",<br />
                            });<br />
                        };<br />
                        <br />
                        return (<br />
                            &#60;form
                    onSubmit={handleSumit}><br />
                                &#60;input<br />
                                    type="text"<br />
                                    name="login"<br />
                                    value={values.login}<br />
                                   
                    onChange={handleChange}<br />
                                /><br />
                                &#60;input<br />
                                    type="password"<br />
                                    name="password"<br />
                                   
                    value={values.password}<br />
                                   
                    onChange={handleChange}<br />
                                /><br />
                                &#60;button
                    type="submit">Login&#60;/button><br />
                            &#60;/form><br />
                        );<br />
                    };
                  </p>
                </div>
              </div>
            </section>
          </section>

          <!-- Колекція елементів -->
          <section class="section new-page">
            <h3 class="m-bottom-min">Колекція елементів</h3>

            <div class="flex">
              <div>
                <p>
                  Розглянемо, як працювати з колекцією
                  елементів, тобто масивом об'єктів. Задачі:
                </p>

                <ul class="m-bottom-min">
                  <li>
                    оновлювати стан, якщо в ньому
                    зберігається масив;
                  </li>
                  <li>
                    додавати новий елемент до колекції;
                  </li>
                  <li>
                    видаляти елемент з колекції за його
                    ідентифікатором;
                  </li>
                  <li>фільтрувати колекцію.</li>
                </ul>

                <p class="border-box m-bottom-min">
                  <b>Важливо!</b> При роботі із колекцією
                  елементів (масиви, об'єкти),
                  рекомендується використовувати у сеттері
                  стану функціональну форму (
                  <b>( ) => { }</b> ).
                </p>

                <p>Кроки:</p>

                <ol>
                  <li class="m-bottom-min">
                    Додаємо новий елемент до колекції:
                    <ul class=" ">
                      <li>
                        <b>App.jsx.</b> Додаємо у стан нову
                        задачу:
                        <ul class=" ">
                          <li>
                            оголошуємо стан
                            <b
                              >[tasks, setTasks] =
                              useState(initialTasks)</b
                            >
                            (початковий стан - імпортований
                            *.json
                            <b>initialTasks</b> - коллекція
                            задач);
                          </li>

                          <li>
                            <i>функція</i>
                            <b>addTask</b> - приймає нову
                            задачу (<b>newTask</b>) із
                            <i>компонента</i>
                            <b>Form</b> та створює новий
                            об'єкт, розпиливши попередній
                            перелік задач (<b>prevTasks</b>)
                            та додавший нову задачу;
                          </li>
                          <li>
                            передаємо у <i>props</i>
                            <i>компонента</i>
                            <b>Form</b>
                            <b>onAdd={addTask}</b>;
                          </li>
                        </ul>
                      </li>
                      <li>
                        <b>Form.jsx.</b> Приймаємо
                        <i>props</i> <b>onAdd</b> та
                        обробляємо сабміт:
                        <ul class=" ">
                          <li>
                            <i>функція</i>
                            <b>handleSubmit</b> - створює
                            об'єкт куди передає як
                            властивості назву нової таски з
                            <b>input</b> та новий <b>id</b>,
                            після чого очищує поле
                            <b>input</b>;
                          </li>
                          <li>
                            передаємо у <i>props</i>
                            <i>тега</i>
                            <b>form</b>
                            <b>onSubmit={handleSubmit}</b>.
                          </li>
                        </ul>
                      </li>
                    </ul>
                  </li>

                  <li class="m-bottom-min new-page">
                    Видаляємо існуючий елемент із колекції
                    <ul class=" ">
                      <li>
                        <b>App.jsx.</b> Видаляємо зі стану
                        існуючий елемент:
                        <ul class=" ">
                          <li>
                            <i>функція</i>
                            <b>deleteTask</b> - приймає
                            <b>id</b> елемента
                            (<b>taskId</b>) із
                            <i>компонента</i>
                            <b>TaskList</b>, що необхідно
                            видалити та фільтрує старий
                            об'єкт (<b>prevTasks</b>),
                            шляхом порівняння
                            <b>id</b>
                            елементів із отриманим
                            (<b>taskId</b>);
                          </li>
                          <li>
                            передаємо у <i>props</i>
                            <i>компонента</i>
                            <b>TaskList</b>
                            <b>onDelete={deleteTask}</b>.
                          </li>
                        </ul>
                      </li>
                      <li>
                        <b>TaskList.jsx.</b> Приймаємо
                        <i>props</i> <b>onDelete</b> та
                        отримуємо <b>id</b> елемента для
                        видалення (<i>транзитом</i>):
                        <ul class=" ">
                          <li>
                            передаємо у <i>props</i>
                            <i>компонента</i>
                            <b>Task</b>
                            <b>onDelete={onDelete}</b> (із
                            тим же самим ім'ям).
                          </li>
                        </ul>
                      </li>
                      <li>
                        <b>Task.jsx.</b> Приймаємо
                        <i>props</i> <b>onDelete</b> та id
                        елементів коллекції (<i
                          >попередньо деструктуризувавши
                          масив колекції компонентів</i
                        >) та отримуємо <b>id</b> елемента
                        для видалення:
                        <ul class=" ">
                          <li>
                            передаємо у <i>props</i>
                            <i>тега</i>
                            <b>button</b>
                            <b
                              >onClick={() =>
                              onDelete(id)</b
                            >.
                          </li>
                        </ul>
                      </li>
                    </ul>
                  </li>
                  <li>
                    Фільтруємо колекцію.
                    <ul class=" ">
                      <li>
                        <b>App.jsx.</b> Отримуємо текст для
                        фільтру:
                        <ul class=" ">
                          <li>
                            оголошуємо стан
                            <b
                              >[filter, setFilter] =
                              useState('')</b
                            >
                            (початковий стан - порожній
                            рядок).
                          </li>

                          <li>
                            передаємо у <i>props</i>
                            <i>компонента</i>
                            <b>Filter</b>
                            <b>value={filter}</b> та
                            <b>onFilter={setFilter}</b> зі
                            стану.
                          </li>
                        </ul>
                      </li>
                      <li class="">
                        <b>Filter.jsx.</b> Приймаємо
                        <i>props</i> <b>value</b> та
                        <b>onFilter</b> та отримуємо текст
                        для фільтру і передаємо до
                        <b>App.jsx.</b>:
                        <ul class=" ">
                          <li>
                            передаємо у <i>props</i>
                            <i>тега</i>
                            <b>input</b>
                            <b>value={value}</b> та
                            <b
                              >onChange={(e) =>
                              onFilter(e.target.value)</b
                            >.
                          </li>
                        </ul>
                      </li>
                      <li>
                        <b>App.jsx.</b> фільтруємо масив
                        елементів на предмет наявності
                        ключового тексту
                      </li>
                    </ul>
                  </li>
                </ol>
              </div>

              <div>
                <div class="bcg-box m-bottom-min">
                  <p>
                    <i>// App.jsx</i><br />
                    import TaskList from
                    '../TaskList/TaskList';<br />
                    import <b>initialTasks</b> from
                    '../../tasks.json';<br />
                    import Form from '../Form/Form';<br />
                    import Filter from
                    '../Filter/Filter';<br />
                    import css from './App.module.css';<br />
                    import { useState } from 'react';<br />
                    <br />
                    export default function App() {<br />
                        const
                    <b
                      >[tasks, setTasks] =
                      useState(initialTasks)</b
                    >;<br />
                        const [filter, setFilter] =
                    useState('');<br />
                        <br />
                        const <b>addTask</b> = (newTask) =>
                    {<br />
                            setTasks((prevTasks) => {<br />
                                return [...prevTasks,
                    newTask];<br />
                            });<br />
                        };<br />
                        const <b>deleteTask</b> = (taskId)
                    => {<br />
                            setTasks((prevTasks) => {<br />
                                return
                    prevTasks.filter((task) => task.id !==
                    taskId);<br />
                            });<br />
                        };<br />
                        const <b>visibleTasks</b> =
                    tasks.filter((task) =><br />
                           
                    task.text.toLowerCase().includes(filter.toLowerCase())<br />
                        );<br />
                        <br />
                        return (<br />
                            &#60;div
                    className={css.container}><br />
                                &#60;Form
                    <b>onAdd={addTask}</b> /><br />
                                &#60;Filter
                    <b>value={filter}</b>
                    <b>onFilter={setFilter}</b> /><br />
                                &#60;TaskList
                    tasks={<b>visibleTasks</b>}
                    <b>onDelete={deleteTask}</b> /><br />
                            &#60;/div><br />
                        );<br />
                    }
                  </p>
                </div>

                <div class="bcg-box m-bottom-min">
                  <p>
                    <i>// Form.jsx</i><br />
                    import css from './Form.module.css';<br />
                    <br />
                    export default function Form({
                    <b>onAdd</b> }) {<br />
                        const <b>handleSubmit</b> = (e) =>
                    {<br />
                            e.preventDefault();<br />
                    <br />
                            <b>onAdd</b>({<br />
                                id: Date.now(),<br />
                                text:
                    e.target.elements.text.value,<br />
                            });<br />
                            e.target.reset();<br />
                        };<br />
                        <br />
                        return (<br />
                            &#60;form className={css.form}
                    <b>onSubmit={handleSubmit}</b>><br />
                                &#60;input
                    className={css.field} type="text"
                    name="text" /><br />
                                &#60;button
                    type="submit">Add task&#60;/button><br />
                            &#60;/form><br />
                        );<br />
                    }
                  </p>
                </div>

                <div class="bcg-box m-bottom-min new-page">
                  <p>
                    <i>// Filter.jsx</i><br />
                    <br />
                    import css from
                    './Filter.module.css';<br />
                    <br />
                    export default function Filter({
                    <b>value, onFilter</b> }) {<br />
                        return (<br />
                            &#60;div><br />
                                &#60;p
                    className={css.label}>Search by
                    name&#60;/p><br />
                                &#60;input<br />
                                    type="text"<br />
                                    <b>value={value}</b
                    ><br />
                                   
                    <b
                      >onChange={(e) =>
                      onFilter(e.target.value)}</b
                    ><br />
                                /><br />
                            &#60;/div><br />
                        );<br />
                    }
                  </p>
                </div>

                <div class="bcg-box m-bottom-min">
                  <p>
                    <i>// TaskList.jsx</i><br />
                    <br />
                    import Task from '../Task/Task';<br />
                    import css from
                    './TaskList.module.css';<br />
                    <br />
                    export default function TaskList({
                    tasks,
                    <b>onDelete</b> }) {<br />
                        return (<br />
                            &#60;ul className={css.list}><br />
                                {tasks.map((task) => (<br />
                                    &#60;li
                    className={css.item} key={task.id}><br />
                                        &#60;Task
                    data={task}
                    <b>onDelete={onDelete}</b> /><br />
                                    &#60;/li><br />
                                ))}<br />
                            &#60;/ul><br />
                        );<br />
                    }
                  </p>
                </div>

                <div class="bcg-box">
                  <p>
                    <i>// Task.jsx</i><br />

                    <br />
                    import css from './Task.module.css';<br />
                    <br />
                    export default function Task({ data: {
                    <b>id</b>, text }, <b>onDelete</b> })
                    {<br />
                        return (<br />
                            &#60;div
                    className={css.container}><br />
                                &#60;p
                    className={css.text}>{text}&#60;/p><br />
                                &#60;button<br />
                                    className={css.btn}<br />
                                   
                    <b>onClick={() => onDelete(id)}</b
                    ><br />
                                ><br />
                                    Delete<br />
                                &#60;/button><br />
                            &#60;/div><br />
                        );<br />
                    }
                  </p>
                </div>
              </div>
            </div>

            <!-- додаток до списку -->
            <ul
              class=""
              style="
                margin-left: 80px;
                list-style-type: square;
              "
            >
              <li>
                <i>функція</i>
                <b>visibleTasks</b> приймає масив елементів
                задач із стану <b>tasks</b> та фільтрує по
                наявності фільтруючого тексту зі стану
                <b>filter</b> (самі стани залишаються не
                зміними);
              </li>
              <li>
                передаємо у <i>props</i>
                <i>компонента</i>
                <b>TaskList</b>
                <b>tasks={visibleTasks}</b>
                для рендеру
                <i>компонентів</i>
                <b>Task</b> (на початку він ренедився із
                <b>initialTasks</b>).
              </li>
            </ul>
          </section>

          <div class="new-page"></div>

          <!-- Бібліотека Formik -->
          <section class="section new-page">
            <h3 class="m-bottom-min">Бібліотека Formik</h3>

            <div class="m-bottom-min flex">
              <p>
                <b>Formik!</b> (https://formik.org/)
                бібліотека для роботи з <i>формами</i> в
                React та React Native.
              </p>
              <div class="bcg-box">
                <p>npm install formik</p>
              </div>
            </div>

            <p class="m-bottom">
              Дбає про рутинні аспекти розробки —
              відстеження значень/помилок/відвіданих полів,
              валідація та обробка даних. Для внутрішньої
              логіки Formik використовує лише звичайний стан
              та властивості React. Залишаючись в межах
              основного фреймворку React, Formik робить
              налагодження та мислення про форми легкими.
            </p>

            <!-- Контейнер форми -->
            <section class="sub-section">
              <h4 class="m-bottom-min">Контейнер форми</h4>

              <div class="m-bottom-min flex">
                <div>
                  <p class="m-bottom-min">
                    Побудова форми починається з
                    компонента-контейнера <b>Formik</b>.
                  </p>
                  <div class="border-box">
                    <p>
                      <b>Важливо!</b> Його необхідно
                      <b>імпортувати</b> та при
                      <i>виклику передати два пропси</i>:
                    </p>
                    <ul>
                      <li>
                        <b>initialValues</b> - об'єкт
                        початкових значень полів, наразі
                        передамо порожній об'єкт.
                      </li>
                      <li>
                        <b>onSubmit</b> - функція, яка буде
                        викликана при сабміті форми..
                      </li>
                    </ul>
                  </div>
                </div>
                <div class="bcg-box">
                  <p>
                    <b>import { Formik } from 'formik'</b
                    >;<br />
                    <br />
                    const FeedbackForm = () => {<br />
                        return (<br />
                           
                    <b
                      >&#60;Formik initialValues={{}}
                      onSubmit={() => {}}></b
                    ><br />
                                ...<br />
                            <b>&#60;/Formik></b><br />
                        );<br />
                    };
                  </p>
                </div>
              </div>

              <div class="flex">
                <div>
                  <p class="m-bottom-min">
                    Усередині компонента
                    <i>Formik</i> вкладаються елементи
                    форми, але <i>не вбудовані теги</i>,
                    такі як <b>form</b> чи <b>input</b>, а
                    ті, що надає бібліотека.
                  </p>
                  <p>
                    <i>Компонент</i> <b>Form</b> рендерить
                    звичайний <i>тег</i> <b>form</b>, але з
                    розширеним функціоналом бібліотеки
                    Formik.
                  </p>
                </div>
                <div class="bcg-box">
                  <p>
                    import { Formik, <b>Form</b> } from
                    'formik';<br />
                    const FeedbackForm = () => {<br />
                        return ( <br />
                            &#60;Formik initialValues={{}}
                    onSubmit={() => {}}><br />
                                <b>&#60;Form></b><br />
                                    &#60;button
                    type="submit">Submit&#60;/button><br />
                                <b>&#60;/Form></b><br />
                            &#60;/Formik><br />
                        );<br />
                    };
                  </p>
                </div>
              </div>
            </section>

            <!-- Поля форми -->
            <section class="sub-section">
              <h4 class="m-bottom-min">Поля форми</h4>

              <div class="flex">
                <div>
                  <p class="m-bottom-min">
                    Для додавання полів форми
                    використовується
                    <i>компонент</i> <b>Field</b>, який за
                    замовчуванням рендерить <i>тег</i>
                    <b>input</b>. Кожному полю обов'язково
                    потрібно вказати <i>атрибут</i>
                    <b>name</b>.
                  </p>
                  <p class="m-bottom-min">
                    Тег <b>Field</b>, як і тег <b>Form</b>,
                    <i
                      >пов'язує поля форми і внутрішню
                      логіку бібліотеки</i
                    >, яка зберігається в тезі
                    <b>Formik</b>.
                  </p>
                </div>
                <div class="bcg-box">
                  <p>
                    import { Formik, Form, Field } from
                    'formik';<br />
                    const FeedbackForm = () => {<br />
                        return (<br />
                            &#60;Formik initialValues={{}}
                    onSubmit={() => {}}><br />
                                &#60;Form><br />
                                    &#60;<b
                      >Field type="text" name="username"
                      /></b
                    ><br />
                                    &#60;<b
                      >Field type="email" name="email" /></b
                    ><br />
                                    &#60;button
                    type="submit">Submit&#60;/button><br />
                                &#60;/Form><br />
                            &#60;/Formik><br />
                        );<br />
                    };
                  </p>
                </div>
              </div>
            </section>

            <!-- Стилізація -->
            <section class="sub-section">
              <h4 class="m-bottom-min">Стилізація</h4>

              <div class="m-bottom flex">
                <div>
                  <p class="m-bottom-min">
                    <i>Компоненти</i> з бібліотеки Formik
                    стилізуються за допомогою <i>пропса</i>
                    <b>className</b> і <b>CSS-модулів</b>.
                    Значення
                    <i>пропса</i>
                    <b>className</b> передається тегу, який
                    рендерить компонент, і відповідно
                    стилізація застосовується до необхідного
                    тегу.
                  </p>
                  <p class="border-box">
                    <b>Важливо!</b> Компонент
                    <b>Formik не стилізується</b>, оскільки
                    не рендерить жодного тегу, а зберігає
                    логіку роботи з формою..
                  </p>
                </div>

                <div class="bcg-box">
                  <p>
                    import { Formik, Form, Field } from
                    'formik';<br />
                    <b
                      >import css from
                      "./FeedbackForm.module.css"</b
                    >;<br />
                    <br />
                    const FeedbackForm = () => {<br />
                        return (<br />
                            &#60;Formik initialValues={{}}
                    onSubmit={() => {}}><br />
                                &#60;Form
                    <b>className={css.form}</b>><br />
                                    &#60;Field
                    <b>className={css.field}</b>
                    type="text" name="username" /><br />
                                    &#60;Field
                    <b>className={css.field}</b>
                    type="email" name="email" /><br />
                                    &#60;button
                    <b>classname={css.btn}</b>
                    type="submit">Submit&#60;/button><br />
                                &#60;/Form><br />
                            &#60;/Formik><br />
                        );<br />
                    };
                  </p>
                </div>
              </div>
            </section>

            <!-- Початкове значення полів -->
            <section class="sub-section new-page">
              <h4 class="m-bottom-min">
                Початкове значення полів
              </h4>

              <div class="m-bottom flex">
                <div>
                  <p class="m-bottom-min">
                    Форми, створені за допомогою бібліотеки
                    Formik -
                    <b>контрольовані форми</b>,
                    <i
                      >значення кожного поля зберігається
                      в</i
                    >
                    <b>стані</b>. Не потрібно оголошувати та
                    змінювати стан, це
                    <i>вже виконує</i> компонент
                    <b>Formik</b>.
                  </p>
                  <p class="m-bottom-min">
                    <i>Пропсу</i>
                    <b>initialValues</b> необхідно передати
                    об'єкт з початковими значеннями полів.
                  </p>
                  <p class="border-box">
                    <b>Уважно!</b> Усередині Formik зберігає
                    стан у вигляді об'єкта, де імена полів -
                    це імена властивостей у стані, а
                    значення полів - це значення
                    властивостей.
                  </p>
                </div>
                <div class="bcg-box">
                  <p>
                    import { Formik, Form, Field } from
                    "formik";<br />
                    <br />
                    const FeedbackForm = () => {<br />
                        return (<br />
                            &#60;Formik<br />
                               
                    <b
                      >initialValues={{<br />
                                      username: "",<br />
                                      email: ""<br />
                                  }}</b
                    ><br />
                                onSubmit={() => {}}<br />
                            ><br />
                                &#60;Form><br />
                                    &#60;Field type="text"
                    <b>name="username"</b> /><br />
                                    &#60;Field type="email"
                    <b>name="email"</b> /><br />
                                    &#60;button
                    type="submit">Submit&#60;/button><br />
                                &#60;/Form><br />
                            &#60;/Formik><br />
                        );<br />
                    };
                  </p>
                </div>
              </div>

              <div class="flex">
                <p class="">
                  <i>Якщо форма велика</i>, зручно винести
                  об'єкт початкових значень полів в
                  <b>зовнішню змінну</b>.
                </p>
                <div class="bcg-box">
                  <p>
                    <b
                      >const initialValues = {<br />
                          username: "",<br />
                          email: ""<br />
                      };</b
                    ><br />
                    <br />
                    &#60;Formik
                    <b>initialValues={initialValues}</b>
                    onSubmit={() => {}}><br />
                    &#60;/Formik><br />
                  </p>
                </div>
              </div>
            </section>

            <!-- Відправка форми -->
            <section class="sub-section">
              <h4 class="m-bottom-min">Відправка форми</h4>

              <div class="flex">
                <div>
                  <p class="m-bottom-min">
                    При відправці форми викликається
                    <i>колбек-функція</i>, (<i>пропс</i>
                    <b>onSubmit</b>
                    <i>компоненту Formik</i>). Зручною є
                    ідея зробити її іменованою функцією
                    <b>handleSubmit</b> і передати посилання
                    на неї в <b>onSubmit</b>.
                  </p>

                  <p>
                    Функція відправки форми має два
                    параметри:
                  </p>

                  <ul class="m-bottom-min">
                    <li>
                      <b>values</b> - об'єкт значень полів
                      форми в момент її відправки.
                    </li>
                    <li>
                      <b>actions</b> - об'єкт з допоміжними
                      методами. Наприклад, метод
                      <b>resetForm</b>
                      використовується для очищення полів
                      форми після відправки.
                    </li>
                  </ul>

                  <p>
                    Функція відправки форми не отримує
                    об'єкт події, що є зайвим. Formik в
                    момент відправки форми:
                  </p>

                  <ul>
                    <li>
                      викликає метод
                      <b>preventDefault</b>, щоб уникнути
                      перезавантаження сторінки;
                    </li>
                    <li>
                      збирає значення полів форми в
                      <b>один об'єкт</b>, де
                      <i
                        >ім'я властивості - це ім'я поля, а
                        значення поля - це значення
                        властивості</i
                      >.
                    </li>
                  </ul>
                </div>
                <div class="bcg-box">
                  <p>
                    import { Formik, Form, Field } from
                    "formik";<br />
                    <br />
                    <br />
                    const FeedbackForm = () => {<br />
                    <br />
                    <b
                      >    const handleSubmit = (values,
                      actions) => {<br />
                              console.log(values);<br />
                              actions.resetForm();<br />
                          };<br
                    /></b>
                        <br />
                        return (<br />
                            &#60;Formik<br />
                                initialValues={{}}<br />
                               
                    <b>onSubmit={handleSubmit}</b><br />
                            ><br />
                                &#60;Form><br />
                                    &#60;Field type="text"
                    name="username" /><br />
                                    &#60;Field type="email"
                    name="email" /><br />
                                    &#60;button
                    type="submit">Submit&#60;/button><br />
                                &#60;/Form><br />
                            &#60;/Formik><br />
                        );<br />
                    };
                  </p>
                </div>
              </div>
            </section>

            <!-- Елементи форми -->
            <section class="sub-section new-page">
              <h4 class="m-bottom-min">Елементи форми</h4>

              <div class="flex">
                <p class="">
                  В бібліотеці <b>Formik</b> немає
                  компонентів для створення <b>label</b>,
                  <b>fieldset</b>, <b>legend</b> та інших
                  семантичних елементів форми. Для цього
                  використовуються звичайні теги.
                  Обов'язково необхідно використовувати хук
                  <b>useId</b> для створення унікальних
                  ідентифікаторів полів.
                </p>
                <div class="bcg-box">
                  <p>
                    import { useId } from "react";<br />
                    import { Formik, Form, Field } from
                    "formik";<br />
                    <br />
                    const FeedbackForm = () => {<br />
                        const <b>nameId</b> = useId();<br />
                        const <b>emailId</b> = useId();<br />
                        <br />
                        return (<br />
                            &#60;Formik initialValues={{}}
                    onSubmit={() => {}}><br />
                                &#60;Form><br />
                                    &#60;label
                    htmlFor={<b>nameId</b>}>Username&#60;/label><br />
                                    &#60;Field type="text"
                    name="username" id={<b>nameId</b>} /><br />
                                    &#60;label
                    htmlFor={<b>emailId</b>}>Email&#60;/label><br />
                                    &#60;Field type="email"
                    name="email" id={<b>emailId</b>} /><br />

                                &#60;/Form><br />
                            &#60;/Formik><br />
                        );<br />
                    };
                  </p>
                </div>
              </div>
            </section>

            <!-- Типи полів -->
            <section class="sub-section">
              <h4 class="m-bottom-min">Типи полів</h4>

              <div class="m-bottom flex">
                <p class="">
                  За замовчуванням <i>компонент</i>
                  <b>Field</b> рендерить <i>тег</i>
                  <b>input</b>. Щоб змінити тип поля,
                  необхідно передати
                  <i>компоненту Field пропс</i>
                  <b>as</b> значенням якого є рядок -
                  <i>тип тега</i> (наприклад,
                  <b>input, select, textarea</b>).
                </p>
                <div class="bcg-box">
                  <p>
                    &#60;Field <br />
                        <b>as="textarea"</b><br />
                        name="message"<br />
                        cols="20"<br />
                        rows="5"<br />
                        id={massageId}<br />
                    />
                  </p>
                </div>
              </div>
            </section>

            <!-- Селект -->
            <section class="sub-section">
              <h4 class="m-bottom-min">Селект</h4>

              <div class="flex">
                <div>
                  <p class="m-bottom-min">
                    Для використання
                    <b>select</b> компоненту
                    <b>Field</b> передається пропс
                    <b>as="select"</b>. Список опцій
                    вказується тегами <b>option</b> між
                    відкриваючим та закриваючим тегами
                    <b>Field</b>.
                  </p>
                  <p class="border-box">
                    <b>Важливо!</b> До об'єкта
                    <i>початкових значень</i> необхідно
                    додати
                    <i
                      >властивість із значенням за
                      замовчуванням</i
                    >. А <b>тегам option</b> - атрибут
                    <b>value</b>.
                  </p>
                </div>
                <div class="bcg-box">
                  <p>
                    import { useId } from "react";<br />
                    import { Formik, Form, Field } from
                    "formik";<br />
                    <br />
                    const initialValues = {<br />
                        <b>level: "good"</b>,<br />
                    };<br />
                    <br />
                    const FeedbackForm = () => {<br />
                        const levelId = useId();<br />
                        <br />
                        return (<br />
                            &#60;Formik
                    initialValues={initialValues}
                    onSubmit={() => {}}&#60;/Formik><br />
                                &#60;Form><br />
                                    &#60;label
                    htmlFor="levelId">Service satisfaction
                    level&#60;/label><br />
                                    &#60;Field
                    <b>as="select"</b> name="<b>level</b>"
                    id={levelId}><br />
                                        &#60;option
                    <b>value="good"</b
                    >>Good&#60;/option><br />

                                        &#60;option
                    <b>value="bad"</b
                    >>Bad&#60;/option><br />
                                    &#60;/Field><br />
                                &#60;/Form><br />
                            &#60;/Formik><br />
                        );<br />
                    };
                  </p>
                </div>
              </div>
            </section>

            <!-- Валідація -->
            <section class="sub-section new-page">
              <h4 class="m-bottom-min">Валідація</h4>

              <div class="m-bottom-min flex">
                <div>
                  <p class="m-bottom-min">
                    <b>Валідація</b> - це перевірка введених
                    користувачем значень на відповідність
                    деяким критеріям. Валідація - це
                    передусім захист від неправильно
                    введених значень перед їх відправленням
                    на сервер.
                  </p>
                  <p>
                    В <i>Formik</i> валідація виконується
                    <i>автоматично</i>, все, що потрібно
                    зробити, це налаштувати її. Для цього
                    необхідно встановити бібліотеку
                    валідації <b>Yup</b> та імпортувати її в
                    компонент форми.
                  </p>
                </div>
                <div>
                  <div class="m-bottom-min bcg-box">
                    <p>
                      <i>// terminal</i><br />
                      <b>npm install yup</b>
                    </p>
                  </div>
                  <div class="bcg-box">
                    <p>
                      <i>// Form.jsx</i><br />
                      <b>import * as Yup from "yup"; </b>
                    </p>
                  </div>
                </div>
              </div>

              <div class="m-bottom-min flex">
                <p>
                  Валідатор Yup використовує схеми валідації
                  для перевірки значень. Значення форми
                  зберігаються в стані Formik у вигляді
                  об'єкта з властивостями.
                </p>
                <div class="bcg-box">
                  <p>
                    const FeedbackSchema =
                    Yup.object().shape({});
                  </p>
                </div>
              </div>

              <div class="m-bottom-min flex">
                <div>
                  <p class="m-bottom-min">
                    <b>Приклад валідації</b>
                  </p>

                  <p>
                    Для поля <b>username</b> валідується
                    наступне:
                  </p>

                  <ul class="m-bottom-min">
                    <li>це рядок;</li>
                    <li>
                      рядок повинен бути принаймні 2
                      символи;
                    </li>
                    <li>
                      рядок повинен бути максимум 50
                      символів;
                    </li>
                    <li>
                      властивість обов'язкова для
                      заповнення.
                    </li>
                  </ul>

                  <p>
                    Функції
                    <b
                      >Yup.string(), Yup.min(), Yup.max(),
                      Yup.required()</b
                    >
                    і інші - це валідатори, які дозволяють
                    додати певний критерій валідації. Кожен
                    валідатор може приймати від нуля до двох
                    параметрів.
                  </p>

                  <ul>
                    <li>
                      перший - це критерій валідації,
                      наприклад, довжина рядка чи значення
                      числа;
                    </li>
                    <li>
                      другий - це рядок, який буде
                      використаний як помилка у разі
                      валідації.
                    </li>
                  </ul>
                </div>

                <div class="bcg-box">
                  <p>
                    const FeedbackSchema =
                    Yup.object().shape({<br />
                        username: Yup.string().min(2, "Too
                    Short!")<br />
                                    .max(50, "Too
                    Long!").required("Required"),<br /><br />
                        email: Yup.string().email("Must be a
                    valid email!")<br />
                                   
                    .required("Required"),<br /><br />
                        message: Yup.string().min(3, "Too
                    short")<br />
                                    .max(256, "Too
                    long").required("Required"),<br /><br />
                        level: Yup.string().oneOf(["good",
                    "neutral", "bad"])<br />
                                    .required("Required")<br />
                    });
                  </p>
                </div>
              </div>

              <p class="m-bottom-min border-box">
                <b>Цікаво!</b> Значенням текстового поля
                типу може бути будь-який рядок, а в разі з
                <b>селектом</b> - лише заздалегідь визначене
                значення з набору опцій, тому використовуємо
                інший валідатор <b>oneOf()</b>, якому
                передається масив всіх можливих значень.
              </p>

              <div class="m-bottom-min flex">
                <div>
                  <p class="m-bottom-min">
                    Схема валідації передається у Formik як
                    третій пропс.
                  </p>
                  <p>
                    Після додавання валідації, ми не зможемо
                    відправити форму, якщо в одному з полів
                    буде введено невалідне значення.
                  </p>
                </div>

                <div class="bcg-box">
                  <p>
                    &#60;Formik<br />
                        initialValues={{}}<br />
                        onSubmit={() => {}}<br />
                       
                    <b>validationSchema={FeedbackSchema}</b
                    ><br />
                    >
                  </p>
                </div>
              </div>
            </section>

            <!-- Помилки валідації -->
            <section class="sub-section">
              <h4 class="m-bottom-min">
                Помилки валідації
              </h4>
              <div class="m-bottom-min flex">
                <p>
                  Для того щоб відобразити користувачу
                  помилки валідації, використовується
                  компонент
                  <b>ErrorMessage</b>.
                </p>
                <div class="bcg-box">
                  <p>
                    import { ErrorMessage } from "formik";
                  </p>
                </div>
              </div>

              <div class="m-bottom flex">
                <div>
                  <p>
                    Компонент <b>ErrorMessage</b> додаєтья в
                    розмітку після кожного поля із
                    валідацією
                  </p>

                  <ul>
                    <li>
                      значення атрибута
                      <b>name</b> компонентів
                      <b>ErrorMessage</b> та
                      <b>Field</b> повинно співпадати. Це
                      потрібно для того, щоб
                      <b>ErrorMessage</b> виводиво
                      повідомлення про помилку валідації для
                      пов'язаного поля;
                    </li>
                    <li>
                      за замовчуванням
                      <b>ErrorMessage</b> відображає текст
                      без тега, це не зручно, оскільки текст
                      неможливо стилізувати. Проп
                      <b>component</b> вказує, в якому тезі
                      рендерити текст помилки.
                    </li>
                    <li>
                      атрибут <b>className</b> дозволяє
                      стилізувати компонент
                    </li>
                  </ul>
                </div>

                <div class="bcg-box">
                      &#60;label htmlFor="{nameFieldId}"><br />
                          Username<br />
                      &#60;/label><br />
                      &#60;Field<br />
                          type="text"<br />
                          <b>name="username"</b><br />
                          id="{nameFieldId}"<br />
                      /><br />
                     <b
                    >&#60;ErrorMessage<br />
                            className={css.error}<br />
                            name="username"<br />
                            component="span"<br />
                        /></b
                  >
                </div>
              </div>
            </section>
          </section>
        </div>
      </section>

      <!-- HTTP-запити -->
      <section id="http-request" class="main-section">
        <div class="container">
          <h2 class="m-bottom center-text">HTTP-запити</h2>

          <div class="m-bottom-min flex">
            <div>
              <p class="m-bottom-min">
                У React немає вбудованого модуля для роботи
                з HTTP-запитами, тому можемо використовувати
                звичайні інструменти, наприклад бібліотеку
                Axios.
              </p>
              <p class="m-bottom-min">
                Її, звісно, необхідно імпортувати у
                компоненті.
              </p>
              <p>
                HTTP-запити можна виконувати як за подією,
                наприклад, при кліку на елементі чи
                відправці форми, так і без очікування дій
                користувача, тобто при монтажі компонента. У
                останньому випадку використовується ефект,
                який виконується після етапу монтажу,
                оскільки компонент вже був відображений у
                DOM і готовий до подальшого оновлення стану.
              </p>
            </div>
            <div class="bcg-box">
              <p>
                <i>// terminal</i><br />
                npm install axios<br /><br />
                import axios from "axios";<br />
                <br />
                const App = () => {<br />

                    useEffect(() => {<br />
                        <i>// HTTP-запит</i><br />
                    }, []);<br />
                <br />
                    return ( ... );<br />
                };
              </p>
            </div>
          </div>

          <div class="m-bottom flex">
            <div>
              <p class="m-bottom-min">
                Колбек-функція, що передається
                <b>useEffect</b>,
                <i>не може бути асинхронною</i>. Щоб
                використовувати синтаксис
                <b>async/await</b>, всередині колбек-функції
                необхідно оголосити ще одну функцію, яка
                буде <i>асинхронною</i>, і
                <i>викликати її одразу після оголошення</i>.
                HTTP-запити слід виконувати всередині цієї
                функції.
              </p>
              <p class="border-box">
                <b>Висновок!</b> При монтуванні компонента
                App усередині ефекту буде виконуватися
                HTTP-запит. Також можна виконувати запити
                при діях користувача, але вже не в ефекті, а
                в обробниках подій, наприклад, кліка чи
                відправки форми.
              </p>
            </div>
            <div class="bcg-box">
              <p>
                const App = () => {<br />
                <br />
                    useEffect(() => {<br />
                        async function fetchArticles() {<br />
                            const response = await
                axios.get(<br />
                               
                "&#60;https://hn.algolia.com/api/v1/search?query=react>"<br />
                            );<br />
                            console.log(response);<br />
                        }<br />
                        <br />
                        fetchArticles();<br />
                    }, []);<br />
                    <br />
                    return ( ... );<br />
                };
              </p>
            </div>
          </div>

          <!-- Обробка даних запиту -->
          <section class="section">
            <h3 class="m-bottom-min">
              Обробка даних запиту
            </h3>

            <div class="m-bottom flex">
              <p class="m-bottom-min">
                Щоб відобразити результат HTTP-запиту, його
                необхідно
                <i>зберегти в стані компонента</i>, іншого
                способу немає. Оголосимо стан articles і
                збережемо в ньому результат HTTP-запиту.
                Оскільки з бекенда буде приходити масив
                даних,
                <i
                  >початковим значенням стану буде порожній
                  масив</i
                >.
              </p>
              <div class="bcg-box">
                <p>
                  <b
                    >const [articles, setArticles] =
                    useState([])</b
                  >;<br />
                  <br />
                  useEffect(() => {<br />
                      async function fetchArticles() {<br />
                          const response = await
                  axios.get(<br />
                             
                  "<https://hn.algolia.com/api/v1/search?query=react>"<br />
                          );<br />
                         
                  <b>setArticles(response.data.hits)</b
                  >;<br />
                      }<br />
                      <br />
                      fetchArticles();<br />
                  }, []);
                </p>
              </div>
            </div>

            <section class="sub-section">
              <!-- Відображення даних -->
              <h4 class="m-bottom-min">
                Відображення даних
              </h4>

              <div class="m-bottom-min flex">
                <p>
                  При зміні стану компонент оновиться, тому
                  можна використовувати стан для
                  відображення JSX-розмітки. Використовуємо
                  відображення за умовою і додаємо розмітку
                  у випадку, якщо у масиві є хоча б один
                  елемент.
                </p>
                <p class="border-box">
                  <b>Уважно!</b> умовний рендерінг
                  відбувається в батьківському компоненті
                  <b>App</b>. Компонент
                  <b>ArticleList</b> не знає, коли рендерити
                  розмітку, це завдання компонента, в якому
                  він використовується. Компонент
                  <b>ArticleList</b> або рендериться, або
                  ні, і це вирішує компонент <b>App</b>.
                </p>
              </div>

              <div class="flex new-page">
                <div class="border-box">
                  <p>По крокове перелік дій</p>
                  <ol>
                    <li>
                      Виконати HTTP-запит, будь-то в ефекті
                      чи при події
                    </li>
                    <li>
                      У засобах розробки на вкладці Network
                      переконатися, що запит успішний, і у
                      відповідь ми отримуємо дані
                    </li>
                    <li>
                      Оголосити у компоненті стан для
                      зберігання результату запиту
                    </li>
                    <li>
                      Зберегти результат HTTP-запиту у стані
                    </li>
                    <li>
                      Використовувати стан для відображення
                      JSX-розмітки
                    </li>
                  </ol>
                </div>
                <div class="bcg-box print-fs-14">
                  <p>
                    const ArticleList = ({ items }) => (<br />
                        &#60;ul><br />
                            {items.map(({ objectID, url,
                    title }) => (<br />
                                &#60;li key={objectID}><br />
                                    &#60;a href={url}
                    target="_blank" rel="noreferrer
                    noopener"><br />
                                        {title}<br />
                                    &#60;/a><br />
                                &#60;/li><br />
                            ))}<br />
                        &#60;/ul><br />
                    );<br />
                    <br />
                    const App = () => {<br />
                        const [articles, setArticles] =
                    useState([]);<br />
                        <br />
                        useEffect(() => {<br />
                            async function fetchArticles()
                    {<br />
                                const response = await
                    axios.get(<br />
                                       
                    "&#60;https://hn.algolia.com/api/v1/search?query=react>"<br />
                                    );<br />
                                   
                    setArticles(response.data.hits);<br />
                                }<br />
                            <br />
                            fetchArticles();<br />
                        }, []);<br />
                        <br />
                        return (<br />
                            &#60;div><br />
                                &#60;h2>Latest
                    articles&#60;/h2><br />
                                {articles.length > 0 &&
                    &#60;ArticleList items="{articles}"
                    />}<br />
                            &#60;/div><br />
                        );<br />
                    };
                  </p>
                </div>
              </div>
            </section>
          </section>

          <!-- Індикатор завантаження -->
          <section class="section">
            <h3 class="m-bottom-min">
              Індикатор завантаження
            </h3>

            <div class="flex">
              <div>
                <p class="m-bottom-min">
                  Під час HTTP-запиту потрібно відображати
                  індикатор завантаження. щоб користувач не
                  бачив порожній блок інтерфейсу (попрожній
                  компонент).
                </p>
                <p class="border-box m-bottom-min">
                  <b>Важливо!</b> Індикатор видно, доки
                  запит виконується, і як тільки він
                  завершується, індикатор приховується, а
                  замість нього відображається компонент із
                  завантаженими даними.
                </p>
                <p>
                  Індикатор завантаження є реактивним
                  значенням, тому воно зберігається в
                  <b>стані компонента</b> . У нього всього
                  два значення:
                </p>
                <ul class="m-bottom-min">
                  <li>
                    <b>false</b> - запит ще не розпочався
                    або вже завершився.
                  </li>
                  <li><b>true</b> - запит виконується.</li>
                </ul>
                <p>
                  Перед HTTP-запитом потрібно встановити
                  значення стану <b>loading</b> в
                  <b>true</b>, а після запиту повернутися в
                  <b>false</b>. Для цього у асинхронній
                  функції використовуємо <b>try...catch</b>.
                </p>
              </div>
              <div class="bcg-box print-fs-14">
                <p>
                  const App = () => {<br />
                      const [articles, setArticles] =
                  useState([]);<br />
                     
                  <b
                    >const [loading, setLoading] =
                    useState(false)</b
                  >;<br />
                      <br />
                      useEffect(() => {<br />
                          async function fetchArticles()
                  {<br />
                              try {<br />
                                 
                  <b>setLoading(true)</b>;<br />
                                 
                  <i>// код обробки запиту</i><br />
                              } catch (error) {<br />
                                 
                  <i>// код обробки помилки</i><br />
                              } finally {<br />

                                 
                  <b>setLoading(false)</b>;<br />
                              }<br />
                          }<br />
                          <br />
                          fetchArticles();<br />
                      }, []);<br />
                      <br />
                      return (<br />
                          &#60;div><br />
                              &#60;h2>Latest
                  articles&#60;/h2><br />
                             
                  <b
                    >{loading && &#60;p>Please
                    wait...&#60;/p>}</b
                  ><br />
                              {articles.length > 0 &&
                  &#60;ArticleList items={articles} />}<br />
                          &#60;/div><br />
                      );<br />
                  };
                </p>
              </div>
            </div>
          </section>

          <!-- Обробка помилок -->
          <section class="section new-page">
            <h3 class="m-bottom-min">Обробка помилок</h3>

            <div class="flex">
              <div>
                <p class="m-bottom-min">
                  У конструкції <b>try...catch</b> для
                  обробки помилок використовується блок
                  <b>catch</b>. Якщо він виконається, це
                  означає, що проміс (HTTP-запит) був
                  виконаний з помилкою. Необхідно додати ще
                  один стан <b>error</b> для зберігання
                  помилки.
                </p>
                <p>
                  У JSX можна використовувати стан error,
                  щоб відобразити користувачеві повідомлення
                  про помилку.
                </p>
              </div>
              <div class="bcg-box print-fs-15">
                <p>
                  const App = () => {<br />
                  const [articles, setArticles] =
                  useState([]);<br />
                  const [loading, setLoading] =
                  useState(false);<br />
                  <b
                    >const [error, setError] =
                    useState(false)</b
                  >;<br />
                  <br />
                  useEffect(() => {<br />
                      async function fetchArticles() {<br />
                          try {<br />
                             
                  <i
                    >// код обробки індикатора завантаження
                    та запиту</i
                  ><br />
                          }
                  <b>
                    catch (error) {<br />
                                setError(true)</b
                  >;<br />
                          } finally {<br />
                              setLoading(false);<br />
                          }<br />
                      }<br />
                      fetchArticles();<br />
                  }, []);<br />
                  <br />

                      return (<br />
                          &#60;div><br />
                              &#60;h2>Latest
                  articles&#60;/h2><br />
                              {loading && &#60;p style={{
                  fontSize: 20 }}>Please wait...&#60;/p>}<br />
                             
                  <b
                    >{error && ( &#60;p> Whoops, something
                    went wrong!&#60;/p> )}</b
                  ><br />
                              {articles.length > 0 &&
                  &#60;ArticleList items={articles} />}<br />
                          &#60;/div>     ); };
                </p>
              </div>
            </div>
          </section>

          <!-- Поділ відповідальності -->
          <section class="section">
            <h3 class="m-bottom-min">
              Поділ відповідальності
            </h3>

            <div class="flex">
              <div>
                <p class="m-bottom-min">
                  Зберігати код, пов'язаний з HTTP-запитом,
                  безпосередньо в компоненті - не найкраща
                  практика. У застосунку буде багато різних
                  запитів до бекенду, можливо навіть до
                  декількох різних бекендів, і вони будуть
                  використовуватися в різних компонентах. До
                  того ж код HTTP-запитів може бути складним
                  та громіздким.
                  <i
                    >Для покращення коду використовують
                    окремий файл *.js</i
                  >.
                </p>
                <div class="border-box">
                  <p>У новому файлі:</p>
                  <ul>
                    <li>
                      Оголошуємо асинхронну функцію
                      (async/await) отримання списку статей
                      за заголовком.
                    </li>
                    <li>
                      Функція виконує HTTP-запит і повертає
                      його результат - проміс із даними.
                    </li>
                    <li>
                      Обробка помилки запиту не входить до
                      тіла функції, це виконується в місці
                      її використання, тобто в компоненті.
                    </li>
                    <li>
                      Імпортуємо функцію
                      fetchArticlesWithTopic із файлу api.js
                      в компонент і використовуємо її в
                      ефекті.
                    </li>
                  </ul>
                </div>
                <div class="bcg-box fs-12">
                  <p>
                    <i>// src/articles-api.js</i><br />
                    import axios from "axios";<br />
                    <br />
                    <b
                      >axios.defaults.baseURL =
                      "&#60;https://hn.algolia.com/api/v1>";<br />
                      <br />
                      export const fetchArticlesWithTopic =
                      async topic => {<br />
                          const response =
                      axios.get(`/search?query=${topic}`);<br />
                          return response.data.hits;<br />
                      }</b
                    >;
                  </p>
                </div>
              </div>
              <div class="bcg-box fs-12">
                <p>
                  <i>// App.jsx</i><br />
                  import { fetchArticlesWithTopic } from
                  "../articles-api.js";<br />
                  const App = () => {<br />
                      const [articles, setArticles] =
                  useState([]);<br />
                      const [loading, setLoading] =
                  useState(false);<br />
                      const [error, setError] =
                  useState(false);<br />
                  <br />
                      useEffect(() => {<br />
                          async function fetchArticles()
                  {<br />
                              try {<br />
                                  setLoading(true);<br />
                                 
                  <b
                    >const data = await
                    fetchArticlesWithTopic("react")</b
                  >;<br />
                                 
                  setArticles(<b>data</b>);<br />
                              } catch (error) {<br />
                                 setError(true);<br />
                              } finally {<br />
                                  setLoading(false);<br />
                              }<br />
                          }<br />
                          fetchArticles();<br />
                      }, []);<br />
                  <br />
                      return (<br />
                          &#60;div><br />
                              &#60;h2>Latest
                  articles&#60;/h2><br />
                              {loading && &#60;p>Loading
                  data, please wait...&#60;/p>}<br />
                              {error && (<br />
                                  &#60;p>Whoops, something
                  went wrong!&#60;/p><br />
                              )}<br />
                              {articles.length > 0 &&
                  &#60;ArticleList items={articles} />}<br />
                          &#60;/div><br />
                      );<br />
                  };
                </p>
              </div>
            </div>
          </section>

          <!-- Пошук через форму -->
          <section class="section new-page">
            <h3 class="m-bottom-min">Пошук через форму</h3>

            <div class="m-bottom-min flex">
              <div>
                <p class="m-bottom-min">
                  <b>SearchForm</b> -
                  <i>неконтрольована форма</i> з одним
                  текстовим полем, значення якого потрібно
                  лише при поданні форми. Форма очікує один
                  пропс <b>onSearch</b> - колбек-функцію,
                  якій передасть значення поля при сабміті
                  форми.
                </p>
                <p class="m-bottom-min">
                  Якщо
                  <i>користувач нічого не ввів</i> у
                  текстове поле і намагається відправити
                  форму, потрібно повідомити його про це,
                  оскільки виконувати HTTP-запит без слова
                  для пошуку не потрібно. Для цього в
                  компоненті форми, в момент її
                  відправлення, перевірте вміст текстового
                  поля, і тільки в тому випадку, якщо
                  введено щось, викличте пропс
                  <b>onSearch</b>.
                </p>
                <p class="m-bottom-min">
                  Оскільки користувач сам вводить рядок для
                  пошуку статей, нам не потрібний ефект.
                  Отже, будемо писати код всередині функції
                  <b>handleSearch</b>, яка виконується при
                  сабміті форми. Робимо її
                  <i>асинхронною</i> і додаємо всередину
                  код, пов'язаний з HTTP-запитом.
                </p>
                <div class="border-box">
                  <p>
                    Зверніть увагу на дві речі перед кодом
                    HTTP-запиту в функції
                    <b>handleSearch</b>
                  </p>
                  <ul>
                    <li>
                      Перше - це <b>setArticles([])</b>, за
                      допомогою якого спеціально очищаємо
                      стан <b>articles</b> перед новим
                      запитом, щоб припинити відображення
                      "старого" списку посилань.
                    </li>
                    <li>
                      Друге - це <b>setError(false)</b>, щоб
                      скинути помилку перед наступним
                      запитом, на випадок, якщо вона була у
                      попередньому запиті.
                    </li>
                  </ul>
                </div>
              </div>
              <div class="bcg-box print-fs-14">
                <p>
                  <i>// src/components/App.jsx</i><br />
                  <br />
                  const App = () => {<br />
                      const [articles, setArticles] =
                  useState([]);<br />
                      const [loading, setLoading] =
                  useState(false);<br />
                      const [error, setError] =
                  useState(false);<br />
                      <br />
                      const <b>handleSearch</b> = async
                  (topic) => {<br />
                          try {<br />
                              setArticles([]);<br />
                              setError(false);<br />
                              setLoading(true);<br />
                              const data = await
                  fetchArticlesWithTopic(topic);<br />
                              setArticles(data);<br />
                          } catch (error) {<br />
                              setError(true);<br />
                          } finally {<br />
                              setLoading(false);<br />
                          }<br />
                      };<br />
                      <br />
                      return (<br />
                          &#60;div><br />
                              &#60;SearchForm
                  <b>onSearch={handleSearch}</b>
                  /><br />
                              {loading && &#60;Loader />}<br />
                              {error && &#60;Error />}<br />
                              {articles.length > 0 &&
                  &#60;ArticleList items={articles} />}<br />
                          &#60;/div><br />
                      );<br />
                  };
                </p>
              </div>
            </div>

            <div class="bcg-box print-fs-14">
              <p>
                <i>// src/components/SearchForm.jsx</i
                ><br />
                export const <b>SearchForm</b> = ({
                <b>onSearch</b> }) => {<br />
                    <br />
                const handleSubmit = (evt) => {<br />
                    evt.preventDefault();<br />
                    const form = evt.target;<br />
                    const <b>topic</b> =
                form.elements.topic.value;<br />
                   
                <i
                  >// Якщо текстове поле порожнє, виводимо
                  повідомлення і припиняємо виконання
                  функції.</i
                ><br />
                    if(form.elements.topic.value.trim() ===
                "") {<br />
                        alert("Please enter search
                term!")<br />
                        return;<br />
                    }<br />
                    <br />
                   
                <i
                  >// У протилежному випадку викликаємо
                  пропс і передаємо йому значення поля<br />
                      <b>onSearch</b>(<b>topic</b> )</i
                >;<br />
                    form.reset();<br />
                    };<br />
                <br />
                    return (<br />
                        &#60;form
                onSubmit={handleSubmit}><br />
                            &#60;input type="text"
                name="topic" placeholder="Пошук статей..."
                /><br />
                           
                &#60;button>Пошук&#60;/button><br />
                        &#60;/form><br />
                    ); };
              </p>
            </div>
          </section>

          <!-- Приклад -->
          <section class="section new-page">
            <h3 class="m-bottom-min">
              Приклад. Шаблоний код від Репети
            </h3>

            <div class="flex">
              <div
                class="bcg-box print-m-left-none print-fs-12"
              >
                <p>
                  <i>//src/components/App/App.jsx</i><br />
                  import { useEffect, useState } from
                  "react";<br />
                  import ArticleList from
                  "../ArticleList/ArticleList";<br />
                  import SearchForm from
                  "../SearchForm/SearchForm";<br />
                  import { fetchArticles } from
                  "../../articles-api";<br />
                  import css from "./App.module.css";<br />
                  <br />
                  export default function App() {<br />
                      const [articles, setArticles] =
                  useState([]);<br />
                      const [isLoading, setIsLoading] =
                  useState(false);<br />
                      const [error, setError] =
                  useState(false);<br />
                      const [page, setPage] =
                  useState(1);<br />
                      const [query, setQuery] =
                  useState("");<br />
                  <br />
                      const handleSearch = (newQuery) =>
                  {<br />
                          setQuery(newQuery);<br />
                          setPage(1);<br />
                          setArticles([]);<br />
                      };<br />
                  <br />
                      const handleLoadMore = () => {<br />
                          setPage(page + 1);<br />
                      };<br />
                  <br />
                      useEffect(() => {<br />
                          if (query === "") {<br />
                              return;<br />
                          }<br />
                      <br />
                          async function getArticles() {<br />
                              try {<br />
                                  setError(false);<br />
                                  setIsLoading(true);<br />
                                  const data = await
                  fetchArticles(query, page);<br />
                                  setArticles((prevArticles)
                  => {<br />
                                      return
                  [...prevArticles, ...data];<br />
                                  });<br />
                              } catch (error) {<br />
                                  setError(true);<br />
                              } finally {<br />
                                  setIsLoading(false);<br />
                              }<br />
                          }<br />
                          <br />
                          getArticles();<br />
                      }, [page, query]);<br />
                  <br />
                      return (<br />
                          &#60;div
                  className={css.container}><br />
                              &#60;h2>HTTP requests in
                  React&#60;/h2><br />
                              &#60;SearchForm
                  onSearch={handleSearch} /><br />
                              {error &&
                  <b>Oops! There was an error!</b>}<br />
                              {articles.length > 0 &&
                  &#60;ArticleList items={articles} />}<br />
                              {isLoading &&
                  <b>Please wait, loading articles...</b
                  >}<br />
                              {articles.length > 0 &&
                  !isLoading && (<br />
                                  &#60;button
                  onClick={handleLoadMore}><br />
                                      Load more articles<br />
                                  &#60;/button><br />
                              )}<br />
                          &#60;/div><br />
                      );<br />
                  }<br />
                  <!-- <br />
                // useEffect(() => {<br />
                // async function getArticles() {<br />
                // try {<br />
                // setIsLoading(true);<br />
                // const data = await
                fetchArticles("html");<br />
                // setArticles(data);<br />
                // } catch (error) {<br />
                // setError(true);<br />
                // } finally {<br />
                // setIsLoading(false);<br />
                // }<br />
                // }<br />
                <br />
                // getArticles();<br />
                // }, []);<br /> -->
                </p>
              </div>
              <div>
                <div
                  class="m-bottom-min bcg-box print-fs-14"
                >
                  <p>
                    <i>//src/articles-api.js</i><br />
                    import axios from "axios";<br />
                    <br />
                    axios.defaults.baseURL =<br />
                        "http://hn.algolia.com/api/v1";<br />
                    <br />
                    export const fetchArticles = async (<br />
                        searchQuery,<br />
                        currentPage<br />
                    ) => {<br />
                    <br />
                        const response = await
                    axios.get("/search", {<br />
                            params: {<br />
                                query: searchQuery,<br />
                                hitsPerPage: 10,<br />
                                page: currentPage,<br />
                            },<br />
                        });<br />
                        return response.data.hits;<br />
                    };
                  </p>
                </div>
                <div class="bcg-box print-fs-14">
                  <p>
                    <i
                      >//src/components/SearchForm/SearchForm.jsx</i
                    ><br />
                    import { Field, Form, Formik } from
                    "formik";<br />
                    import css from
                    "./SearchForm.module.css";<br />
                    <br />
                    export default function SearchForm({<br />
                            onSearch<br />
                        }) {<br />
                        return (<br />
                            &#60;Formik<br />
                                initialValues={{ query: ""
                    }}<br />
                                onSubmit={(values, actions)
                    => {<br />
                                   
                    onSearch(values.query);<br />
                                    actions.resetForm();<br />
                                }}<br />
                              ><br />
                                &#60;Form
                    className={css.form}><br />
                                    &#60;Field<br />
                                       
                    className={css.input}<br />
                                        type="text"<br />
                                        name="query"<br />
                                    /><br />
                                    &#60;button
                    type="submit"><br />
                                        Search<br />
                                    &#60;/button><br />
                                &#60;/Form><br />
                            &#60;/Formik><br />
                        );<br />
                    }
                  </p>
                </div>
              </div>
            </div>
          </section>
        </div>
      </section>

      <div class="next-page"></div>

      <!-- Redux -->
      <section id="redux" class="main-section">
        <div class="container">
          <h2 class="m-bottom center-text">Redux</h2>

          <!-- Redux (vanila) -->
          <section class="section">
            <h3 class="m-bottom-min center-text">
              Redux (vanila)
            </h3>

            <!-- Управління станом -->
            <section class="sub-section">
              <h4 class="m-bottom-min">
                Управління станом
              </h4>

              <div>
                <p>
                  Redux це бібліотека керування станом
                  програми, що стандартизує зберігання та
                  роботу із її станом.
                </p>
                <ul class="m-bottom-min">
                  <li>
                    <b>Передбачуваність результату</b> -
                    існує завжди одне джерело правди, стор
                    (сховище, store), що приховує у собі
                    стан програми та методи для роботи з
                    ним.
                  </li>
                  <li>
                    <b>Підтримуваність</b> - є набір правил
                    та кращих практик про те, як повинен
                    бути структурований код, що робить його
                    більш одноманітним та зрозумілим.
                  </li>
                  <li>
                    <b>Інструменти розробника</b> - зручне
                    розширення браузера в якому надається
                    максимум інформації про стан програми в
                    режимі реального часу.
                  </li>
                </ul>

                <div class="m-bottom-min flex">
                  <p>
                    <b>Бібліотека Redux</b> - набір функцій
                    для створення стора (сховища, store),
                    роботи зі станом програми (state) та
                    відправлення екшенів (дій, actions).
                  </p>
                  <div class="bcg-box">
                    <p><b>npm install redux</b></p>
                  </div>
                </div>

                <div class="m-bottom-min flex">
                  <p>
                    <b>Бібліотека React Redux</b> - набір
                    компонентів та хуків зв'язуючих
                    компонентів React та Redux стор (store).
                  </p>
                  <div class="bcg-box">
                    <p>
                      <b>npm install react-redux</b>
                    </p>
                  </div>
                </div>

                <p class="m-bottom-min">
                  <b>Стора</b> (сховище, store) відповідає
                  за централізоване зберігання всього стану
                  та надає набір правил та методів для його
                  зміни. Компонентам залишається викликати
                  методи для оновлення даних та підписатися
                  на оновлення. Потік даних у Redux завжди
                  односпрямований, від компонентів до стору,
                  та від стора до компонентів без
                  посередників.
                </p>

                <p>Алгоритм дії:</p>
                <ul class="m-bottom-min">
                  <li>
                    Користувач, працюючи з інтерфейсом,
                    ініціалізує відправку
                    <b>екшенів</b> (дій, actions).
                  </li>
                  <li>
                    <b>Стор</b> (store) викликає всі
                    оголошені <b>редюсери</b> (reducers),
                    функції для зміни стану, передаючи їм
                    поточний <b>стан</b> (state) та
                    <b>екшен</b> (дія, action).
                  </li>
                  <li>
                    <b>Стор</b> (store) зберігає оновлений
                    <b>стан</b> (state) повернутий з
                    <b>редюсерів</b> (reducers).
                  </li>
                  <li>
                    При оновленні <b>стану</b> (state)
                    повторно рендеруються залежні від нього
                    компоненти.
                  </li>
                </ul>
              </div>
            </section>

            <!-- Створення структури для Redux -->
            <section class="section">
              <h4 class="m-bottom-min">
                Створення структури для Redux
              </h4>

              <!-- Структура файлів проекту -->
              <div class="m-bottom flex">
                <div>
                  <p>
                    Для відокремлення логіки Redux від коду
                    компонентів, необхідно зробити папку
                    <b>src/redux</b> з кількома файлами.
                  </p>
                  <ul class="m-bottom-min">
                    <li>
                      <b>actions.js</b> - файл оголошення
                      екшенів програми
                    </li>
                    <li>
                      <b>reducer.js</b> - файл оголошення
                      функцій-редюсерів для оновлення стану
                    </li>
                    <li>
                      <b>constants.js</b> - файл для
                      зберігання констант (наприклад значень
                      фільтру статусу)
                    </li>
                    <li>
                      <b>selectors.js</b> - файл оголошення
                      функцій-селекторів
                    </li>
                    <li>
                      <b>store.js</b> - файл створення стор
                      Redux
                    </li>
                  </ul>
                  <p>
                    Якщо в додатку багато різних даних, то
                    підійде «<i>feature based</i>» підхід,
                    де під кожну сутність створюється окрема
                    папка усередині папки redux. Більше
                    файлів, але код логіки Redux поділений
                    на сутності та більш структурований.
                  </p>
                </div>
                <div class="bcg-box print-fs-14">
                  <p>
                    src/<br />
                        - components/<br />
                    <b>
                          - redux/<br />
                              - actions.js <br />
                              - reducer.js <br />
                              - constants.js<br />
                              - selectors.js<br />
                              - store.js<br />
                    </b>
                        - index.js
                  </p>
                </div>
                <div class="bcg-box print-fs-14">
                  <p>
                    src/<br />
                        - components/<br />
                    <b>
                          - redux/<br />
                              - tasks/<br />
                                  - actions.js <br />
                                  - reducer.js <br />
                                  - constants.js<br />
                                  - selectors.js<br />
                              - filters/<br />
                                  - actions.js <br />
                                  - reducer.js <br />
                                  - constants.js<br />
                                  - selectors.js<br />
                              - store.js<br />
                    </b>
                        - index.js
                  </p>
                </div>
              </div>

              <!-- Проектування стану -->
              <section class="inner-section">
                <h5 class="m-bottom-min">
                  Проектування стану
                </h5>

                <div class="flex">
                  <div>
                    <p class="m-bottom-min">
                      Інтерфейс програми повинен
                      ґрунтуватися на його стані. Необхідно
                      спроектувати стан програми, яка
                      міститиме найменшу кількість значень,
                      достатню для опису всього необхідного
                      функціоналу.
                    </p>
                    <p class="m-bottom-min">
                      <b>Стан</b> Redux це завжди
                      <i>об'єкт</i>, всередину якого
                      додаються властивості для стану
                      програми.
                    </p>
                    <p>
                      Стан об'являється у файлі
                      <b>reducers.js</b>
                    </p>
                  </div>
                  <div class="bcg-box print-fs-14">
                    <p>
                      const <b>initialState</b> = {<br />
                          tasks: [<br />
                              { id: 0, text: "Learn HTML &
                      CSS", completed: true },<br />
                              { id: 1, text: "Get good at
                      JS", completed: true },<br />
                              { id: 2, text: "Master React",
                      completed: false },<br />
                          ],<br />
                          filters: {<br />
                              status: "all",<br />
                          },<br />
                      };
                    </p>
                  </div>
                </div>
              </section>
            </section>

            <!-- Стор (store) -->
            <section class="sub-section new-page">
              <h4 class="m-bottom-min">Стор (store)</h4>

              <p class="m-bottom-min">
                Стор (store) - об'єкт, який містить повний
                стан програми, методи доступу до стану та
                відправлення екшенів. У програмі може бути
                лише один стор.
              </p>

              <div class="flex">
                <p>
                  Для створення стора є функція
                  <b>createStore()</b>, яка приймає кілька
                  параметрів та повертає новий об'єкт стора.
                </p>
                <div>
                  <div class="bcg-box">
                    <p>
                      <b
                        >createStore(reducer,
                        preloadedState, enhancer)</b
                      >
                    </p>
                  </div>
                </div>
              </div>

              <ul class="m-bottom-min">
                <li>
                  <b>reducer</b> - функція із логікою зміни
                  стану Redux. Обов'язковий параметр.
                </li>
                <li>
                  <b>preloadedState</b> - початковий стан
                  програми. Це має бути об'єкт тієї ж форми,
                  що й, як мінімум, частина стану.
                  Необов'язковий параметр.
                </li>
                <li>
                  <b>enhancer</b> - функція розширення
                  можливостей стору. Необов'язковий
                  параметр.
                </li>
              </ul>

              <div class="flex">
                <div
                  class="bcg-box print-m-left-none print-fs-14"
                >
                  <p>
                    <i>// src/redux/store.js</i><br />
                    <br />
                    <b
                      >import { createStore } from
                      "redux"</b
                    >;<br />
                    <br />
                    <i
                      >// Початкове значення стану Redux для
                      кореневого<br />
                      // редюсера, якщо не передати параметр
                      preloadedState.<br
                    /></i>
                    const <b>initialState</b> = {<br />
                        tasks: [<br />
                            { id: 0, text: "Learn HTML&CSS",
                    completed: true },<br />
                            { id: 1, text: "Get good at JS",
                    completed: true },<br />
                            { id: 2, text: "Master React",
                    completed: false },<br />
                        ],<br />
                        filters: {<br />
                            status: "all",<br />
                        },<br />
                    };<br />
                    <br />
                    <i
                      >// Поки що використовуємо редюсер
                      який<br />
                      // тільки повертає отриманий стан<br
                    /></i>
                    const <b>rootReducer</b> = (state =
                    <b>initialState</b>, action) => {<br />
                        return state;<br />
                    };<br />
                    <br />
                    export const
                    <b>store = createStore(rootReducer)</b>;
                  </p>
                </div>

                <div>
                  <p class="m-bottom-min">
                    Після створення стору необхідно зв'язати
                    його з компонентами React, щоб вони
                    могли отримувати доступ до стору та його
                    методів. Для цього у бібліотеці React
                    Redux є компонент
                    <b>Provider</b>, котрий чекає
                    однойменний пропс store. Для того щоб
                    будь-який компонент у додатку міг
                    використовувати стор, обертаємо
                    <b>Provider</b> все
                    <i>дерево компонентів</i>.
                  </p>

                  <div class="bcg-box print-fs-14">
                    <p>
                      <i>// src/main.jsx</i>
                      <br />
                      import React from 'react';<br />
                      import ReactDOM from
                      'react-dom/client';<br />
                      import { App } from
                      './components/App';<br />
                      import { store } from
                      "./redux/store";<br />
                      <br />
                      ReactDOM.createRoot(document.getElementById('root'))<br />
                          .render(<br />
                              &#60;React.StrictMode><br />
                                 
                      <b>&#60;Provider store={store}></b
                      ><br />
                                      &#60;App /><br />
                                  <b>&#60;/Provider></b
                      ><br />
                              &#60;/React.StrictMode><br />
                      );
                    </p>
                  </div>
                </div>
              </div>
            </section>

            <!-- Redux DevTools -->
            <section class="sub-section">
              <h4 class="m-bottom-min">Redux DevTools</h4>

              <p class="m-bottom-min">
                Інструменти розробника, розширення браузера,
                яке додає зручний візуальний інтерфейс для
                налагодження змін стану програми та стеження
                за потоком даних у Redux, від відправлення
                дій до зміни стану.
              </p>

              <div class="m-bottom-min flex">
                <p>
                  Бібліотека Redux DevTools дозволяє
                  ініціалізувати логіку Redux DevTools та
                  зв'язати її з розширенням в інструментах
                  розробника.
                </p>
                <div class="bcg-box">
                  <p>
                    <b
                      >npm install
                      @redux-devtools/extension</b
                    >
                  </p>
                </div>
              </div>

              <div class="m-bottom flex">
                <div>
                  <p class="m-bottom-min">
                    Імпортуємо функцію
                    <b>devToolsEnhancer</b> і використовуємо
                    її при створенні стора, передавши її
                    результат третім аргументом, замість
                    початкового стану.
                  </p>
                  <p>
                    Після запуску проекту командою
                    <b>npm start</b>, у стандартних
                    інструментах розробника з'явиться нова
                    вкладка Redux, при переході на яку
                    відкриються Redux DevTools зі списком
                    відправлених екшенів зліва та детальною
                    інформацією про стан та екшени праворуч.
                  </p>
                </div>
                <div class="bcg-box print-fs-15">
                  <p>
                    <i>// src/redux/store.js</i><br />
                    <br />
                    import { <b>devToolsEnhancer</b> } from
                    "@redux-devtools/extension";<br />
                    <br />
                    <i>// Попередній код</i><br />
                    <br />
                    <i>
                      // Створюємо розширення стора, щоб
                      додати<br />
                      інструменти розробника<br />
                    </i>
                    const <b>enhancer</b> =
                    <b>devToolsEnhancer</b>();<br />
                    <br />

                    export const store =
                    createStore(rootReducer,
                    <b>enhancer</b> );
                  </p>
                </div>
              </div>
            </section>

            <!-- Підписка на стор -->
            <section class="sub-section new-page">
              <h4 class="m-bottom-min">Підписка на стор</h4>

              <div class="m-bottom flex">
                <p class="">
                  Щоб отримати дані зі стору, компоненти
                  повинні підписатися на необхідні їм
                  частини стану Redux. Для цього у
                  бібліотеці React Redux є хук
                  <b>useSelector(selector)</b>. Аргументом
                  він приймає функцію, яка оголошує один
                  параметр <b>state</b> - весь об'єкт стану
                  Redux, який буде автоматично переданий
                  функції хуком useSelector. Ця функція
                  називається <i>селектором</i> і повинна
                  повернути тільки ту частину стану, яка
                  необхідна компоненту.
                </p>
                <div class="bcg-box print-fs-14">
                  <p>
                    <i>// Імпортуємо хук</i><br />
                    import { <b>useSelector</b> } from
                    "react-redux";<br />
                    <br />
                    const StatusFilter = () => {<br />
                       
                    <i
                      >// Отримуємо необхідну частину
                      стану</i
                    ><br />
                        const filter =
                    <b
                      >useSelector(<br />
                              state =>
                      state.filters.status<br />
                          )</b
                    >;<br />
                    };
                  </p>
                </div>
              </div>

              <!-- Функції-селектори -->
              <section class="inner-section">
                <h5 class="m-bottom-min">
                  Функції-селектори
                </h5>

                <p class="m-bottom-min">
                  Один і той же селектор може
                  використовуватися в декількох місцях
                  програми, що призводить до дублювання
                  коду.
                </p>

                <div class="m-bottom flex">
                  <p>
                    Щоб уникнути цього, всі
                    функції-селектори оголошуються в
                    окремому файлі, наприклад, в
                    <b>src/redux/selectors.js</b>, після
                    чого <i>імпортуються</i> до
                    <i>компонентів</i>.
                  </p>
                  <div class="bcg-box print-fs-14">
                    <p>
                      <i> // src/redux/selectors.js</i
                      ><br />
                      <br />
                      export const
                      <b>getTasks = state => state.tasks</b
                      >;<br />
                      export const
                      <b
                        >getStatusFilter = state =>
                        state.filters.status</b
                      >;
                    </p>
                  </div>
                </div>
              </section>
            </section>

            <!-- Екшени (actions) -->
            <section class="sub-section">
              <h4 class="m-bottom-min">Екшени (actions)</h4>

              <div class="m-bottom-min flex">
                <p class="">
                  <b>Екшени (actions)</b> - це об'єкти, які
                  передають дані з компонентів у стор, тим
                  самим сигналізуючи про те, яка подія
                  сталася в інтерфейсі. Вони являються
                  єдиним джерелом інформації для стору.
                </p>
                <div class="bcg-box print-fs-14">
                  <p>
                    <i>// src/redux/actions.js</i><br />
                    const action = {<br />
                        type: "Action type",<br />
                        payload: "Payload value",<br />
                    };<br />
                  </p>
                </div>
              </div>

              <div class="m-bottom-min flex">
                <div>
                  <p class="m-bottom-min">
                    Екшени повинні мати обов'язкову
                    властивість
                    <b>type</b> - рядок який описує тип
                    події в інтерфейсі.
                  </p>
                  <p class="m-bottom-min">
                    Крім властивості type структура об'єкта
                    може бути довільною, проте, дані
                    зазвичай передають у необов'язковій
                    властивості
                    <b>payload</b>.
                  </p>
                  <p class="m-bottom-min">
                    Властивість
                    <i>id: "Generated id"</i> буде
                    генерувати бєкенд, а без нього можна
                    через бібліотеку nanoid
                  </p>
                  <p>
                    Даними екшену може бути будь-яке
                    значення крім функцій та класів.
                  </p>
                </div>
                <div class="bcg-box print-fs-14">
                  <p>
                    const addTask = {<br />
                        type: "tasks/addTask",<br />
                        payload: {<br />
                            id: "Generated id",<br />
                            text: "User entered text",<br />
                            completed: false,<br />
                        },<br />
                    };
                  </p>
                </div>
              </div>

              <p class="m-bottom border-box">
                <b
                  >Найменування поля type у форматі
                  <i>domain/eventName</i>.</b
                >
                <b>Перше</b> це ім'я b
                <b>категорії (сутності)</b> до якої належить
                екшен (<i>tasks та filters</i>), зазвичай
                збігається з ім'ям властивості частини стану
                Redux, і <b>друге</b> це <b>подія</b>, яка
                описує екшен (<i
                  >addTask, deleteTask, toggleCompleted,
                  setStatusFilter</i
                >).
              </p>

              <!-- Генератори екшенів -->
              <section class="inner-section">
                <h5 class="m-bottom-min">
                  Генератори екшенів
                </h5>

                <div class="flex">
                  <p class="">
                    Екшени це <i>статичні об'єкти</i>,
                    значення властивості <b>payload</b> яких
                    неможливо задати динамічно.
                    <b>Генератори екшенів</b> (Action
                    Creators) - <i>функції</i>, які можуть
                    приймати <i>аргументи</i>, після чого
                    створюють та повертають екшени
                    <i
                      >з однаковим значенням властивості
                      type</i
                    >, але <i>різними payload</i>. Вони
                    можуть мати побічні ефекти, наприклад,
                    заповнювати властивості за замовчуванням
                    або генерувати унікальний ідентифікатор
                    об'єкта завдання.
                  </p>
                  <div class="bcg-box print-fs-14">
                    <p>
                      <i>// src/redux/actions.js</i><br />
                      <br />
                      import { nanoid } from "nanoid";<br />
                      <br />
                      export const addTask = text => {<br />
                         return
                      <b
                        >{ <br />
                               type: "tasks/addTask",<br />
                               payload: {<br />
                                   id: nanoid(),<br />
                                   completed: false,<br />
                                   text,<br />
                               },<br />
                            }</b
                      >;<br />
                      };
                    </p>
                  </div>
                </div>
              </section>

              <!-- Відправлення екшенів -->
              <section class="inner-section new-page">
                <h5 class="m-bottom-min">
                  Відправлення екшенів
                </h5>

                <div class="flex">
                  <p class="">
                    Для того щоб сповістити сторінку про те,
                    що в інтерфейсі відбулася якась подія,
                    необхідно відправити екшен за допомогою
                    хуку
                    <b>useDispatch()</b>. Він повертає
                    посилання на функцію надсилання екшенів
                    <b>dispatch</b>
                    з об'єкта створеного нами раніше стора
                    Redux.
                  </p>
                  <div class="bcg-box print-fs-14">
                    <p>
                      <i
                        >//
                        src/components/TaskForm/TaskForm.jsx</i
                      ><br />

                      <i>// Імпортуємо хук</i><br />
                      import { <b>useDispatch</b> } from
                      "react-redux";<br />
                      <i>// Імпортуємо генератор екшену</i
                      ><br />
                      import { addTask } from
                      "../../redux/actions";<br />
                      <br />
                      export const TaskForm = () => {<br />
                          ><br />
                          const
                      <b>dispatch = useDispatch()</b>;<br />
                      <br />
                          const handleSubmit = event => {<br />
                              event.preventDefault();<br />
                              const form = event.target;<br />
                             
                      <b
                        >dispatch(addTask(form.elements.text.value))</b
                      >;<br />
                              <br />
                              form.reset();<br />
                          };<br />
                      <br />
                          return (<br />
                              &#60;form
                      onSubmit={handleSubmit}>...&#60;/form><br />

                          );<br />

                      };
                    </p>
                  </div>
                </div>
              </section>
            </section>

            <!-- Редюсери (reducers) -->
            <section class="sub-section">
              <h4 class="m-bottom-min">
                Редюсери (reducers)
              </h4>

              <div class="m-bottom-min flex">
                <p>
                  <b>Редюсер (reducer)</b> - це функція, яка
                  приймає поточний стан та екшен як
                  аргументи і повертає новий стан. Редюсер
                  визначає, як змінюється стан програми у
                  відповідь на екшени, надіслані на стор.
                </p>
                <div class="bcg-box">
                  <p>(state, action) => nextState</p>
                </div>
              </div>

              <p class="m-bottom border-box">
                <b>Важливо!</b> Екшени описують тільки те,
                що сталося, а не як змінюється стан
                програми..
              </p>

              <!-- Кореневий редюсер -->
              <section class="inner-section">
                <h5 class="m-bottom-min">
                  Кореневий редюсер
                </h5>

                <div class="flex">
                  <div>
                    <p class="m-bottom-min">
                      У додатку завжди буде лише
                      <b>один</b>
                      <b>кореневий редюсер</b>, який
                      потрібно передати до
                      <b>createStore</b>
                      під час створення стора. Цей редюсер
                      відповідає за обробку всіх
                      відправлених екшенів та обчислення
                      нового стану.
                    </p>
                    <p class="m-bottom-min border-box">
                      <b>Важливо!</b> При ініціалізації
                      стора всім редюсерам у якості значення
                      стану передається <i>undefined</i>.
                      Тому кожному редюсеру необхідно
                      вказати значення
                      <i>за замовчуванням</i> для параметра
                      <b>state</b>, яке стане початковим
                      станом програми.
                      <b
                        >&#60;product&#62;&#60;/product&#62;</b
                      >.
                    </p>
                    <p class="m-bottom-min border-box">
                      <b>Цікаво!</b> Редюсер розрізняє
                      екшени за значенням властивості
                      <b>type</b>. Залежно від типу екшену
                      виконуватиметься <i>різна логіка</i
                      ><br />
                    </p>
                    <p><b>Правила редюсерів</b></p>
                    <ul class="">
                      <li>
                        Не можна змінювати аргументи (<b
                          >state</b
                        >
                        та <b>action</b>). Редюсери мають
                        лише обчислювати нове значення стану
                        з урахуванням цих аргументів.
                      </li>
                    </ul>
                  </div>
                  <div class="bcg-box print-fs-14">
                    <p>
                      <i>// src/redux/reducers.js</i><br />
                      import { statusFilters } from
                      "./constants";<br />
                      <br />
                      const initialState = {<br />
                              ...<br />
                      };<br />
                      <br />
                      export const rootReducer = (state =
                      initialState, action) => {<br />

                          switch (action.type) {<br />

                              case "tasks/addTask": {<br />
                                  return {<br />
                                    ...state,<br />
                                    tasks: [<br />
                                        ...state.tasks,<br />
                                        action.payload,<br />
                                    ],<br />
                                  };<br />
                              }<br />
                              default:<br />
                                  return state;<br />
                          }<br />
                      };
                    </p>
                  </div>
                </div>

                <ul class="">
                  <li>
                    Не можна змінювати стан (<b>state</b>).
                    Натомість редюсери повинні робити
                    оновлення, копіюючи існуючий стан та
                    вносячи зміни до копії.
                  </li>
                  <li>
                    Редюсери
                    <b>не повинні виконувати</b> жодних
                    <i>«побічних ефектів»</i>. Наприклад,
                    запуск таймера, виконання HTTP-запиту,
                    зміна значення поза функцією або її
                    аргументів, генерація випадкових чисел
                    чи рядків тощо.
                  </li>
                </ul>
              </section>

              <!-- Композиція редюсерів -->
              <section class="inner-section">
                <h5 class="m-bottom-min">
                  Композиція редюсерів
                </h5>

                <div class="m-bottom flex">
                  <div>
                    <p class="m-bottom-min">
                      Зазвичай редюсери поділяються
                      ґрунтуючись на частинах стану Redux
                      які вони оновлюють. Розділимо обробку
                      екшенів завдань та зміни фільтра на
                      два незалежних редюсера. Кожен редюсер
                      відповідатиме лише за свою частину
                      стану Redux, тому код оновлення стану
                      буде значно простіше.
                    </p>
                    <p class="m-bottom-min">
                      Тепер у нас є два окремі редюсери, але
                      при створенні стора необхідно передати
                      один кореневий редюсер, який
                      відповідає за весь стан Redux. Ми
                      можемо написати кореневий редюсер так,
                      щоб він просто викликав два інші
                      редюсери і передавав їм необхідну
                      частину стану та екшен. Це і є
                      <b>композиція редюсерів</b>.
                    </p>

                    <div class="border-box m-bottom-min">
                      <p class="m-bottom-min">
                        Щоб не створювати кореневий редюсер
                        вручну, у бібліотеці Redux є функція
                        <b>combineReducers</b>, яка робить
                        те саме, але коротше.
                      </p>

                      <div class="bcg-box">
                        <p>
                          import {
                          <b>combineReducers</b> } from
                          "redux";<br />
                          <br />
                          export const
                          <b>rootReducer</b> =
                          <b>combineReducers</b>({<br />
                              tasks:
                          <b>tasksReducer</b>,<br />
                              filters:
                          <b>filtersReducer</b>,<br />
                          });
                        </p>
                      </div>
                    </div>

                    <div class="border-box">
                      <p class="m-bottom-min">
                        <b>Слайси</b> (slices, шматочки) -
                        частина стану Redux, що групує інщі
                        дані, які відносятся до певного
                        інтерфейсу чи іншим даним,
                        пов'язаних спільною логікою. По
                        факту - слайси - це властивості
                        стану першого рівня вкладеності.
                      </p>
                      <div class="flex">
                        <p>
                          Можна сказати, що композиція
                          редьюсерів залежить від слайсів
                        </p>
                        <div class="bcg-box">
                          <p>
                            const initialState = {<br />
                                <b>tasks</b>: [ {...}, {...}
                            ],<br />
                                <b>filters</b>: {<br />
                                    status: "all",<br />
                                },<br />
                            };
                          </p>
                        </div>
                      </div>
                    </div>
                  </div>
                  <div class="bcg-box print-fs-14">
                    <p>
                      <i>// src/redux/reducers.js</i><br />
                      <br />
                      const tasksInitialState = [<br />
                          ...
                      <i>// дані початкового стану</i><br />
                      ];<br />
                      <br />
                      const <b>tasksReducer</b> = (state =
                      tasksInitialState, action) => {<br />
                          switch (action.type) {<br />
                              case "tasks/addTask":<br />
                                  return [...state,
                      action.payload];<br />
                              case "tasks/deleteTask":<br />
                                  return state.filter(task
                      => task.id !== action.payload);<br />
                              case
                      "tasks/toggleCompleted":<br />
                                  return state.map(task =>
                      {<br />
                                      if (task.id !==
                      action.payload) {<br />
                                          return task;<br />
                                      }<br />
                                      return { ...task,
                      completed: !task.completed };<br />
                                  });<br />
                              default:<br />
                                  return state;<br />
                          }<br />
                      };<br />
                      <br />
                      const filtersInitialState = {<br />
                          status: statusFilters.all,<br />
                      };<br />
                      <br />
                      const <b>filtersReducer</b> = (state =
                      filtersInitialState, action) => {<br />
                          switch (action.type) {<br />
                              case
                      "filters/setStatusFilter":<br />
                                  return {<br />
                                      ...state,<br />
                                      status:
                      action.payload,<br />
                                  };<br />
                              default:<br />
                                  return state;<br />
                          }<br />
                      };<br />
                      <br />
                      export const <b>rootReducer</b> =
                      (state = {}, action) => {<br />
                          return {<br />
                              tasks:
                      tasksReducer(state.tasks, action),<br />
                              filters:
                      filtersReducer(state.filters,
                      action),<br />
                          };<br />
                      };
                    </p>
                  </div>
                </div>
              </section>
            </section>

            <!-- Висновки -->
            <section class="sub-section">
              <h4 class="m-bottom-min">Висновки</h4>

              <p>Алгоритм використання Redux</p>
              <ul class="" style="min-width: max-content">
                <li>Створити <b>Store</b></li>
                <li>Оголосити <b>початковий стан</b></li>
                <li>
                  Створити базовий Reducer
                  (<b>rootReducer</b>)
                </li>
                <li>
                  <b>Provider</b>'ом огорнути <b>App</b> (у
                  main.js) та передати
                  <b>store</b>
                </li>
                <li>Створити компонент</li>
                <li>
                  Оголосити <b>useSelector</b> у компоненті
                  для підписання на зміну частини стану
                </li>
                <li>Оголосити <b>actions</b></li>
                <li>
                  <b>dispatch</b> actions із компоненту при
                  подіях
                </li>
                <li>
                  Обробити <b>actions</b> у <i>reducer</i>'і
                </li>
              </ul>
            </section>

            <!-- Приклад -->
            <section class="sub-section no-break new-page">
              <h4 class="m-bottom-min center-text">
                Приклад
              </h4>

              <div class="flex print-fs-10">
                <div style="margin-right: auto">
                  <!-- <p>Стан (Store)</p> -->
                  <div
                    class="bcg-box print-m-left-none print-fs-12"
                    style="
                      margin-right: auto;
                      margin-bottom: 4px;
                    "
                  >
                    <p>
                      <i>// src/redux/store.js</i><br />

                      import { createStore, combineReducers
                      } from "redux";<br />
                      import { balanceReducer } from
                      "./balanceSlice";<br />
                      import { localeReducer } from
                      "./localeSlice";<br />
                      const rootReducer =
                      combineReducers({<br />
                          balance: balanceReducer,<br />
                          locale: localeReducer,<br />
                      });<br />
                      export const store =
                      createStore(rootReducer);
                    </p>
                  </div>

                  <!-- <p>balanceSlice</p> -->
                  <div
                    class="bcg-box print-m-left-none print-fs-12"
                    style="
                      margin-right: auto;
                      margin-bottom: 4px;
                    "
                  >
                    <p>
                      <i>// src/redux/balanceSlice.js </i
                      ><br />
                      export const deposit = (value) => {<br />
                          return {<br />
                              type: "balance/deposit",<br />
                              payload: value,<br />
                          };<br />
                      };<br />
                      export const withdraw = (value) =>
                      {<br />
                          return {<br />
                              type: "balance/withdraw",<br />
                              payload: value,<br />
                          };<br />
                      };<br />
                      export const balanceReducer = (<br />
                              state = {value: 1000 },<br />
                              action<br />
                          ) => {<br />
                              switch (action.type) {<br />
                                  case "balance/deposit":<br />
                                      return {<br />
                                          ...state,<br />
                                          value: state.value
                      + action.payload,<br />
                                      };<br />
                                  case
                      "balance/withdraw":<br />
                                      return {<br />
                                          ...state,<br />
                                          value: state.value
                      - action.payload,<br />
                                      };<br />
                                  default:<br />
                                      return state;<br />
                          }<br />
                      };
                    </p>
                  </div>

                  <!-- <p>localeSlice.js</p> -->
                  <div
                    class="bcg-box print-m-left-none print-fs-12"
                    style="margin-right: auto"
                  >
                    <p>
                      <i>// src/redux/localeSlice.js </i
                      ><br />
                      export const changeLang = (newLang) =>
                      {<br />
                          return {<br />
                              type: "locale/changeLang",<br />
                              payload: newLang,<br />
                          };<br />
                      };<br />
                      export const localeReducer = (<br />
                              state = { lang: "uk" },<br />
                              action<br />
                          ) => {<br />
                              switch (action.type) {<br />
                                  case
                      "locale/changeLang":<br />
                                      return {<br />
                                          ...state,<br />
                                          lang:
                      action.payload,<br />
                                      };<br />
                                  default:<br />
                                      return state;<br />
                          }<br />
                      };
                    </p>
                  </div>

                  <!-- <p>main.jsx</p>
                  <div class="bcg-box">
                    <p>
                      <i>// src/main.jsx</i>

                      import React from "react";<br />
                      import ReactDOM from "react-dom/client";<br />
                      import App from "./components/App";<br />
                      import "modern-normalize";<br />
                      import "./index.css";<br />
                      import { Provider } from "react-redux";<br />
                      import { store } from "./redux/store";<br />
                      <br />
                      ReactDOM.createRoot(document.getElementById("root")).render(<br />
                          &#60;React.StrictMode ><br />
                              &#60;Provider store="{store}" ><br />
                                  &#60;App /><br />
                              &#60;/Provider ><br />
                          &#60;/React.StrictMode ><br />
                      );
                    </p>
                  </div> -->
                </div>

                <div class="print-m-left-none">
                  <!-- <p>App.jsx</p> -->
                  <div
                    class="bcg-box print-fs-12"
                    style="margin-bottom: 4px"
                  >
                    <p>
                      <i>// src/components/App/App.jsx</i
                      ><br />
                      import LangSwitcher from
                      "./LangSwitcher";<br />
                      import Balance from "./Balance";<br />
                      import { useSelector } from
                      "react-redux";<br />
                      export default function App() {<br />
                          const lang = useSelector((state)
                      => state.locale.lang);<br />
                          return (<br />
                              &#60;div><br />
                                  &#60;h2>Redux&#60;/h2><br />
                                  &#60;Balance /><br />
                                  &#60;LangSwitcher /><br />
                                  &#60;p>Selected lang:
                      {lang}&#60;/p><br />
                              &#60;/div><br />
                          );<br />
                      }
                    </p>
                  </div>

                  <!-- <p>Balance</p> -->
                  <div
                    class="bcg-box print-fs-12"
                    style="margin-bottom: 4px"
                  >
                    <p>
                      <i
                        >//
                        src/components/Balance/Balance.jsx</i
                      ><br />

                      import { useDispatch, useSelector }
                      from "react-redux";<br />
                      import { deposit, withdraw } from
                      "../redux/balanceSlice";<br />
                      import { useState } from "react";<br />
                      <br />
                      export default function Balance() {<br />
                          const dispatch = useDispatch();<br />
                          const balance =
                      useSelector((state) =>
                      state.balance.value);<br />
                          const [value, setValue] =
                      useState(0);<br />
                          return (<br />
                              &#60;div><br />
                                  &#60;p>Balance:
                      {balance}&#60;/p><br />
                                  &#60;input<br />
                                      type="number"<br />
                                      value={value}<br />
                                      onChange={(e) =>
                      setValue(Number(e.target.value))}<br />
                                  /><br />
                                  &#60;button onClick={() =>
                      dispatch(deposit(value))}><br />
                                      Deposit credits<br />
                                  &#60;/button><br />
                                  &#60;button onClick={() =>
                      dispatch(withdraw(value))}><br />
                                      Withdraw credits<br />
                                  &#60;/button><br />
                              &#60;/div><br />
                          );<br />
                      }
                    </p>
                  </div>

                  <!-- <p>LangSwitcher</p> -->
                  <div class="bcg-box print-fs-12">
                    <p>
                      <i
                        >//
                        src/components/LangSwitcher/LangSwitcher.jsx</i
                      ><br />

                      import { useDispatch, useSelector }
                      from "react-redux";<br />
                      import { changeLang } from
                      "../redux/localeSlice";<br />
                      <br />
                      export default function LangSwitcher()
                      {<br />
                          const dispatch = useDispatch();<br />
                          const lang = useSelector((state)
                      => state.locale.lang);<br />
                          return (<br />
                              &#60;div><br />
                                  &#60;select<br />
                                      value={lang}<br />
                                      onChange={(e) =>
                      dispatch(<br />
                                         
                      changeLang(e.target.value)<br />
                                      )}<br />
                                  ><br />
                                      &#60;option
                      value="en">EN&#60;/option><br />
                                      &#60;option
                      value="uk">UK&#60;/option><br />
                                  &#60;/select><br />
                              &#60;/div><br />
                          );<br />
                      }
                    </p>
                  </div>
                </div>
              </div>
            </section>
          </section>

          <!-- Redux Toolkit -->
          <section class="section new-page">
            <h3 class="m-bottom-min center-text">
              Redux Toolkit
            </h3>

            <!-- Загальне -->
            <div class="m-bottom">
              <p class="m-bottom-min">
                <b>Redux Toolkit</b> - бібліотека для
                ефективної розробки з використанням Redux,
                яка призначена для стандартизації та
                спрощення написання логіки Redux.
              </p>

              <div style="display: flex">
                <div>
                  <p><b>Недоліки ванільного Redux</b></p>
                  <ul class="">
                    <li>
                      Надмірно складний процес налаштування
                      стора.
                    </li>
                    <li>
                      Необхідність встановлення стандартного
                      набору додаткових бібліотек для
                      розширення можливостей Redux.
                    </li>
                    <li>
                      Великий обсяг шаблонного коду
                      створення екшенів, редюсерів тощо.
                    </li>
                  </ul>
                </div>
                <div>
                  <p><b>Переваги Redux Toolkit</b></p>
                  <ul class="">
                    <li>
                      Дозволяє зосередитися на написанні
                      основної логіки програми, не
                      витрачаючи час на налаштування.
                    </li>
                    <li>
                      Містить утиліти для спрощення основних
                      завдань. Таких як налаштування стора,
                      створення екшенів та редюсерів,
                      іммутабельне оновлення даних та багато
                      чого іншого.
                    </li>
                    <li>
                      Надає стандартний набір налаштувань
                      для стора і включає в себе бібліотеки,
                      що часто використовуються з екосистеми
                      Redux.
                    </li>
                  </ul>
                </div>
              </div>
            </div>

            <!-- Встановлення -->
            <section class="sub-section">
              <h4 class="m-bottom-min">Встановлення</h4>

              <div class="flex">
                <div>
                  <p>
                    Використовуючи <b>Redux Toolkit</b>,
                    <i>немає необхідності</i> додавати в
                    проект пакет <b>redux</b>, крім
                    випадків, коли вам необхідна функція
                    <b>combineReducers()</b>.
                  </p>
                  <ul>
                    <li>
                      <b>@reduxjs/toolkit</b> - написання
                      <i>логіки</i> Redux
                    </li>
                    <li>
                      <b>react-redux</b> - зв'язок
                      <i>стора</i> з <i>компонентами</i>.
                    </li>
                  </ul>
                </div>
                <div>
                  <div class="m-bottom-min bcg-box">
                    <p>
                      <b>npm install @reduxjs/toolkit </b>
                    </p>
                  </div>
                  <div class="bcg-box">
                    <p>
                      <b
                        >npm install @reduxjs/toolkit
                        react-redux
                      </b>
                    </p>
                  </div>
                </div>
              </div>
            </section>

            <!-- configureStore -->
            <section class="section">
              <h4 class="m-bottom-min">configureStore</h4>

              <div class="m-bottom-min flex">
                <div>
                  <p class="m-bottom-min">
                    Функція
                    <b>configureStore(options)</b> обертає
                    оригінальний <b>createStore()</b>.
                  </p>
                  <p class="m-bottom-min">
                    Очікує єдиним аргументом
                    <i>об'єкт параметрів</i> та налаштовує
                    деякі корисні інструменти розробки як
                    частина процесу створення стора.
                  </p>
                  <p>
                    На перший погляд, практично одне й теж,
                    проте, відразу були налаштовані
                    інструменти розробника (Redux DevTools)
                    та деякі інші корисні функції, наприклад
                    перевірка поширених помилок, таких як
                    мутація стану в редюсерах чи
                    використання невалідних значень у стані.
                  </p>
                </div>
                <div class="bcg-box print-fs-15">
                  <p>
                    <i>// src/redux/store.js</i><br />
                    <i
                      >//=============== Before
                      ==================</i
                    ><br />
                    import { createStore } from "redux";<br />
                    import { devToolsEnhancer } from
                    "@redux-devtools/extension";<br />
                    import { rootReducer } from
                    "./reducer";<br />
                    <br />
                    const enhancer = devToolsEnhancer();<br />
                    export const store =
                    createStore(rootReducer, enhancer);<br />
                    <br />
                    <i
                      >//=============== After
                      ==================</i
                    ><br />
                    import { <b>configureStore</b> } from
                    "@reduxjs/toolkit";<br />
                    import { <b>rootReducer</b> } from
                    "./reducer";<br />
                    <br />
                    const store =
                    <b>configureStore</b>({<br />
                        reducer: <b>rootReducer</b>,<br />
                    });
                  </p>
                </div>
              </div>

              <div class="m-bottom-min flex">
                <p>
                  Функція <b>configureStore()</b> може
                  автоматично створити кореневий редюсер.
                  Для цього необхідно передати властивості
                  reducer об'єкт тієї ж форми що в
                  <b>combineReducers</b>.
                </p>
                <div class="bcg-box print-fs-15">
                  <p>
                    <i>// src/redux/store.js </i><br />
                    import { <b>configureStore</b> } from
                    "@reduxjs/toolkit";<br />
                    import { <b>tasksReducer</b>,
                    <b>filtersReducer</b> } from
                    "./reducers";<br />
                    <br />
                    export const store =
                    <b>configureStore</b>({<br />
                        reducer: {<br />
                            tasks:
                    <b>tasksReducer</b>,<br />
                            filters:
                    <b>filtersReducer</b>,<br />
                        },<br />
                    });
                  </p>
                </div>
              </div>

              <div class="bcg-box print-fs-15 new-page">
                <p>
                  <i>// src/redux/reducers.js</i><br />
                  <i
                    >//=============== Before
                    ================================</i
                  ><br />
                  import { combineReducers } from
                  "redux";<br />
                  import { statusFilters } from
                  "./constants";<br />
                  <br />
                  const tasksInitialState = [];<br />
                  const filtersInitialState = {<br />
                      status: statusFilters.all,<br />
                  };<br />
                  <br />
                  const tasksReducer = (state =
                  tasksInitialState, action) => {
                  <i>// Reducer code</i> };<br />
                  const filtersReducer = (state =
                  filtersInitialState, action) => {
                  <i>// Reducer code</i> };<br />
                  <br />
                  export const rootReducer =
                  combineReducers({<br />
                      tasks: tasksReducer,<br />
                      filters: filtersReducer,<br />
                  });<br />
                  <br />
                  <i
                    >//=============== After
                    ================================</i
                  ><br />
                  import { statusFilters } from
                  "./constants";<br />
                  <br />
                  const tasksInitialState = [];<br />
                  const filtersInitialState = {<br />
                      status: statusFilters.all,<br />
                  };<br />
                  <br />
                  export const <b>tasksReducer</b> = (state
                  = tasksInitialState, action) => {
                  <i>// Reducer code</i> };<br />
                  <br />
                  export const <b>filtersReducer</b> =
                  (state = filtersInitialState, action) => {
                  <i>// Reducer code</i> };
                </p>
              </div>
            </section>

            <!-- createAction -->
            <section class="sub-section">
              <h4 class="m-bottom-min">createAction</h4>

              <div class="m-bottom-min flex">
                <p>
                  Функція
                  <b>createAction(type)</b> спрощує процес
                  оголошення екшенів. В якості аргументу
                  вона приймає
                  <i>рядок який описує тип дії</i> та
                  повертає <i>генератор екшену</i>.
                </p>
                <div class="bcg-box print-fs-12">
                  <p>
                    <i>// src/redux/actions.js</i><br />
                    <i
                      >//=============== Before
                      ==============</i
                    ><br />
                    const addTask = text => {<br />
                        return { type: "tasks/AddTask",
                    payload: text };<br />
                    };<br />
                    <br />
                    console.log(addTask("Learn Redux
                    Toolkit"));<br />
                    <i
                      >// {type: "tasks/addTask", payload:
                      "Learn Redux Toolkit"}</i
                    ><br />
                    <br />
                    <i
                      >//=============== After
                      ===============</i
                    ><br />
                    import { <b>createAction</b> } from
                    "@reduxjs/toolkit";<br />
                    <br />
                    export const addTask =
                    <b>createAction</b
                    >(<i>"tasks/AddTask"</i>);<br />
                    export const deleteTask =
                    <b>createAction</b
                    >(<i>"tasks/deleteTask"</i>);<br />
                    export const toggleCompleted =
                    <b>createAction</b
                    >(<i>"tasks/toggleCompleted"</i>);
                    <br />
                    <br />
                    console.log(addTask("Learn Redux
                    Toolkit"));<br />
                    <i
                      >// {type: "tasks/addTask", payload:
                      "Learn Redux Toolkit"}</i
                    >
                  </p>
                </div>
              </div>

              <!-- Отримання типу екшену -->
              <section class="inner-section">
                <h5 class="m-bottom-min">
                  Отримання типу екшену
                </h5>

                <div class="m-bottom-min flex">
                  <p>
                    Для отримання типу екшену у генератора
                    екшену є властивість
                    <b>type</b> та метод
                    <b>toString()</b> функції
                  </p>
                  <div class="bcg-box print-fs-12">
                    <p>
                      import { createAction } from
                      "@reduxjs/toolkit";<br />
                      <br />
                      const addTask =
                      createAction("tasks/AddTask");<br />
                      <br />
                      console.log(addTask.<b>type</b>);
                      <i>// "tasks/AddTask"</i><br />
                      console.log(addTask.<b>toString()</b>);
                      <i>// "tasks/AddTask"</i>
                    </p>
                  </div>
                </div>

                <div class="flex new-page">
                  <p>
                    У редюсер імпортуються екшени та
                    використовується їх властивість type для
                    заміни рядків всередині інструкції
                    <b>switch</b>.
                  </p>
                  <div class="bcg-box print-fs-12">
                    <p>
                      <i>// src/redux/reducers.js</i><br />
                      import { addTask, deleteTask,
                      toggleCompleted } from "./actions";<br />
                      <br />
                      export const tasksReducer = (state =
                      tasksInitialState, <b>action</b>) =>
                      {<br />
                          switch (<b>action.type</b>) {<br />
                              case
                      <b>addTask.type</b>:<br />
                                  return [...state,
                      action.payload];<br />
                              case
                      <b>deleteTask.type</b>:<br />
                                  return state.filter(task
                      => task.id !== action.payload);<br />
                              case
                      <b>toggleCompleted.type</b>:<br />
                                  return state.map(task =>
                      {<br />
                                      if (task.id !==
                      action.payload) {<br />
                                          return task;<br />
                                      }<br />
                                      return { ...task,
                      completed: !task.completed };<br />
                                  });<br />
                              default:<br />
                                  return state;<br />
                          }<br />
                      };
                    </p>
                  </div>
                </div>
              </section>

              <!-- Вміст payload -->
              <section class="inner-section">
                <h5 class="m-bottom-min">Вміст payload</h5>

                <div class="m-bottom flex">
                  <div>
                    <p class="m-bottom-min">
                      За замовчуванням
                      <i>генератори</i> екшенів приймають
                      <i>один аргумент</i>, який стає
                      значенням властивості <b>payload</b>.
                      Якщо потрібно написати додаткову
                      логіку створення значення payload,
                      наприклад, додати унікальний
                      ідентифікатор, createAction можна
                      передати
                      <i
                        >другий, необов'язковий аргумент –
                        функцію створення екшену</i
                      >.
                    </p>
                    <p>
                      Аргументи генератора екшену будуть
                      передані функції
                      <b>prepareAction</b>, яка повинна
                      повернути
                      <i>об'єкт із властивістю</i>
                      <b>payload</b>. Властивість
                      <b>type</b> буде
                      <i>додано автоматично</i>.
                    </p>
                  </div>
                  <div>
                    <div
                      class="m-bottom-min bcg-box print-fs-12"
                    >
                      <p>
                        createAction(type,
                        <b>prepareAction</b>)
                      </p>
                    </div>
                    <div class="bcg-box print-fs-12">
                      <p>
                        <i>// src/redux/actions.js</i><br />
                        import { createAction, nanoid } from
                        "@reduxjs/toolkit";<br />
                        <br />
                        export const addTask =
                        createAction("tasks/addTask",
                        <b
                          >text => {<br />
                              return {<br />
                                  payload: {<br />
                                      text,<br />
                                      id: nanoid(),<br />
                                      completed: false,<br />
                                  },<br />
                              };<br />
                          }</b
                        >
                        );
                      </p>
                    </div>
                  </div>
                </div>
              </section>
            </section>

            <!-- createReducer -->
            <section class="sub-section">
              <h4 class="m-bottom-min">createReducer</h4>

              <div class="flex">
                <p>
                  Будь-який редюсер отримує
                  <i>стан Redux</i> і <i>екшен</i>,
                  перевіряє <i>тип екшену</i> всередині
                  інструкції <b>switch</b> і виконує
                  відповідну логіку оновлення стану для
                  даного екшену. До того ж, редюсер визначає
                  початкове значення стану та повертає
                  отриманий стан, якщо не повинен обробляти
                  екшен. Функція
                  <b>createReducer()</b> спрощує процес
                  оголошення редюсерів.
                </p>
                <div>
                  <div
                    class="m-bottom-min bcg-box print-fs-15"
                  >
                    <p>
                      createReducer(initialState,
                      builderCallback)
                    </p>
                  </div>
                  <div
                    class="m-bottom-min bcg-box print-fs-15"
                  >
                    <p>
                      createReducer({}, builder => {<br />
                          builder.addCase(actionType,
                      (state, action) => {});<br />
                      });
                    </p>
                  </div>
                  <div
                    class="m-bottom-min bcg-box print-fs-15"
                  >
                    <p>addCase(action, reducer)</p>
                  </div>
                </div>
              </div>

              <div>
                <ul class="m-bottom-min">
                  <li>
                    <b>initialState</b> - початковий стан
                    редюсера.
                  </li>
                  <li>
                    <b>builderCallback</b> - функція
                    зворотнього виклику, за допомогою якої
                    визначається редюсер для кожного екшена.
                  </li>
                </ul>

                <p>
                  Функція зворотнього виклику
                  <b>builderCallback</b>
                  <i>оголошує</i> один параметр
                  <b>builder</b> -
                  <i>об'єкт із методами</i>, за допомогою
                  яких (<b>addCase</b>) ми реєструємо
                  редюсери для екшенів. Тобто кожен
                  <b>case</b> з <b>switch</b> стає викликом
                  <b>addCase</b>, для якого написаний
                  власний міні-редюсер.
                </p>
              </div>

              <div class="m-bottom-min flex new-page">
                <div class="bcg-box print-fs-15">
                  <p>
                    <i>// src/redux/reducers.js</i><br />
                    import { createReducer } from
                    "@reduxjs/toolkit";<br />
                    import { statusFilters } from
                    "./constants";<br />
                    import { addTask, deleteTask,
                    toggleCompleted } from "./actions";<br />
                    <br />
                    const tasksInitialState = [];<br />
                    <i
                      >//=============== Before
                      ========================</i
                    ><br />
                    const tasksReducer = (state =
                    tasksInitialState, action) => {<br />
                        switch (action.type) {<br />
                            case addTask.type:<br />
                            // case logic<br />
                            case deleteTask.type:<br />
                            // case logic<br />
                            case toggleCompleted.type:<br />
                            // case logic<br />
                            default:<br />
                                return state;<br />
                        }<br />
                    };<br />
                    <br />
                    <i
                      >//=============== After
                      ========================</i
                    ><br />
                    export const tasksReducer =
                    <b
                      >createReducer(tasksInitialState,
                      builder => {</b
                    ><br />
                        <b>builder</b><br />
                            .<b>addCase</b>(addTask, (state,
                    action) => {<br />
                                return [...state,
                    action.payload];<br />
                            })<br />
                            .<b>addCase</b>(deleteTask,
                    (state, action) => {<br />
                                return state.filter(task =>
                    task.id !== action.payload);<br />
                            })<br />
                            .<b>addCase</b>(toggleCompleted,
                    (state, action) => {<br />
                                return state.map(task =>
                    {<br />
                                    if (task.id !==
                    action.payload) {<br />
                                        return task;<br />
                                    }<br />
                                    return {<br />
                                        ...task,<br />
                                        completed:
                    !task.completed,<br />
                                    };<br />
                                });<br />
                          });<br />
                    });<br />
                    <br />
                    export const filtersReducer =
                    createReducer(filtersInitialState,
                    builder => {<br />
                        builder.addCase(setStatusFilter,
                    (state, action) => {<br />
                            return {<br />
                                ...state,<br />
                                status: action.payload,<br />
                            };<br />
                        });<br />
                    });
                  </p>
                </div>
              </div>

              <!-- Бібліотека Immer -->
              <section class="inner-section new-page">
                <h5 class="m-bottom-min">
                  Бібліотека Immer
                </h5>

                <div class="flex">
                  <p>
                    Redux Toolkit «під капотом» використовує
                    бібліотеку Immer, яка значно спрощує
                    логіку роботи зі станом, дозволяючи
                    писати код оновлення стану в редюсері
                    так, ніби ми безпосередньо змінювали
                    стан. Насправді редюсери отримують копію
                    стану, а Immer перетворює всі мутації на
                    еквівалентні операції оновлення.
                  </p>
                  <div class="bcg-box">
                    <p>
                      <i>// src/redux/reducers.js</i><br />
                      <br />
                      export const tasksReducer =
                      createReducer(tasksInitialState,
                      builder => {<br />
                          builder<br />
                              .addCase(addTask, (state,
                      action) => {<br />
                                 
                      <i
                        >// ✅ Immer замінить це на операцію
                        оновлення</i
                      ><br />
                                 
                      state.push(action.payload);<br />
                              })<br />
                              .addCase(deleteTask, (state,
                      action) => {<br />
                                 
                      <i
                        >// ✅ Immer замінить це на операцію
                        оновлення</i
                      ><br />
                                  const index =
                      state.findIndex(task => task.id ===
                      action.payload);<br />
                                  state.splice(index, 1);<br />
                              })<br />
                              .addCase(toggleCompleted,
                      (state, action) => {<br />
                                 
                      <i
                        >// ✅ Immer замінить це на операцію
                        оновлення</i
                      ><br />
                                  for (const task of state)
                      {<br />
                                      if (task.id ===
                      action.payload) {<br />
                                          task.completed =
                      !task.completed;<br />
                                      }<br />
                                  }<br />
                              });<br />
                      });<br />
                      export const filtersReducer =
                      createReducer(filtersInitialState,
                      builder => {<br />
                          builder.addCase(setStatusFilter,
                      (state, action) => {<br />
                             
                      <i
                        >// ✅ Immer замінить це на операцію
                        оновлення</i
                      ><br />
                              state.status =
                      action.payload;<br />
                          });<br />
                      });
                    </p>
                  </div>
                </div>
              </section>

              <!-- Зміна або оновлення -->
              <section class="inner-section">
                <h5 class="m-bottom-min">
                  Зміна або оновлення
                </h5>

                <div class="flex">
                  <p>
                    Іноді код іммутабельного оновлення стану
                    лаконічніший, ніж його альтернатива, що
                    «змінює». Наприклад, у редюсері обробки
                    екшену видалення завдання. У такому разі
                    необхідно обов'язково повернути новий
                    стан.
                  </p>
                  <div class="bcg-box">
                    <p>
                      <i>// src/redux/reducers.js</i><br />
                      <br />
                      export const tasksReducer =
                      createReducer(tasksInitialState,
                      builder => {<br />
                         builder.addCase(deleteTask, (state,
                      action) => {<br />
                            <i>// ❌ Не правильно</i><br />
                            // state.filter(task => task.id
                      !== action.payload)<br />
                            <i>// ✅ Правильно</i><br />
                            return state.filter(task =>
                      task.id !== action.payload);<br />
                         });<br />
                      });
                    </p>
                  </div>
                </div>
              </section>

              <!-- Зміна чи повернення -->
              <section class="inner-section">
                <h5 class="m-bottom-min">
                  Зміна чи повернення
                </h5>

                <div class="flex">
                  <p>
                    Один із підводних каменів бібліотеки
                    Immer полягає в тому, що в коді одного
                    редюсера можна лише або мутувати стан,
                    або повернути оновлений, але не те й
                    інше водночас.
                  </p>
                  <div class="bcg-box">
                    <p>
                      <i>// src/redux/reducers.js</i><br />
                      <br />
                      const reducer = createReducer([],
                      builder => {<br />
                          builder.addCase(doSomething,
                      (state, action) => {<br />
                             
                      <i
                        >// ❌ Так робити не можна, буде
                        згенеровано виняток</i
                      ><br />
                              state.push(action.payload);<br />
                              return state.map(value =>
                      value * 2);<br />
                          });<br />
                      });
                    </p>
                  </div>
                </div>
              </section>
            </section>

            <!-- createSlice -->
            <section class="sub-section">
              <h4 class="m-bottom-min">createSlice</h4>

              <div class="m-bottom-min flex">
                <div>
                  <p class="m-bottom-min">
                    При проектуванні структура стану Redux
                    ділиться на
                    <b>слайси (slice, частина)</b>, за кожен
                    із яких відповідає окремий редюсер
                  </p>
                  <p>
                    Для кожного слайсу створюється
                    стандартний набір сутностей: типи
                    екшенів, генератори екшенів та редюсер.
                    Редюсери визначають початковий стан
                    слайсу, список екшенів, що впливають на
                    нього та операції оновлення стану.
                  </p>
                </div>
                <div class="bcg-box">
                  <p>
                    const appState = {<br />
                        <b>tasks</b>: [],<br />
                        <b>filters</b>: {},<br />
                    };
                  </p>
                </div>
              </div>

              <div class="m-bottom-min flex new-page">
                <div>
                  <p class="m-bottom-min">
                    Функція <b>createSlice()</b> це
                    надбудова над <b>createAction()</b> та
                    <b>createReducer()</b>, яка стандартизує
                    та ще більше спрощує оголошення слайсу.
                    Вона
                    <i>приймає параметри налаштувань</i>,
                    створює і
                    <i
                      >повертає типи екшенів, генератори
                      екшенів та редюсер</i
                    >.
                  </p>
                  <p>
                    Властивість <b>name</b> визначає ім'я
                    слайсу, яке додаватиметься під час
                    створення екшенів, як приставка до імен
                    редюсерів, оголошених у властивості
                    <b>reducers</b>. Так ми отримаємо екшени
                    з типами <b>tasks/addTask</b>,
                    <b>tasks/deleteTask</b> та
                    <b>tasks/toggleCompleted</b>.
                  </p>
                </div>
                <div class="bcg-box">
                  <p>
                    import { createSlice } from
                    "@reduxjs/toolkit";<br />
                    <br />
                    const <b>tasksSlice</b> =
                    <b>createSlice</b>({<br />
                        <i>// Ім'я слайсу</i><br />
                        <b>name</b>: "tasks",<br />
                       
                    <i>// Початковий стан редюсера слайсу</i
                    ><br />
                        initialState: [],<br />
                        <i>// Об'єкт редюсерів</i><br />
                        <b>reducers</b>: {<br />
                            <b>addTask</b>(state, action)
                    {},<br />
                            <b>deleteTask</b>(state, action)
                    {},<br />
                           
                    <b>toggleCompleted</b>(state, action)
                    {},<br />
                        },<br />
                    });<br />
                    <br />
                    <i>// Генератори екшенів</i><br />
                    const {
                    <b
                      >addTask, deleteTask,
                      toggleCompleted</b
                    >
                    } = tasksSlice.actions;<br />
                    <br />
                    <i>// Редюсер слайсу</i><br />
                    const tasksReducer =
                    <b>tasksSlice</b>.<b>reducer</b>;<br />
                  </p>
                </div>
              </div>

              <div class="m-bottom flex">
                <p>
                  Функція <b>createSlice()</b> у своїй
                  реалізації використовує
                  <b>createReducer</b> і бібліотеку
                  <b>Immer</b>, тому можна писати логіку
                  оновлення стану так, як якби ми
                  безпосередньо змінювали його.
                </p>
                <div class="bcg-box">
                  <p>
                    import { createSlice } from
                    "@reduxjs/toolkit";<br />
                    <br />
                    const tasksSlice = createSlice({<br />
                        name: "tasks",<br />
                        initialState: [],<br />
                        reducers: {<br />
                            addTask(state, action) {<br />
                               
                    state.push(action.payload);<br />
                            },<br />
                            deleteTask(state, action) {<br />
                                const index =
                    state.findIndex(task => task.id ===
                    action.payload);<br />
                                state.splice(index, 1);<br />
                            },<br />
                            toggleCompleted(state, action)
                    {<br />
                                for (const task of state)
                    {<br />
                                    if (task.id ===
                    action.payload) {<br />
                                        task.completed =
                    !task.completed;<br />
                                        break;<br />
                                    }<br />
                                }<br />
                            },<br />
                        },<br />
                    });<br />
                    <br />
                    const { addTask, deleteTask,
                    toggleCompleted } =
                    tasksSlice.actions;<br />
                    const tasksReducer = tasksSlice.reducer;
                  </p>
                </div>
              </div>

              <!-- Вміст payload -->
              <section class="inner-section">
                <h5 class="m-bottom-min">Вміст payload</h5>

                <div class="m-bottom-min flex">
                  <p>
                    <i>Генератор екшену</i>
                    <b>addTask</b> очікує лише рядок з
                    текстом завдання, після чого змінює
                    значення <b>payload</b> використовуючи
                    функцію підготовки екшену. Ось як це
                    виглядає зараз у нашому коді.
                  </p>
                  <div class="bcg-box">
                    <p>
                      <i>// src/redux/actions.js</i><br />
                      <br />
                      import { createAction, nanoid } from
                      "@reduxjs/toolkit";<br />
                      <br />
                      export const <b>addTask</b> =
                      createAction(<i>"tasks/addTask"</i>,
                      text => {<br />
                          return {<br />
                              payload: {<br />
                                  text,<br />
                                  id: nanoid(),<br />
                                  completed: false,<br />
                              },<br />
                          };<br />
                      });
                    </p>
                  </div>
                </div>

                <div class="flex new-page">
                  <p>
                    Щоб зробити те саме при створенні
                    слайсу, властивості в об'єкті редюсерів,
                    в нашому випадку
                    <b>addTask</b>, необхідно передати не
                    функцію, а об'єкт із двома властивостями
                    - <b>reducer</b> та <b>prepare</b>.
                  </p>
                  <div class="bcg-box">
                    <p>
                      import { createSlice, nanoid } from
                      "@reduxjs/toolkit";<br />
                      <br />
                      const tasksSlice = createSlice({<br />
                          name: "tasks",<br />
                          initialState:
                      tasksInitialState,<br />
                          reducers: {<br />
                              <b>addTask</b>: {<br />
                                  <b>reducer</b>(state,
                      action) {<br />
                                     
                      state.push(action.payload);<br />
                                  },<br />
                                  <b>prepare</b>(text) {<br />
                                      return {<br />
                                          payload: {<br />
                                              text,<br />
                                              id:
                      nanoid(),<br />
                                              completed:
                      false,<br />
                                          },<br />
                                      };<br />
                                  },<br />
                              },<br />
                              // Код решти редюсерів<br />
                          },<br />
                      });
                    </p>
                  </div>
                </div>
              </section>

              <!-- Файли слайсів -->
              <section class="inner-section">
                <h5 class="m-bottom-min">Файли слайсів</h5>

                <div class="m-bottom-min flex">
                  <p>
                    Нам більше не потрібний файл
                    <i>reducer.js</i>, тому що під кожен
                    слайс ми створимо окремий файл. Для
                    слайсу завдань це буде файл
                    <b>tasksSlice.js</b>.
                  </p>
                  <div class="bcg-box print-fs-14">
                    <p>
                      <i>// src/redux/tasksSlice.js</i
                      ><br />
                      <br />
                      import { createSlice } from
                      "@reduxjs/toolkit";<br />
                      <br />
                      const tasksSlice = createSlice({<br />
                          name: "tasks",<br />
                          initialState: [],<br />
                          reducers: {<br />
                              addTask: {<br />
                                  reducer(state, action)
                      {<br />
                                     
                      state.push(action.payload);<br />
                                  },<br />
                                  prepare(text) {<br />
                                      return {<br />
                                          payload: {<br />
                                              text,<br />
                                              id:
                      nanoid(),<br />
                                              completed:
                      false,<br />
                                          },<br />
                                      };<br />
                                  },<br />
                              },<br />
                              deleteTask(state, action) {<br />
                                  const index =
                      state.findIndex(task => task.id ===
                      action.payload);<br />
                                  state.splice(index, 1);<br />
                              },<br />
                              toggleCompleted(state, action)
                      {<br />
                                    for (const task of
                      state) {<br />
                                        if (task.id ===
                      action.payload) {<br />
                                            task.completed =
                      !task.completed;<br />
                                            break;<br />
                                        }<br />
                                    }<br />
                              },<br />
                              <br />
                      });<br />
                      <i
                        >// Експортуємо генератори екшенів
                        та редюсер</i
                      ><br />
                      export const { addTask, deleteTask,
                      toggleCompleted } =
                      tasksSlice.actions;<br />
                      export const tasksReducer =
                      tasksSlice.reducer;
                    </p>
                  </div>
                </div>

                <div class="bcg-box print-fs-14">
                  <p>
                    <i>// src/redux/filtersSlice.js</i
                    ><br />
                    <br />
                    import { createSlice } from
                    "@reduxjs/toolkit";<br />
                    import { statusFilters } from
                    "./constants";<br />
                    <br />
                    const filtersSlice = createSlice({<br />
                        name: "filters",<br />
                        initialState: {<br />
                        status: statusFilters.all,<br />
                    },<br />
                        reducers: {<br />
                            setStatusFilter(state, action)
                    {<br />
                                state.status =
                    action.payload;<br />
                            },<br />
                        },<br />
                    });<br />
                    <br />
                    <i
                      >// Експортуємо генератори екшенів та
                      редюсер</i
                    ><br />
                    export const { setStatusFilter } =
                    filtersSlice.actions;<br />
                    export const filtersReducer =
                    filtersSlice.reducer;<br />
                  </p>
                </div>
              </section>

              <!-- Створення стора -->
              <section class="inner-section">
                <h5 class="m-bottom-min">
                  Створення стора
                </h5>

                <div class="m-bottom flex">
                  <p>
                    У файлі створення стора необхідно
                    змінити код імпорту редюсерів.
                  </p>
                  <div class="bcg-box">
                    <p>
                      <i>// src/redux/store.js</i><br />
                      <br />
                      import { configureStore } from
                      "@reduxjs/toolkit";<br />
                      <i
                        >//=============== Before
                        ========================</i
                      ><br />
                      // import { tasksReducer,
                      filtersReducer } from "./reducer";<br />
                      <br />
                      <i
                        >//=============== After
                        ========================</i
                      ><br />
                      import { tasksReducer } from
                      "./tasksSlice";<br />
                      import { filtersReducer } from
                      "./filtersSlice";<br />
                      <br />
                      export const store =
                      configureStore({<br />
                          reducer: {<br />
                              tasks: tasksReducer,<br />
                              filters: filtersReducer,<br />
                          },<br />
                      });
                    </p>
                  </div>
                </div>
              </section>

              <!-- Генератори екшенів -->
              <section class="inner-section">
                <h5 class="m-bottom-min">
                  Генератори екшенів
                </h5>

                <div class="m-bottom-min flex">
                  <p>
                    Генератори екшенів тепер створюються
                    автоматично для кожного слайсу. Це
                    означає, що нам більше не потрібно
                    вручну оголошувати їх в окремому файлі
                    <b>createAction()</b>. Ми можемо
                    видалити файл <i>actions.js</i> та
                    оновити імпорти генераторів екшенів у
                    файлах компонентів. Структура файлів
                    проекту тепер буде виглядати так.
                  </p>
                  <div class="bcg-box print-fs-14">
                    <p>
                      src/<br />
                          - components/<br />
                      <b>
                            - redux/<br />
                                - constants.js<br />
                                - selectors.js<br />
                                - tasksSlice.js <br />
                                - filtersSlice.js <br />
                                - store.js<br />
                      </b>
                          - index.js
                    </p>
                  </div>
                </div>

                <div class="flex">
                  <p>
                    Імпорти генераторів екшенів імпортуються
                    з відповідного файлу слайсу.
                  </p>
                  <div class="bcg-box print-fs-14">
                    <p>
                      <i
                        >//=============== Before
                        ========================</i
                      ><br />
                      // import { deleteTask,
                      toggleCompleted } from
                      "redux/actions";<br />
                      <br />
                      <i
                        >//=============== After
                        ========================</i
                      ><br />
                      import { deleteTask, toggleCompleted }
                      from "redux/tasksSlice";
                    </p>
                  </div>
                </div>
              </section>
            </section>
          </section>

          <!-- localstorage -->
          <section class="section new-page">
            <h3 class="m-bottom-min">
              Збереження і читання localstorage
            </h3>

            <div class="m-bottom-min flex">
              <p>
                Для запису даних
                <b>localstorage</b> та читання із нього
                викорустовується бібліотека
                <b>Redux Persist</b>.
              </p>
              <div class="bcg-box">
                <p>npm install redux-persist</p>
              </div>
            </div>

            <div class="m-bottom-min flex">
              <p class="">
                Файл <b>store.js</b> імпортуються
                <b>persistStore</b> та
                <b>persistReducer</b> та посилання на
                localstorage - <b>storage</b>
              </p>
              <div class="bcg-box">
                <p>
                  <i>//store.js</i><br />
                  <br />
                  import {<br />
                      <b>persistStore</b>,<br />
                      <b>persistReducer</b>,<br />
                  } from "redux-persist";<br />
                  <br />
                  import <b>storage</b> from
                  "redux-persist/lib/storage";
                </p>
              </div>
            </div>

            <div class="m-bottom-min flex">
              <p class="">
                Необхідно налаштувати <b>store</b>, за
                допомогою <b>persistReducer</b>, передавши
                йому першим аргументом об'єкт конфігурації,
                а другим - безпосередньо редьюсер.
              </p>
              <div class="bcg-box">
                <p>
                  import balanceReducer from
                  "./balanceSlice";<br />
                  <br />
                  const pBalanceReducer =
                  <b>persistReducer</b>(<br />
                      balancePersistConfig,<br />
                      <b>balanceReducer</b><br />
                  );<br />
                </p>
              </div>
            </div>

            <div class="m-bottom-min flex">
              <p class="">
                Об'єкт конфігурації
                (<b>balancePersistConfig</b>) має дві
                основні властивості <b>key</b> (ім'я ключа у
                localstorage) та <b>storage</b>. Властивість
                <b>whitelist</b> приймає масив властивостей
                із <i>слайсу</i>, які необхідно зберегти у
                <i>localstorage</i>.
                <i
                  >Без <b>whitelist</b> - збережеться
                  повністю весь слайс</i
                >.
              </p>
              <div class="bcg-box">
                <p>
                  const <b>balancePersistConfig</b> = {<br />
                      <b>key</b>:
                  <i>"balanceValue"</i>,<br />
                      <b>storage</b>,<br />
                      <b>whitelist</b>:
                  <i>["value"]</i>,<br />
                  };
                </p>
              </div>
            </div>

            <div class="m-bottom-min flex">
              <p class="">
                У слайс, замість старого редьюсера,
                необхідно повернути новий
              </p>
              <div class="bcg-box">
                <p>
                  export const store = configureStore({<br />
                      reducer: {<br />
                          balance:
                  <b>pBalanceReducer</b>,<br />
                      },<br />
                  });
                </p>
              </div>
            </div>

            <div class="m-bottom-min flex">
              <p>
                В кінці необхідно виконати стандартні
                налаштування бібліотеки та створити зміну
                <b>persistor</b> із функції
                <b>persistStore</b> (імпортується),
                передавши у неї наш <b>store</b>
              </p>
              <div class="bcg-box">
                <p>
                  export const <b>persistor</b> =
                  <b>persistStore</b>(store);
                </p>
              </div>
            </div>

            <div class="m-bottom flex">
              <p class="">
                Необхідно огорнути додаток за допомогою
                <b>PersistGate</b> із обов'зковим пропсом
                <b>persistor</b>. Додатково можна передати
                пропс <b>loading</b> (loading = {}).
              </p>
              <div class="bcg-box">
                <p>
                  <i>//main.jsx</i><br />
                  import { PersistGate } from
                  "redux-persist/integration/react";<br />
                  import App from "./components/App/App";<br />
                  import { store, persistor } from
                  "./redux/store";<br />
                  <br />
                  ReactDOM.createRoot(document.getElementById("root")).render(<br />
                      &#60;React.StrictMode><br />
                          &#60;Provider store={store}><br />
                              &#60;PersistGate
                  persistor={persistor}><br />
                                  &#60;App /><br />
                              &#60;/PersistGate><br />
                          &#60;/Provider><br />
                      &#60;/React.StrictMode><br />
                  );
                </p>
              </div>
            </div>

            <!-- фінал -->
            <div class="flex new-page">
              <div>
                <p class="m-bottom-min">
                  Фінальний вигляд файл
                  <b>store.js</b> має
                </p>
                <p class="border-box m-bottom-min">
                  В action не можна передавати функції, але
                  бібліотека redax-persist їх передає. Для
                  виключення помилок із redux необхідно
                  неохідно імпортувати усі action`и та
                  додати властивість
                  <b>middleware</b> із налаштуваннями у
                  <b>store</b>
                </p>
                <div class="bcg-box print-m-left-none">
                  <p>
                    <b
                      >import {<br />
                          persistStore,<br />
                          persistReducer,<br />
                          FLUSH,<br />
                          REHYDRATE,<br />
                          PAUSE,<br />
                          PERSIST,<br />
                          PURGE,<br />
                          REGISTER,<br />
                      } from "redux-persist";<br
                    /></b>
                    <br />
                    export const <b>store</b> =
                    configureStore({<br />
                        reducer: {<br />
                            balance: pBalanceReducer,<br />
                        },<br />
                       
                    <b
                      >middleware: (getDefaultMiddleware)
                      =><br />
                              getDefaultMiddleware({<br />
                                  serializableCheck: {<br />
                                      ignoredActions: [<br />
                                          FLUSH,<br />
                                          REHYDRATE,<br />
                                          PAUSE,<br />
                                          PERSIST,<br />
                                          PURGE,<br />
                                          REGISTER<br />
                                      ],<br />
                              },<br />
                          })</b
                    >,<br />
                    });<br />
                    <br />
                    export const persistor =
                    persistStore(store);
                  </p>
                </div>
              </div>
              <div class="bcg-box print-fs-15">
                <p>
                  <i>//store.js</i><br />
                  <br />
                  import { configureStore } from
                  "@reduxjs/toolkit";<br />
                  import {<br />
                      persistStore,<br />
                      persistReducer,<br />
                      FLUSH,<br />
                      REHYDRATE,<br />
                      PAUSE,<br />
                      PERSIST,<br />
                      PURGE,<br />
                      REGISTER,<br />
                  } from "redux-persist";<br />
                  import storage from
                  "redux-persist/lib/storage";<br />
                  import balanceReducer from
                  "./balanceSlice";<br />
                  <br />
                  const balancePersistConfig = {<br />
                      key: "balanceValue",<br />
                      storage,<br />
                      whitelist: ["value"],<br />
                  };<br />
                  <br />
                  const pBalanceReducer = persistReducer(<br />
                      balancePersistConfig,<br />
                      balanceReducer<br />
                  );<br />
                  <br />
                  export const store = configureStore({<br />
                      reducer: {<br />
                          balance: pBalanceReducer,<br />
                      },<br />
                      middleware: (getDefaultMiddleware)
                  =><br />
                          getDefaultMiddleware({<br />
                              serializableCheck: {<br />
                                  ignoredActions: [<br />
                                      FLUSH,<br />
                                      REHYDRATE,<br />
                                      PAUSE,<br />
                                      PERSIST,<br />
                                      PURGE,<br />
                                      REGISTER<br />
                                  ],<br />
                          },<br />
                      }),<br />
                  });<br />
                  <br />
                  export const persistor =
                  persistStore(store);
                </p>
              </div>
            </div>
          </section>
        </div>
      </section>

      <!-- Асинхронність в Redux -->
      <section id="http-redux" class="main-section">
        <div class="container">
          <section>
            <h2 class="center-text">
              Асинхронність в Redux
            </h2>

            <p class="m-bottom">
              <b>HTTP-запити</b> це
              <i>асинхронні операції</i>, які представлені
              <i>промісами</i>, тому їх можна розбити на три
              складові: процес
              <i>запиту</i> (<b>pending</b>),
              <i>успішне</i> завершення запиту
              (<b>fulfilled</b>) та завершення запиту з
              <i>помилкою</i>
              (<b>rejected</b>).
            </p>

            <!-- Операції -->
            <section class="section">
              <h3 class="m-bottom-min">Операції</h3>

              <div class="m-bottom-min flex">
                <div>
                  <p class="m-bottom-min">
                    <b>Завдання</b>: завантаження даних,
                    обробки індикатора завантаження та
                    помилки виконання запиту. Оголосимо
                    слайс списку завдань, у стані якого
                    будемо зберігати масив завдань, прапор
                    статусу завантаження та дані можливої
                    помилки.
                  </p>

                  <p>
                    Додамо редюсер для обробки кожного з
                    можливих станів запиту.
                  </p>

                  <ul class="m-bottom-min">
                    <li>
                      Прапор завантаження
                      <b>isLoading</b> встановлюємо в
                      <b>true</b> на старті запиту, та
                      <b>false</b> у будь-якому іншому
                      випадку, тому що запит завершено.
                    </li>
                    <li>
                      При виконанні запиту з помилкою
                      змінюємо значення властивості
                      <b>error</b>, записавши в нього те, що
                      прийде в <b>action.payload</b> -
                      інформація про помилку.
                    </li>
                    <li>
                      У разі успішного виконання запиту,
                      скидаємо значення помилки та записуємо
                      в
                      <b>items</b> отримані дані з
                      <b>action.payload</b> - масив завдань.
                    </li>
                  </ul>

                  <div class="bcg-box print-m-left-none">
                    <p>
                      <i>store.js</i><br />
                      <br />

                      import { configureStore } from
                      '@reduxjs/toolkit';<br />
                      import { tasksReducer } from
                      './tasksSlice';<br />
                      <br />
                      export const store =
                      configureStore({<br />
                          reducer: {<br />
                              tasks: tasksReducer,<br />
                          },<br />
                      });
                    </p>
                  </div>
                </div>
                <div>
                  <div class="bcg-box m-bottom-min">
                    <p>
                      <i>tasksSlice.js</i><br />
                      <br />

                      import { createSlice } from
                      '@reduxjs/toolkit';<br />
                      <br />
                      const tasksInitialState = {<br />
                          items: [],<br />
                          isLoading: false,<br />
                          error: null,<br />
                      };<br />
                      <br />
                      const tasksSlice = createSlice({<br />
                          name: 'tasks',<br />
                          initialState:
                      tasksInitialState,<br />
                          <b>reducers</b>: {<br />
                             
                      <b>fetchingInProgress(state)</b>
                      {<br />
                                  state.<b>isLoading</b> =
                      true;<br />
                              },<br />
                             
                      <b>fetchingSuccess(state, action)</b>
                      {<br />
                                  state.<b>isLoading</b> =
                      false;<br />
                                  state.<b>error</b> =
                      null;<br />
                                  state.<b>items</b> =
                      <b>action.payload</b>;<br />
                              },<br />
                             
                      <b>fetchingError(state, action)</b>
                      {<br />
                                  state.<b>isLoading</b> =
                      false;<br />
                                  state.<b>error</b> =
                      <b>action.payload</b>;<br />
                              },<br />
                          },<br />
                      });<br />
                      export const { fetchingInProgress,
                      fetchingSuccess, fetchingError } =<br />
                          tasksSlice.actions;<br />
                      export const tasksReducer =
                      tasksSlice.reducer;
                    </p>
                  </div>
                  <div class="bcg-box">
                    <p>
                      <i>selectors.js</i><br />
                      <br />

                      export const getTasks = (state) =>
                      state.tasks;
                    </p>
                  </div>
                </div>
              </div>

              <div class="m-bottom-min flex">
                <div>
                  <p class="m-bottom-min">
                    Для того, щоб при відправленні екшену
                    виконати асинхронний код, необхідно
                    оголосити
                    <b>«операцію»</b> -
                    <i>асинхронний генератор екшену</i>, в
                    <i>тілі</i> якого викликаються інші,
                    <i>синхронні генератори екшенів</i>.
                    <i>Операція</i> не повертає екшен
                    замість цього вона
                    <i>повертає іншу функцію</i>, яка
                    <i>аргументом</i> набуває
                    <b>dispatch</b>. У тілі цієї функції
                    можна виконувати асинхронні дії,
                    наприклад, HTTP-запит. Для запитів
                    використовуємо бібліотеку axios.
                  </p>
                  <p class="m-bottom-min">
                    Усередині операції надсилаємо
                    <i>синхронні екшени</i> для обробки
                    трьох ситуацій: встановлення індикатора
                    завантаження, отримання даних при
                    успішному запиті та обробка помилки.
                  </p>
                  <p class="border-box">
                    <b>Цікаво!</b> Можливість оголошувати
                    асинхронні генератори екшенів та
                    виконувати асинхронні дії надає
                    розширення стора <b>redux-thunk</b>, яке
                    за умовчанням включено до Redux Toolkit.
                  </p>
                </div>
                <div class="bcg-box">
                  <p>
                    <i>operations.js</i><br />
                    <br />

                    import axios from 'axios';<br />
                    import {<br />
                        fetchingInProgress,<br />
                        fetchingSuccess,<br />
                        fetchingError,<br />
                    } from './tasksSlice';<br />
                    <br />
                    axios.defaults.baseURL =<br />
                       
                    'https://62584f320c918296a49543e7.mockapi.io';<br />
                    <br />
                    export const <b>fetchTasks</b> = () =>
                    <b>async (dispatch)</b> => {<br />
                        try {<br />
                           
                    <b>dispatch</b
                    >(fetchingInProgress());<br />
                            const response = await
                    axios.get('/tasks');<br />
                           
                    <b>dispatch</b
                    >(fetchingSuccess(response.data));<br />
                        } catch (e) {<br />
                           
                    <b>dispatch</b
                    >(fetchingError(e.message));<br />
                        }<br />
                    };
                  </p>
                </div>
              </div>

              <div class="flex new-page">
                <div class="bcg-box print-m-left-none">
                  <p>
                    <i>main.jsx</i><br />
                    <br />

                    import React from 'react';<br />
                    import ReactDOM from
                    'react-dom/client';<br />
                    import { Provider } from
                    'react-redux';<br />
                    import { App } from './App.jsx';<br />
                    import { store } from
                    './redux/store';<br />
                    import './index.css';<br />
                    <br />
                    ReactDOM.createRoot(document<br />
                        .getElementById('root')).render(<br />
                            &#60;React.StrictMode ><br />
                                &#60;Provider
                    store="{store}" ><br />
                                    &#60;App /><br />
                                &#60;/Provider ><br />
                            &#60;/React.StrictMode ><br />
                        );
                  </p>
                </div>
                <div class="bcg-box">
                  <p>
                    <i>App.jsx</i><br />
                    <br />
                    import { useEffect } from 'react';<br />
                    import { useDispatch, useSelector } from
                    'react-redux';<br />
                    import { fetchTasks } from
                    './redux/operations';<br />
                    import { getTasks } from
                    './redux/selectors';<br />
                    <br />
                    export const App = () => {<br />
                        const dispatch = useDispatch();<br />
                        const { items, isLoading, error }
                    =<br />
                            useSelector(getTasks);<br />
                        <br />
                        useEffect(() => {<br />
                            dispatch(fetchTasks());<br />
                        }, [dispatch]);<br />
                        <br />
                        return (<br />
                            &#60;div><br />
                                {isLoading &&
                    <b>Loading tasks...</b>}<br />
                                {error &&
                    <b>{error}</b>}<br />
                                &#60;p><br />
                                    {items.length > 0 &&<br />
                                       
                    JSON.stringify(items, null, 2)}<br />
                                &#60;/p><br />
                            &#60;/div><br />
                        );<br />
                    };
                  </p>
                </div>
              </div>
            </section>

            <!-- createAsyncThunk -->
            <section class="section">
              <h3 class="m-bottom-min">createAsyncThunk</h3>

              <div class="m-bottom-min flex">
                <div>
                  <p class="m-bottom-min">
                    <b>createAsyncThunk()</b> - функція
                    Redux Toolkit спрощує процес оголошення
                    асинхронного генератора екшену.
                    <i>Першим аргументом</i> приймає
                    <b>тип екшену</b>, а <i>другим</i>
                    <b>функцію</b>, яка повинна виконати
                    HTTP-запит і повернути проміс із даними,
                    які стануть значенням <b>payload</b>.
                    Повертає
                    <i
                      >асинхронний генератор екшену
                      (операцію)</i
                    >
                    при запуску якого виконається функція з
                    кодом запиту.
                  </p>
                  <p>
                    Функція <b>createAsyncThunk()</b>
                    <i>автоматично</i> створює
                    <i>екшени</i>, що представляють життєвий
                    цикл HTTP-запиту, і відправляє їх у
                    правильному порядку, залежно від статусу
                    запиту.
                  </p>
                </div>
                <div class="bcg-box">
                  <p>
                    <i>// src/redux/operations.js</i><br />
                    <br />
                    import axios from "axios";<br />
                    import { createAsyncThunk } from
                    "@reduxjs/toolkit";<br />
                    <br />
                    axios.defaults.baseURL =<br />
                       
                    "https://62584f320c918296a49543e7.mockapi.io";<br />
                    <br />
                    export const fetchTasks =
                    createAsyncThunk(<br />
                        "tasks/fetchAll",<br />
                        async () => {<br />
                            const response = await
                    axios.get("/tasks");<br />
                            return response.data;<br />
                        }<br />
                    );
                  </p>
                </div>
              </div>

              <p>
                <i
                  >Тип створених екшенів складається з
                  рядка, зазначеного першим аргументом
                  (<b>"tasks/fetchAll"</b>), до якого
                  додається постфікси <b>"pending"</b>,
                  <b>"fulfilled"</b> або
                  <b>"rejected"</b></i
                >, залежно від того, який стан запиту описує
                екшен.
              </p>
              <ul class="m-bottom-min">
                <li>
                  <b>"tasks/fetchAll/pending"</b> - початок
                  запиту;
                </li>
                <li>
                  <b>"tasks/fetchAll/fulfilled"</b> -
                  успішне завершення запиту;
                </li>
                <li>
                  <b>"tasks/fetchAll/rejected"</b> -
                  завершення запиту з помилкою.
                </li>
              </ul>

              <div class="flex new-page">
                <div>
                  <p class="m-bottom-min">
                    Функція <b>createAsyncThunk</b>
                    <i>не створює</i> <b>редюсер</b>, тому
                    що не може знати, як ми хочемо
                    відстежувати стан завантаження, з якими
                    даними завершиться запит та як їх
                    правильно обробити. Тому наступним
                    кроком буде зміна коду слайсу так, щоб
                    він обробляв <b>нові екшени</b>.
                  </p>
                  <p class="m-bottom-min">
                    Властивість
                    <b>extraReducers</b> використовується
                    щоб оголосити
                    <i
                      >редюсери для «зовнішніх» типів
                      екшенів</i
                    >, тобто тих, які не згенеровані з
                    властивості <b>reducers</b>. Оскільки ці
                    редюсери обробляють «зовнішні» екшени,
                    для них не буде створено генератори
                    екшенів в <b>slice.actions</b>,
                    <i>в цьому немає необхідності</i>.
                  </p>
                  <p>
                    <i>Генератори екшенів</i>, які мають
                    життєвий цикл запиту, зберігаються в
                    об'єкті операції як властивості
                    <b>pending</b>, <b>fulfilled</b> та
                    <b>rejected</b>. Вони автоматично
                    створюються за допомогою
                    <b>createAction</b> і тому мають
                    властивість <b>type</b> і перевизначений
                    метод <b>toString()</b>, який повертає
                    рядок типу екшену.
                  </p>
                </div>
                <div class="bcg-box">
                  <p>
                    <i>// src/redux/tasksSlice.js </i><br />
                    <br />
                    import { createSlice } from
                    "@reduxjs/toolkit";<br />
                    import { fetchTasks } from
                    "./operations";<br />
                    <br />
                    const tasksSlice = createSlice({<br />
                        name: "tasks",<br />
                        initialState: {<br />
                            items: [],<br />
                            isLoading: false,<br />
                            error: null,<br />
                        },<br />
                        <b>extraReducers</b>: builder =>
                    {<br />
                            builder<br />
                               
                    .addCase(fetchTasks.<b>pending</b>,
                    (state, action) => {<br />
                                    state.isLoading =
                    true;<br />
                                })<br />
                               
                    .addCase(fetchTasks.<b>fulfilled</b>,
                    (state, action) => {<br />
                                    state.isLoading =
                    false;<br />
                                    state.error = null;<br />
                                    state.items =
                    action.payload;<br />
                                })<br />
                               
                    .addCase(fetchTasks.<b>rejected</b>,
                    (state, action) => {<br />
                                    state.isLoading =
                    false;<br />
                                    state.error =
                    action.payload;<br />
                                });<br />
                        },<br />
                    });<br />
                    <br />
                    export const tasksReducer =
                    tasksSlice.reducer;

                    <br />
                    export default Product;
                  </p>
                </div>
              </div>
            </section>

            <!-- Селектори -->
            <section class="section">
              <h3 class="m-bottom-min">Селектори</h3>

              <p class="m-bottom-min">
                <b>Селектори</b> - функції, які інкапсулюють
                у собі читання значень із стану Redux.
              </p>

              <div class="m-bottom-min flex">
                <p>
                  У компонентах використовуємо хук
                  <b>useSelector(selector)</b>, якому
                  передається посилання на функцію селектор.
                </p>
                <div class="bcg-box">
                  <p>
                    const <b>valueSelector</b> = state =>
                    state.some.value;<br />
                    const value =
                    <b>useSelector(valueSelector)</b>;
                  </p>
                </div>
              </div>

              <p class="m-bottom-min">
                Таким чином компоненти не знають про форму
                стану Redux та процес обчислення необхідного
                їм значення. При зміні структури стану
                необхідно буде оновити лише селектори,
                компоненти не будуть порушені.
              </p>

              <p class="m-bottom">
                По суті селектори це прошарок абстракції,
                який мінімізує зв'язок між компонентами та
                стором Redux.
              </p>

              <!-- Найменування -->
              <section class="sub-section">
                <h4 class="m-bottom-min">Найменування</h4>

                <p class="m-bottom-min">
                  Рекомендується починати імена
                  <i>функцій селекторів</i> приставкою
                  <b>select</b>, після якої йде опис
                  обраного значення.
                </p>

                <div class="m-bottom flex">
                  <div class="bcg-box print-m-left-none">
                    <p>
                      <i>// src/redux/selectors.js</i><br />
                      <br />

                      <i
                        >//=============== Before
                        ===============</i
                      ><br />
                      export const getTasks = state =>
                      state.tasks.items;<br />
                      export const getStatusFilter = state
                      => state.filters.status;<br />
                      <br />
                      <i
                        >//=============== After
                        ===============</i
                      ><br />
                      export const <b>select</b>Tasks =
                      state => state.tasks.items;<br />
                      export const
                      <b>select</b>StatusFilter = state =>
                      state.filters.status;
                    </p>
                  </div>
                  <div class="bcg-box">
                    <p>
                      <i>//===== Before =====</i><br />
                      import {<br />
                          getTasks,<br />
                          getStatusFilter,<br />
                      } from "redux/selectors";<br />
                      <br />
                      <i>//===== After =====</i><br />
                      import {<br />
                          selectTasks,<br />
                          selectStatusFilter,<br />
                      } from "redux/selectors";
                    </p>
                  </div>
                </div>
              </section>

              <!-- Складові селектори -->
              <section class="sub-section new-page">
                <h4 class="m-bottom-min">
                  Складові селектори
                </h4>

                <div class="m-bottom-min flex">
                  <p class="">
                    У найпростішому вигляді селектор отримує
                    поточний стан та повертає його необхідну
                    частину. Селектори це звичайні функції,
                    а отже, можуть обчислювати значення
                    використовуючи частини стану та
                    повертати результат обчислень.
                  </p>
                  <div class="bcg-box">
                    <p>
                      const selectTotalValue = state => {<br />
                          const a = state.values.a;<br />
                          const b = state.values.b;<br />
                          return a + b;<br />
                      };
                    </p>
                  </div>
                </div>

                <p class="m-bottom-min">
                  Селектори, які тільки повертають якусь
                  частину стану, без додаткових обчислень,
                  називатимемо
                  <b>простими</b>. А ті, що повертають якісь
                  значення, що обчислюються -
                  <b>складовими</b>.
                </p>
              </section>

              <!-- Функція createSelector -->
              <section class="sub-section">
                <h4 class="m-bottom-min">
                  Функція createSelector
                </h4>

                <p class="m-bottom-min">
                  Якщо селектор повертає посилальний тип або
                  виконує якісь обчислення, його необхідно
                  оптимізувати так, щоб ці обчислення
                  запускалися тільки за умови зміни тих
                  частин стану, які використовуються в
                  селекторі ы не обчислювались при змінах
                  інших властивостей стану.
                </p>

                <div class="m-bottom-min flex">
                  <div>
                    <p class="m-bottom-min">
                      Процес
                      <i>оптимізації селекторів</i>
                      називається <b>мемоізація</b> -
                      збереження результатів виконання
                      функції для запобігання повторним
                      обчисленням.
                    </p>
                    <p>
                      Для мемоізації селектора
                      використовується функція
                      <b>createSelector</b>, яка приймає
                      масив селекторів, значення яких
                      необхідні для наступних обчислень та
                      функцію перетворювач, в якій
                      виконуватимуться всі обчислення.
                    </p>
                  </div>
                  <div class="bcg-box">
                    <p>
                      import { <b>createSelector</b> } from
                      "@reduxjs/toolkit";<br />
                      <br />
                      const selector =
                      <b>createSelector</b>(<br />
                         
                      <i>// Масив вхідних селекторів</i
                      ><br />
                          [inputSelector1, inputSelector2,
                      inputSelector3],<br />
                          <i>// Функція перетворювач</i
                      ><br />
                          (result1, result2, result3) =>
                      {<br />
                             
                      <i
                        >// Виконуємо обчислення та
                        повертаємо результат</i
                      ><br />
                          }<br />
                      );
                    </p>
                  </div>
                </div>

                <ul class="m-bottom-min">
                  <li>
                    У <i>масиві селекторів</i> можуть бути
                    будь-які інші селектори, як
                    <i>прості</i> так і <i>складові</i>, у
                    тому числі <i>мемоізовані</i>.
                  </li>
                  <li>
                    Результати вхідних селекторів
                    передаються як
                    <i>аргументи функції</i> перетворення
                    <i
                      >в тому самому порядку, в якому вони
                      перераховані</i
                    >.
                  </li>
                  <li>
                    <i>Повторні обчислення</i> виконуються
                    лише якщо
                    <i
                      >зміниться значення якогось
                      параметра</i
                    >, в іншому випадку повертається
                    результат останнього виклика функції.
                  </li>
                </ul>

                <div class="flex">
                  <div>
                    <p class="center-text">Було</p>

                    <div class="bcg-box">
                      <p>
                        <i
                          >//
                          src/components/TaskCounter/TaskCounter.jsx</i
                        ><br />
                        <br />
                        import { useSelector } from
                        "react-redux";<br />
                        import { selectTasks } from
                        "redux/selectors";<br />
                        <br />
                        export const TaskCounter = () =>
                        {<br />
                            const tasks =
                        useSelector(selectTasks);<br />
                        <br />
                            const count = tasks.reduce(<br />
                                (acc, task) => {<br />
                                    if (task.completed) {<br />
                                        acc.completed +=
                        1;<br />
                                    } else {<br />
                                        acc.active += 1;<br />
                                    }<br />
                                    return acc;<br />
                                },<br />
                                { active: 0, completed: 0
                        }<br />
                            );<br />
                        <br />
                            <i>// Рендер JSX розмітки</i
                        ><br />
                        };
                      </p>
                    </div>
                  </div>
                  <div>
                    <p class="center-text">Стало</p>

                    <div class="bcg-box m-bottom-min">
                      <p>
                        <i>// src/redux/selectors.js</i
                        ><br />
                        import { <b>createSelector</b> }
                        from "@reduxjs/toolkit";<br />
                        <br />
                        export const
                        <b>selectTasks</b> = state =>
                        state.tasks.items;<br />
                        <br />
                        export const
                        <b>selectTaskCount</b> =
                        <b>createSelector</b>(<br />
                            [<b>selectTasks</b>],<br />
                            tasks => {<br />
                            return tasks.reduce(<br />
                                (count, task) => {<br />
                                    if (task.completed) {<br />
                                        count.completed +=
                        1;<br />
                                    } else {<br />
                                        count.active +=
                        1;<br />
                                    }<br />
                                    return count;<br />
                                },<br />
                                { active: 0, completed: 0
                        }<br />
                            );<br />
                        });
                      </p>
                    </div>
                    <div class="bcg-box">
                      <p>
                        <i
                          >//
                          src/components/TaskCounter/TaskCounter.jsx</i
                        ><br />
                        import { useSelector } from
                        "react-redux";<br />
                        import { <b>selectTaskCount</b> }
                        from "redux/selectors";<br />
                        export const TaskCounter = () =>
                        {<br />
                            const count =
                        useSelector(<b>selectTaskCount</b>);<br />
                            <i>// Рендер JSX розмітки</i
                        ><br />
                        };
                      </p>
                    </div>
                  </div>
                </div>
              </section>
            </section>
          </section>
        </div>
      </section>

      <!-- Реєстрація та логін користувача -->
      <section id="register-login" class="main-section">
        <div class="container">
          <h2 class="m-bottom center-text">
            Реєстрація та логін користувача
          </h2>

          <!-- Права доступу -->
          <section class="m-bottom">
            <h3 class="m-bottom-min">Права доступу</h3>
            <p class="m-bottom-min">
              <b>Аутентифікація (authentication)</b> - це
              процес перевірки облікових даних користувача
              (логін/пароль). Перевірка аутентифікації
              користувача шляхом порівняння введеного ним
              логіна/паролю з даними збереженими в базі
              даних.
            </p>
            <p class="m-bottom-min">
              <b>Авторизація (authorization)</b> - це
              перевірка прав користувача на доступ до певних
              ресурсів. Правом доступу може бути якесь
              унікальне значення, яке фронтенд передає з
              кожним HTTP запитом на бекенд.
            </p>
            <p>
              Наприклад, після аутентифікації користувач
              отримує право запитувати та отримувати від
              ресурсу my-api.com/tasks деякі дані. При
              кожному зверненні користувача до ресурсу tasks
              система авторизації перевірить, чи має він
              право звертатися до цього ресурсу, внаслідок
              чого пропускає чи відсікає запит. Право
              доступу до ресурсу визначається за наявністю
              якогось унікального значення у запиті
              (токену).
            </p>
          </section>

          <!-- JSON Web Token -->
          <section class="m-bottom">
            <h3 class="m-bottom-min">JSON Web Token</h3>
            <div class="m-bottom-min flex">
              <!-- main.jsx -->
              <div>
                <p class="m-bottom-min">
                  Один із механізмів авторизації це JWT
                  (JSON Web Token). Токени надають собою
                  засіб авторизації для кожного запиту від
                  фронтенду до бекенду. Токени створюються
                  на бекенді ґрунтуючись на секретному
                  ключі, який зберігається на сервері, та
                  якихось унікальних для користувача даних,
                  наприклад пошта тощо. Токен у результаті
                  зберігається на фронтенді і
                  використовується за необхідності
                  авторизації будь-якого запиту.
                </p>

                <p class="m-bottom-min">
                  Кожен токен це унікальний зашифрований
                  рядок, який містить три блоки:
                  <b
                    >заголовок (header), набір полів
                    (payload) та сигнатуру</b
                  >. При спробі зловмисником підмінити дані
                  в header або payload, токен стане не
                  валідним, оскільки сигнатура не
                  відповідатиме початковим значенням. А
                  можливість згенерувати нову сигнатуру у
                  зловмисника відсутня, оскільки секретний
                  ключ для зашифрування лежить на сервері.
                </p>

                <div class="bcg-box fs-13">
                  <p>
                    <i>main.jsx</i><br />
                    <br />
                    import React from 'react';<br />
                    import { HelmetProvider } from
                    'react-helmet-async';<br />
                    import ReactDOM from
                    'react-dom/client';<br />
                    import { BrowserRouter } from
                    'react-router-dom';<br />
                    import { PersistGate } from
                    'redux-persist/integration/react';<br />
                    import { Provider } from
                    'react-redux';<br />
                    import { App } from
                    './components/App';<br />
                    import { store, persistor } from
                    './redux/store';<br />
                    import 'modern-normalize';<br />
                    import './index.css';<br />
                    <br />
                    ReactDOM.createRoot(document.getElementById('root')).render(<br />
                        &#60;React.StrictMode><br />
                            &#60;Provider store={store}><br />
                                &#60;PersistGate
                    loading={null} persistor={persistor}><br />
                                    &#60;BrowserRouter><br />
                                       
                    &#60;HelmetProvider><br />
                                            &#60;App /><br />
                                       
                    &#60;/HelmetProvider><br />
                                    &#60;/BrowserRouter><br />
                                &#60;/PersistGate><br />
                            &#60;/Provider><br />
                        &#60;/React.StrictMode><br />
                    );
                  </p>
                </div>
              </div>

              <!-- redux/store.js -->
              <div class="bcg-box fs-13">
                <p>
                  <i>redux/store.js</i>
                  <br />
                  import { configureStore } from
                  '@reduxjs/toolkit';<br />
                  import {<br />
                      persistStore,<br />
                      persistReducer,<br />
                      FLUSH,<br />
                      REHYDRATE,<br />
                      PAUSE,<br />
                      PERSIST,<br />
                      PURGE,<br />
                      REGISTER,<br />
                  } from 'redux-persist';<br />
                  import storage from
                  'redux-persist/lib/storage';<br />
                  import { tasksReducer } from
                  './tasks/slice';<br />
                  import { authReducer } from
                  './auth/slice';<br />
                  <br />
                  <i
                    >// Persisting token field from auth
                    slice to localstorage</i
                  ><br />
                  const authPersistConfig = {<br />
                      key: 'auth',<br />
                      storage,<br />
                      whitelist: ['token'],<br />
                  };<br />
                  <br />
                  export const store = configureStore({<br />
                      reducer: {<br />
                          auth:
                  persistReducer(authPersistConfig,
                  authReducer),<br />
                          tasks: tasksReducer,<br />
                      },<br />
                  <br />
                      middleware: (getDefaultMiddleware)
                  =><br />
                          getDefaultMiddleware({<br />
                              serializableCheck: {<br />
                                  ignoredActions: [<br />
                                      FLUSH,<br />
                                      REHYDRATE,<br />
                                      PAUSE,<br />
                                      PERSIST,<br />
                                      PURGE,<br />
                                      REGISTER<br />
                                  ],<br />
                              },<br />
                          }),<br />
                      devTools: process.env.NODE_ENV ===
                  'development',<br />
                  });<br />
                  <br />
                  export const persistor =
                  persistStore(store);
                </p>
              </div>
            </div>

            <!-- redux/auth/operations.js -->
            <div class="m-bottom-min bcg-box flex new-page">
              <p>
                <i>redux/auth/operations.js</i><br />
                <br />
                import axios from 'axios';<br />
                import { createAsyncThunk } from
                '@reduxjs/toolkit';<br />
                <br />
                axios.defaults.baseURL =<br />
                   
                'https://goit-task-manager.herokuapp.com/';<br />
                <br />
                <i>// Utility to add JWT<br /></i>
                const setAuthHeader = (token) => {<br />
                axios.defaults.headers.common.Authorization
                = `Bearer ${token}`;<br />
                };<br />
                <br />
                <i>// Utility to remove JWT<br /></i>
                const clearAuthHeader = () => {<br />
                axios.defaults.headers.common.Authorization
                = '';<br />
                };<br />
                <br />

                <i
                  >/*<br />
                  * POST @ /users/signup<br />
                  * body: { name, email, password }<br />
                  */<br
                /></i>
                export const register = createAsyncThunk(<br />
                    'auth/register',<br />
                    async (credentials, thunkAPI) => {<br />
                        try {<br />
                            const res = await
                axios.post('/users/signup', credentials);<br />
                <i
                  >            // After successful
                  registration, add the token<br />
                              // to the HTTP header<br
                /></i>
                           
                setAuthHeader(res.data.token);<br />
                            return res.data;<br />
                        } catch (error) {<br />
                            return
                thunkAPI.rejectWithValue(error.message);<br />
                        }<br />
                    }<br />
                );<br />
                <br />

                <i
                  >/*<br />
                  * POST @ /users/login<br />
                  * body: { email, password }<br />
                  */<br
                /></i>
                export const logIn = createAsyncThunk(<br />
                    'auth/login',<br />
                    async (credentials, thunkAPI) => {<br />
                        try {<br />
                            const res = await
                axios.post('/users/login', credentials);<br />
                <i
                  >            // After successful login,
                  add the token<br />
                              // to the HTTP header<br
                /></i>
                           
                setAuthHeader(res.data.token);<br />
                            return res.data;<br />
                        } catch (error) {<br />
                            return
                thunkAPI.rejectWithValue(error.message);<br />
                        }<br />
                    }<br />
                );<br />
              </p>

              <p>
                <br />
                <br />
                <i
                  >/*<br />
                  * POST @ /users/logout<br />
                  * headers: Authorization: Bearer token<br />
                  */<br
                /></i>
                export const logOut = createAsyncThunk(<br />
                    'auth/logout',<br />
                    async (_,<br />
                    thunkAPI<br />
                ) => {<br />
                    try {<br />
                        await
                axios.post('/users/logout');<br />
                <i
                  >        // After a successful logout,
                  remove the token<br />
                          // from the HTTP header<br
                /></i>
                        clearAuthHeader();<br />
                    } catch (error) {<br />
                        return
                thunkAPI.rejectWithValue(error.message);<br />
                    }<br />
                });<br />
                <br />

                <i
                  >/*<br />
                  * GET @ /users/me<br />
                  * headers: Authorization: Bearer token<br />
                  */<br
                /></i>
                export const refreshUser =
                createAsyncThunk(<br />
                    'auth/refresh',<br />
                    async (_, thunkAPI) => {<br />
                <i
                  >        // Reading the token from the
                  state via getState()<br
                /></i>
                        const state =
                thunkAPI.getState();<br />
                        const persistedToken =
                state.auth.token;<br />
                    <br />
                        if (persistedToken === null) {<br />
                <i
                  >            // If there is no token, exit
                  without<br />
                              // performing any request<br
                /></i>
                            return
                thunkAPI.rejectWithValue(<br />
                                'Unable to fetch user'<br />
                            );<br />
                        }<br />
                    <br />
                        try {<br />
                <i
                  >            // If there is a token, add
                  it to the HTTP header<br />
                              // and perform the request<br
                /></i>
                           
                setAuthHeader(persistedToken);<br />
                            const res = await
                axios.get('/users/me');<br />
                            return res.data;<br />
                        } catch (error) {<br />
                            return
                thunkAPI.rejectWithValue(error.message);<br />
                        }<br />
                    }<br />
                );
              </p>
            </div>

            <!-- redux/auth/selectors.js -->
            <div class="m-bottom-min bcg-box">
              <p>
                <i>redux/auth/selectors.js</i><br />
                <br />
                export const selectIsLoggedIn = (state) =>
                state.auth.isLoggedIn;<br />
                <br />
                export const selectUser = (state) =>
                state.auth.user;<br />
                <br />
                export const selectIsRefreshing = (state) =>
                state.auth.isRefreshing;
              </p>
            </div>

            <!-- redux/auth/slice.js -->
            <div class="flex new-page">
              <div
                class="m-bottom-min bcg-box print-m-left-none"
              >
                <p>
                  <i>redux/auth/slice.js</i><br />
                  import { createSlice } from
                  '@reduxjs/toolkit';<br />
                  import { register, logIn, logOut,
                  refreshUser }<br />
                      from './operations';<br />
                  <br />
                  const authSlice = createSlice({<br />
                      name: 'auth',<br />
                      initialState: {<br />
                          user: {<br />
                              name: null,<br />
                              email: null,<br />
                          },<br />
                          token: null,<br />
                          isLoggedIn: false,<br />
                          isRefreshing: false,<br />
                      },<br />
                      extraReducers: (builder) => {<br />
                          builder<br />
                              .addCase(register.fulfilled,
                  (state, action) => {<br />
                                  state.user =
                  action.payload.user;<br />
                                  state.token =
                  action.payload.token;<br />
                                  state.isLoggedIn =
                  true;<br />
                              })<br />
                              .addCase(logIn.fulfilled,
                  (state, action) => {<br />
                                  state.user =
                  action.payload.user;<br />
                                  state.token =
                  action.payload.token;<br />
                                  state.isLoggedIn =
                  true;<br />
                              })<br />
                              .addCase(logOut.fulfilled,
                  (state) => {<br />
                                  state.user = { name: null,
                  email: null };<br />
                                  state.token = null;<br />
                                  state.isLoggedIn =
                  false;<br />
                              })<br />
                              .addCase(refreshUser.pending,
                  (state) => {<br />
                                  state.isRefreshing =
                  true;<br />
                              })<br />
                             
                  .addCase(refreshUser.fulfilled, (state,
                  action) => {<br />
                                  state.user =
                  action.payload;<br />
                                  state.isLoggedIn =
                  true;<br />
                                  state.isRefreshing =
                  false;<br />
                              })<br />
                              .addCase(refreshUser.rejected,
                  (state) => {<br />
                                  state.isRefreshing =
                  false;<br />
                              });<br />
                      },<br />
                  }); export const authReducer =
                  authSlice.reducer;
                </p>
              </div>

              <!-- redux/tasks/operations.js -->
              <div class="m-bottom-min bcg-box">
                <p>
                  <i>redux/tasks/operations.js</i><br />
                  <br />
                  import { createAsyncThunk } from
                  '@reduxjs/toolkit';<br />
                  import axios from 'axios';<br />
                  <br />
                  // GET @ /tasks<br />
                  export const fetchTasks =
                  createAsyncThunk(<br />
                      'tasks/fetchAll',<br />
                      async (_, thunkAPI) => {<br />
                          try {<br />
                              const res = await
                  axios.get('/tasks');<br />
                              return res.data;<br />
                          } catch (error) {<br />
                              return
                  thunkAPI.rejectWithValue(error.message);<br />
                          }<br />
                      }<br />
                  );<br />
                  <br />
                  // POST @ /tasks<br />
                  export const addTask =
                  createAsyncThunk(<br />
                      'tasks/addTask',<br />
                      async (text, thunkAPI) => {<br />
                          try {<br />
                              const response = await
                  axios.post('/tasks', { text });<br />
                              return response.data;<br />
                          } catch (e) {<br />
                              return
                  thunkAPI.rejectWithValue(e.message);<br />
                          }<br />
                      }<br />
                  );<br />
                  <br />
                  // DELETE @ /tasks/:id<br />
                  export const deleteTask =
                  createAsyncThunk(<br />
                      'tasks/deleteTask',<br />
                      async (taskId, thunkAPI) => {<br />
                          try {<br />
                              const response = await
                  axios.delete(`/tasks/${taskId}`);<br />
                              return response.data;<br />
                          } catch (e) {<br />
                              return
                  thunkAPI.rejectWithValue(e.message);<br />
                          }<br />
                      }<br />
                  );
                </p>
              </div>
            </div>

            <!-- redux/tasks/selectors.js -->
            <div class="m-bottom-min bcg-box">
              <p>
                <i>redux/tasks/selectors.js</i><br />
                <br />
                export const selectLoading = (state) =>
                state.tasks.loading;<br />
                <br />
                export const selectFilter = (state) =>
                state.tasks.filter;<br />
                <br />
                export const selectAllTasks = (state) =>
                state.tasks.items;
              </p>
            </div>

            <!-- redux/tasks/slice.js -->
            <div class="m-bottom-min bcg-box new-page">
              <p>
                <i>redux/tasks/slice.js</i><br />
                <br />
                import { createSlice } from
                '@reduxjs/toolkit';<br />
                import { logOut } from
                '../auth/operations';<br />
                import { fetchTasks, addTask, deleteTask }
                from './operations';<br />
                <br />
                const handlePending = (state) => {<br />
                    state.isLoading = true;<br />
                };<br />
                <br />
                const handleRejected = (state, action) =>
                {<br />
                    state.isLoading = false;<br />
                    state.error = action.payload;<br />
                };<br />
                <br />
                const tasksSlice = createSlice({<br />
                    name: 'tasks',<br />
                    initialState: {<br />
                        items: [],<br />
                        isLoading: false,<br />
                        error: null,<br />
                    },<br />
                    extraReducers: (builder) => {<br />
                        builder<br />
                            .addCase(fetchTasks.pending,
                handlePending)<br />
                            .addCase(fetchTasks.fulfilled,
                (state, action) => {<br />
                                state.isLoading = false;<br />
                                state.error = null;<br />
                                state.items =
                action.payload;<br />
                            })<br />
                            .addCase(fetchTasks.rejected,
                handleRejected)<br />
                            .addCase(addTask.pending,
                handlePending)<br />
                            .addCase(addTask.fulfilled,
                (state, action) => {<br />
                                state.isLoading = false;<br />
                                state.error = null;<br />
                               
                state.items.push(action.payload);<br />
                            })<br />
                            .addCase(addTask.rejected,
                handleRejected)<br />
                            .addCase(deleteTask.pending,
                handlePending)<br />
                            .addCase(deleteTask.fulfilled,
                (state, action) => {<br />
                                state.isLoading = false;<br />
                                state.error = null;<br />
                                const index =
                state.items.findIndex(<br />
                                    (task) => task.id ===
                action.payload.id<br />
                                );<br />
                                state.items.splice(index,
                1);<br />
                            })<br />
                            .addCase(deleteTask.rejected,
                handleRejected)<br />
                            .addCase(logOut.fulfilled,
                (state) => {<br />
                                state.items = [];<br />
                                state.error = null;<br />
                                state.isLoading = false;<br />
                            });<br />
                    },<br />
                });<br />
                <br />
                export const tasksReducer =
                tasksSlice.reducer;
              </p>
            </div>

            <!-- <div class="m-bottom-min bcg-box ">
            <p>
              const Product = () => {<br />
                  return (<br />
                      &#60;div&#62;<br />
                          &#60;h3&#62;Cookies&#60;/h3&#62;<br />
                          &#60;p&#62;Price: 999
              credits&#60;/p&#62;<br />
                      &#60;/div&#62;<br />
                  );<br />
              }<br />
              <i>redux/store.js</i><br />
            </p>
          </div> -->
          </section>
        </div>
      </section>

      <!-- Хуки -->
      <section id="hooks" class="main-section">
        <div class="container">
          <h2 class="m-bottom center-text">Хуки</h2>

          <section class="section">
            <div class="m-bottom">
              <p class="m-bottom-min">
                <b>Хук</b> - функція за допомогою якої можна
                "підключитися" до різних можливостей React,
                що починається з <b>use</b> (useState,
                useEffect...).
              </p>
              <div class="flex">
                <div>
                  <p class="m-bottom-min">
                    Для використання хуку, необхідно
                    <b>імпортувати</b> його в файлі
                    компонента з бібліотеки React.
                  </p>
                </div>
                <div class="bcg-box">
                  <p>import { useState } from 'react';</p>
                </div>
              </div>

              <table class="thick-element">
                <caption></caption>
                <thead>
                  <tr>
                    <th>hook</th>
                    <th>Опис</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><a href="#useId">useId</a></td>
                    <td>
                      генерація унікальних ідентифікаторів,
                      які можна передавати атрибутам
                      доступності полів форми
                    </td>
                  </tr>

                  <tr>
                    <td>
                      <a href="#useState">useState</a>
                    </td>
                    <td>
                      додає стан до функціональних
                      компонентів
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <a href="#useEffect">useEffect</a>
                    </td>
                    <td>
                      управління побічними ефектами в
                      компонентах функціонального типу
                    </td>
                  </tr>
                  <tr>
                    <td><a href="#useMemo">useMemo</a></td>
                    <td></td>
                  </tr>
                  <tr>
                    <td><a href="#useRef">useRef</a></td>
                    <td></td>
                  </tr>
                  <tr>
                    <td>
                      <a href="#useContext">useContext</a>
                    </td>
                    <td></td>
                  </tr>
                  <tr>
                    <td>
                      <a href="#own-hooks">Власні хуки</a>
                    </td>
                    <td></td>
                  </tr>
                  <tr>
                    <td>useToggle</td>
                    <td></td>
                  </tr>
                  <tr>
                    <td></td>
                    <td></td>
                  </tr>
                  <tr>
                    <td></td>
                    <td></td>
                  </tr>
                </tbody>
              </table>
            </div>
          </section>

          <!-- Хук useId -->
          <section id="useId" class="section new-page">
            <h3 class="m-bottom-min">Хук useId</h3>

            <div class="">
              <div class="m-bottom flex">
                <div>
                  <p>
                    Хук<b>useId</b> використовується для
                    генерації унікальних ідентифікаторів,
                    які можна передавати атрибутам
                    доступності полів форми:
                  </p>
                  <ul class="m-bottom-min">
                    <li>не приймає жодних параметрів,</li>
                    <li>
                      повертає унікальний рядок
                      ідентифікатора.
                    </li>
                  </ul>
                  <p class="border-box">
                    <b>Важливо!</b> Не слід використовувати
                    <b>useId</b> для генерації ключів у
                    списку, він призначений лише для
                    створення ідентифікаторів полів форми.
                  </p>
                </div>
                <div class="bcg-box">
                  <p>
                    import { useId } from 'react';<br />
                    <br />
                    const MyComponent = () => {<br />
                        <b>const id = useId()</b>;<br />
                    };
                  </p>
                </div>
              </div>
              <div class="m-bottom flex">
                <div>
                  <p class="m-bottom-min">
                    HTML-атрибут <b>for</b> тегу
                    <b>label</b>, який в React представлений
                    <i>jsx-атрибутом</i> <b>htmlFor</b>,
                    допомагає асистивним технологіям,
                    связуючи <i>поле</i> і <i>label</i> за
                    <i>ідентифікатором</i>.
                  </p>
                  <p>
                    Для кожної форми можна створити стільки
                    ідентифікаторів, скільки потрібно. Кожен
                    ідентифікатор зберігається в окремій
                    змінній.
                  </p>
                </div>
                <div class="bcg-box">
                  <p>
                    const LoginForm = () => {<br />
                       
                    <b>const loginId = useId()</b>;<br />
                       
                    <b>const passwordId = useId()</b>;<br />
                        <br />
                        return (<br />
                            &#60;form><br />
                                &#60;label
                    htmlFor={<b>loginId</b>}>Login&#60;/label><br />
                                &#60;input type="text"
                    name="login" id={<b>loginId</b>} /><br />
                                &#60;label
                    htmlFor={<b>passwordId</b>}>Password&#60;/label><br />
                                &#60;input type="password"
                    name="password" id={<b>passwordId</b>}
                    /><br />
                                &#60;button
                    type="submit">Login&#60;/button><br />
                            &#60;/form><br />
                        );<br />
                    };
                  </p>
                </div>
              </div>
            </div>
          </section>

          <!-- Хук useState -->
          <section id="useState" class="section new-page">
            <h3 class="m-bottom-min">Хук useState</h3>

            <div class="m-bottom-min flex">
              <div>
                <p class="m-bottom-min">
                  Хук <b>useState</b> повідомляє React, щоб
                  цей компонент запам'ятовував щось.
                </p>
                <ul class="">
                  <li>
                    <b
                      >const [clicks, setClicks] =
                      useState(0)</b
                    >
                  </li>
                  <li>
                    <b>[ clicks, setClicks ]</b> -
                    деструктуризованний масив
                  </li>
                  <li><b>clicks</b> - змінна стану</li>
                  <li>
                    <b>setClicks</b> - функція для
                    динамічного встановлення стану
                  </li>
                  <li>
                    <b>useState(0)</b> - встановлення
                    початкового стану
                  </li>
                </ul>
              </div>
              <div class="bcg-box">
                <p>
                  import { useState } from 'react';<br />
                  <br />
                  const App = () => {<br />
                     
                  <b
                    >const [clicks, setClicks] =
                    useState(0)</b
                  >;<br />
                  <br />
                      const handleClick = () => {<br />
                          <b>setClicks</b>(<b>clicks</b> +
                  1);<br />
                      };<br />
                  <br />
                      return &#60;button
                  onClick={handleClick}>Current:
                  {<b>clicks</b>}&#60;/button><br />
                  };
                </p>
              </div>
            </div>

            <p class="m-bottom-min">
              Єдиний аргумент для <b>useState</b> -
              початкове значення змінної стану.
            </p>

            <p class="m-bottom-min">
              Кожного разу, коли компонент рендериться,
              useState повертає масив, що містить два
              значення:
            </p>

            <ul class="m-bottom-min">
              <li>
                Змінну стану (<b>clicks</b>) зі збереженим
                поточним значенням.
              </li>
              <li>
                Функцію встановлення стану
                (<b>setClicks</b>), яка може оновлювати
                змінну стану і викликати повторний рендеринг
                компонента.
              </li>
            </ul>

            <p class="border-box m-bottom">
              <b>Цікаво!</b> Використовуючи
              деструктуризацію, можна задати будь-які імена
              змінних. Рекомендовано називати цю пару як
              [<b>something</b>, <b>setSomething</b>].
            </p>

            <!-- Декілька станів -->
            <section class="sub-section">
              <h4 class="m-bottom-min">Декілька станів</h4>

              <div class="flex">
                <div>
                  <p class="m-bottom-min">
                    Можна мати стільки змінних стану,
                    скільки потрібно в одному компонентії.
                    Для кожного використовуйте окремий
                    <b>useState</b>.
                  </p>
                  <p>
                    Кожен зі станів <b>clicks</b> та
                    <b>isOpen </b> незалежний і оновлюється
                    своїми відповідними функціями
                    встановлення <b>setClicks</b> та
                    <b>setIsOpen</b> відповідно.
                  </p>
                </div>
                <div class="bcg-box print-fs-12">
                  <p>
                    const App = () => {<br />
                       
                    <b
                      >const [clicks, setClicks] =
                      useState(0)</b
                    >;<br />
                       
                    <b
                      >const [isOpen, setIsOpen] =
                      useState(false)</b
                    >;<br />
                        const handleClick = () => {<br />
                            setClicks(clicks + 1);<br />
                        };<br />
                        const handleToggle = () => {<br />
                            setIsOpen(!isOpen);<br />
                        }; <br />
                        return (<br />
                            &#60;><br />
                                &#60;button
                    onClick={handleClick}>Current:
                    {clicks}&#60;/button><br />
                                &#60;button
                    onClick={handleToggle}><br />
                                    {isOpen ? "Hide" :
                    "Show"}<br />
                                &#60;/button><br />
                                {isOpen && &#60;div>Now you
                    can see me!&#60;/div>}<br />
                            &#60;/><br />
                        );<br />
                    };
                  </p>
                </div>
              </div>
            </section>

            <!-- Ізоляція стану -->
            <section class="sub-section">
              <h4 class="m-bottom-min">Ізоляція стану</h4>

              <div class="flex">
                <div>
                  <p class="m-bottom-min">
                    Стан є локальним для екземпляра
                    компонента. Якщо відобразити один і той
                    самий компонент декілька разів, кожна
                    копія матиме абсолютно ізольований стан!
                    Зміна одного з них не вплине на інший.
                  </p>
                  <p class="border-box">
                    <b>Важливо!</b> Компонент
                    <b>App</b> нічого не знає про стан. На
                    відміну від <b>props</b>, стан є
                    повністю приватним для компонента, що
                    його визначає.
                    <b
                      >Батьківський компонент не може його
                      змінити.</b
                    >
                    Це дозволяє додавати чи видаляти стан до
                    компонента без впливу на решту
                    компонентів.
                  </p>
                </div>
                <div class="bcg-box print-fs-12">
                  <p>
                    const ClickCounter = () => {<br />
                        const [clicks, setClicks] =
                    useState(0);<br />
                        const handleClick = () => {<br />
                            setClicks(clicks + 1);<br />
                        };<br />
                        return &#60;button
                    onClick={handleClick}>Current:
                    {clicks}&#60;/button><br />
                    };<br />

                    const App = () => {<br />
                        return (<br />
                            &#60;><br />
                                &#60;ClickCounter /><br />
                                &#60;ClickCounter /><br />
                            &#60;/><br />
                        );<br />
                    };
                  </p>
                </div>
              </div>
            </section>

            <!-- Підняття стану -->
            <section class="sub-section new-page">
              <h4 class="m-bottom-min">Підняття стану</h4>

              <div class="flex">
                <div>
                  <p class="m-bottom-min">
                    Для того щоб стан відстежувався одразу
                    на двох компонентах, його необхідно
                    створити на спільному батьку. При цьому,
                    дочірні компоненти ничого не будуть
                    знати про стан батька-компонента.
                  </p>
                  <p>
                    Через пропси необхідно передати значення
                    стану та метод зміни стану.
                  </p>
                </div>
                <div class="bcg-box print-fs-12">
                  <p>
                    const ClickCounter = ({ <b>value</b>,
                    <b>onUpdate</b> }) => {<br />
                        return &#60;button
                    onClick={<b>onUpdate</b>}>Current:
                    {<b>value</b>}&#60;/button><br />
                    };<br />
                    const App = () => {<br />
                        const [clicks, setClicks] =
                    useState(0);<br />
                        const <i>handleClick</i> = () =>
                    setClicks(clicks + 1);<br />
                        return (<br />
                        &#60;><br />
                            &#60;ClickCounter
                    <b>value</b>={clicks}
                    <b>onUpdate</b>={<i>handleClick</i>}
                    /><br />
                            &#60;ClickCounter
                    <b>value</b>={clicks}
                    <b>onUpdate</b>={<i>handleClick</i>}
                    /><br />
                        &#60;/><br />
                        );<br />
                    };<br />
                  </p>
                </div>
              </div>
            </section>

            <!-- Обмеження хуків -->
            <section class="sub-section">
              <h4 class="m-bottom-min">Обмеження хуків</h4>

              <div class="flex">
                <div>
                  <p class="m-bottom-min">
                    Будь-які хуки можна викликати лише на
                    верхньому рівні функції компонента. Це
                    означає, що хуки повинні
                    <b
                      >знаходитися безпосередньо в тілі
                      функції компонента</b
                    >, а не всередині циклів, умов,
                    вкладених функцій і так далі.
                  </p>
                  <p class="border-box">
                    <b>Важливо!</b> Викликати хуки лише на
                    верхньому рівні функції компонента, так
                    само, як імпортування модулів лише на
                    верхньому рівні файлу.
                  </p>
                </div>
                <div class="bcg-box print-fs-12">
                  <p>
                    const App = () => {<br />
                        // ❌ Буде помилка<br />
                        if (isLoggedIn) {<br />
                            const [username, setUsername] =
                    useState("");<br />
                        }<br />
                        // ❌ Буде помилка<br />
                        for(let i = 0; i < 10; i++) {<br />
                            const [valiue, setValue] =
                    useState(0);<br />
                        }<br />
                    };<br />
                    // ✅ Так правильно<br />
                    const App = () => {<br />
                        const [username, setUsername] =
                    useState("");<br />
                        const [valiue, setValue] =
                    useState(0);<br />
                    };
                  </p>
                </div>
              </div>
            </section>

            <!-- Оновлення об'єктів -->
            <section class="sub-section">
              <h4 class="m-bottom-min">
                Оновлення об'єктів
              </h4>

              <div class="flex">
                <div>
                  <p class="m-bottom-min">
                    Стан може містити будь-який тип
                    значення, включаючи об'єкти.
                  </p>
                  <p class="m-bottom-min">
                    Оновлювати дані об'єкту мутацією
                    <b>не можна</b>
                    <b
                      >( const updateX = () => values.x += 1
                      )</b
                    >
                  </p>
                  <p class="m-bottom-min">
                    Об'єкти, як і будь-який інший стан,
                    оновлюються за допомогою
                    <b>функції-сеттера.</b>
                    (<b>setValues</b>).
                  </p>
                  <div class="border-box">
                    <p class="m-bottom-min">
                      <b>Важливо!</b> Якщо в об'єкті більше
                      однієї властивості, то при оновлені
                      будь-якої з них, усі інщі - зникнить
                      (функція-сеттер записує отримане
                      значення (об'єкт) поверх існуючого
                      стану). Для того щоб цього уникнути
                      потрібно зробити копію існуючого
                      (<b>spread</b>).
                    </p>

                    <div class="bcg-box">
                      <p>
                        const updateX = () => {<br />
                            setValues({<br />
                                ...values,<br />
                                x: values.x + 1<br />
                            });<br />
                        };
                      </p>
                    </div>
                  </div>
                </div>

                <div class="bcg-box print-fs-12">
                  <p>
                    const App = () => {<br />
                        const [values, setValues] =
                    useState({<br />
                            x: 0,<br />
                            y: 0,<br />
                        });<br />
                    const updateX = () => {<br />
                    <b
                      >    setValues({<br />
                              ...values,<br />
                              x: values.x + 1<br />
                          })</b
                    >;<br />
                    };<br />
                    const updateY = () => {<br />
                    <b
                      >    setValues({<br />
                              ...values,<br />
                              y: values.y + 1<br />
                          })</b
                    >;<br />
                    };<br />
                    <br />
                        return (<br />
                            &#60;div><br />
                                &#60;p> x: {values.x}, y:
                    {values.y} &#60;/p><br />
                            <br />
                                &#60;button
                    onClick={updateX}>Update
                    x&#60;/button><br />
                                &#60;button
                    onClick={updateY}>Update
                    y&#60;/button><br />
                            &#60;/div><br />
                        );<br />
                    };
                  </p>
                </div>
              </div>
            </section>
          </section>

          <!-- Хук useEffect -->
          <section id="useEffect" class="section new-page">
            <h3 class="m-bottom-min">Хук useEffect</h3>
            <div class="m-bottom">
              <div class="m-bottom-min flex">
                <div>
                  <p>
                    Хук
                    <b>useEffect(callback, deps)</b>
                    оголошує ефект при зміні стану, який
                    приймає два аргументи:
                  </p>
                  <ul class="m-bottom-min">
                    <li>
                      <b>callback</b> - завжди є анонімною
                      функцією, всередині якої виконується
                      вся логіка ефекту. Наприклад, запити
                      на сервер, запис у локальне сховище і
                      т.п.;
                    </li>
                    <li>
                      <b>deps</b> - це масив залежностей
                      ефекту. Коли будь-яка з цих
                      залежностей змінюється, ефект буде
                      викликаний і виконувати callback. Це
                      може бути стан, пропси або будь-яке
                      локальне значення всередині
                      компонента.
                    </li>
                  </ul>
                  <p>
                    Якщо не передати масив залежностей,
                    ефект буде викликаний при кожному
                    оновленні компонента, тобто кожного
                    разу, коли компонент оновлюється.
                  </p>
                </div>
                <div class="bcg-box">
                  <p>
                    import { useState, useEffect } from
                    "react";<br />
                    <br />
                    const App = () => {<br />
                        const [clicks, setClicks] =
                    useState(0);<br />
                    <br />
                       
                    <b
                      >useEffect(() => {<br />
                              document.title = `You clicked
                      ${clicks} times`;<br />
                          })</b
                    >;<br />
                    <br />
                        return (<br />
                            &#60;button onClick={() =>
                    setClicks(clicks + 1)}><br />
                                You clicked {clicks}
                    times<br />
                            &#60;/button><br />
                        );<br />
                    };
                  </p>
                </div>
              </div>
              <p class="border-box">
                <b>Важливо!</b> Хук <b>useEffect</b> не
                повертає жодного значення як результат своєї
                роботи, а лише запускає виконання анонімної
                функції. Іншими словами, неможливо виконати
                в середині функції обчислення і повернути їх
                у зовнішній код. Ефекти не призначені для
                цього!.
              </p>
            </div>

            <!-- Етап монтування -->
            <section class="sub-section">
              <h4 class="m-bottom-min">Етап монтування</h4>
              <div class="m-bottom">
                <div class="flex">
                  <p>
                    Якщо другим аргументом хука useEffect
                    передати
                    <b>порожній масив</b>, то такий ефект
                    виконається лише
                    <i
                      >один раз - на етапі монтування
                      компонента</i
                    >, і більше ніколи. Такі ефекти
                    використовуються для виконання коду без
                    очікування дій користувача.
                  </p>
                  <div class="bcg-box">
                    <p>
                      useEffect(() => {<br />
                          // ...<br />
                      }, <b>[]</b> )<br />
                    </p>
                  </div>
                </div>
                <p>Наприклад:</p>
                <ul>
                  <li>
                    HTTP-запити за початковими даними;
                  </li>
                  <li>додавання слухачів на документ;</li>
                  <li>запуск таймерів;</li>
                  <li>зчитування з локального сховища.</li>
                </ul>
              </div>

              <!-- Суворий режим -->
              <section class="inner-section">
                <h5 class="m-bottom-min">Суворий режим</h5>
                <div class="m-bottom">
                  <div class="m-bottom flex">
                    <div>
                      <p class="m-bottom-min">
                        Після монтування компонента в
                        консолі відображається одне й те ж
                        повідомлення двічі, а не один раз.
                        Це пов'язано з компонентом
                        <b>React.StrictMode</b>, який в
                        режимі розробки виконує ряд
                        перевірок нашого коду.
                      </p>
                    </div>
                    <div class="bcg-box">
                      <p>
                        ReactDOM.createRoot(document.getElementById("root"))<br />
                            .render(<br />
                                <b>&#60;React.StrictMode></b
                        ><br />
                                    &#60;App /><br />
                               
                        <b>&#60;/React.StrictMode></b><br />
                        );
                      </p>
                    </div>
                  </div>
                  <p class="m-bottom-min">
                    Окрім перевірок, суворий режим виконує
                    подвійне монтування кожного компонента в
                    додатку, щоб гарантувати стресостійкість
                    коду, особливо тієї його частини, де
                    працюємо зі станом і його оновленням.
                  </p>
                  <p>
                    Алгоритм дій для компонента <b>App</b>.
                  </p>
                  <ul>
                    <li>
                      Компонент App монтується в DOM вперше.
                    </li>
                    <li>
                      Виконується ефект, і в консоль
                      виводиться повідомлення.
                    </li>
                    <li>
                      Компонент App розмонтується і
                      видаляється з DOM.
                    </li>
                    <li>
                      Компонент App монтується в DOM вдруге.
                    </li>
                    <li>
                      Виконується ефект, і в консоль
                      виводиться повідомлення.
                    </li>
                    <li>
                      Компонент залишається в DOM і готовий
                      до оновлень.
                    </li>
                  </ul>
                </div>
              </section>
            </section>

            <!-- Етап розмонтування -->
            <section class="sub-section">
              <h4 class="m-bottom-min new-page">
                Етап розмонтування
              </h4>
              <div class="m-bottom flex">
                <div>
                  <p class="m-bottom-min">
                    При розмонтуванні компонента, можна
                    стикнутися з необхідністю
                    <b>"почистити за собою"</b>, наприклад,
                    знімати обробники подій, зупиняти
                    таймери та скасовувати HTTP-запити і
                    таке інше.
                  </p>
                  <p>
                    Хук useEffect може оголошувати функцію
                    очищення ефекту, для цього
                    <b
                      >з колбек-функції потрібно повернути
                      ще одну функцію</b
                    >.
                  </p>
                </div>
                <div class="bcg-box">
                  <p>
                    const Modal = () => {<br />
                        useEffect(() => {<br />
                           
                    <i
                      >// Зберігаємо ідентифікатор інтервалу
                      в змінну</i
                    ><br />
                            const intervalId =
                    setInterval(() => {<br />
                                console.log(`Interval -
                    ${Date.now()}`);<br />
                            }, 2000);<br />
                            <b>return () => {</b><br />
                               
                    <i
                      >// Очищаємо інтервал за його
                      ідентифікатором</i
                    ><br />
                               
                    <b>clearInterval(intervalId);</b><br />
                            <b>}</b>;<br />
                        }, []);<br />
                        <br />
                        return &#60;div>Modal&#60;/div>;<br />
                    };<br />
                    <br />
                    const App = () => {<br />
                        const [isOpen, setIsOpen] =
                    useState(false);<br />
                        return (<br />
                            &#60;div><br />
                                &#60;button onClick={() =>
                    setIsOpen(!isOpen)}><br />
                                    {isOpen ? "Close" :
                    "Open"}<br />
                                &#60;/button><br />
                                {isOpen && <Modal />}<br />
                            &#60;/div><br />
                        );<br />
                    };
                  </p>
                </div>
              </div>
            </section>

            <!-- Етап оновлення -->
            <section class="sub-section">
              <h4 class="m-bottom-min">Етап оновлення</h4>
              <div class="m-bottom flex">
                <div>
                  <p class="m-bottom-min">
                    Ефект з
                    <b>без масиву залежностей</b> буде
                    запускатися при кожному оновленні
                    компонента
                  </p>

                  <p class="m-bottom-min">
                    Ефект з
                    <b>пустим масивом залежностей</b> буде
                    запускатися лише один раз - на етапі
                    монтування компонента
                  </p>

                  <p class="m-bottom-min">
                    Ефект <b>з масивом залежностей</b> буде
                    запускатися один раз після монтажу
                    компонента, а потім кожного разу після
                    оновлення будь-якої залежності
                  </p>
                  <p class="border-box">
                    <b>Цікаво</b> Розширення у VSC
                    <b>ESLint</b> підкреслює масив
                    залежностей, якщо невірно вказані
                    обов'язкові наявні зовнішніх зміних
                    (стан, пропси і т.п.)
                  </p>
                </div>
                <div class="bcg-box">
                  <p>
                    import { useState, useEffect } from
                    "react";<br />
                    <br />
                    const App = () => {<br />
                        const [clicks, setClicks] =
                    useState(0);<br />
                    <br />
                        useEffect(() => {<br />
                            console.log("Clicks updated: ",
                    clicks);<br />
                        }, [<b>clicks</b>]);<br />
                    <br />
                        return (<br />
                            &#60;button onClick={() =>
                    setClicks(clicks + 1)}><br />
                                You clicked {clicks}
                    times<br />
                            &#60;/button><br />
                        );<br />
                    };
                  </p>
                </div>
              </div>
            </section>

            <!-- Декілька ефектів -->
            <section class="sub-section">
              <h4 class="m-bottom-min new-page">
                Декілька ефектів
              </h4>
              <div>
                <div>
                  <p class="m-bottom-min">
                    У компоненті можна оголошувати стільки
                    ефектів, скільки потрібно. Це дозволяє
                    згрупувати логіку, створивши ефект для
                    кожної незалежної операції.
                  </p>
                </div>
                <div class="m-bottom-min flex">
                  <div>
                    <p class="m-bottom-min">
                      Коли в компоненті є кілька станів,
                      можна використовувати ефекти, щоб
                      реагувати на зміни будь-якої
                      комбінації значень і виконувати певний
                      код.
                    </p>
                    <p class="border-box">
                      <b>Важливо!</b> Кожен з цих ефектів
                      виконається також при монтуванні
                      компонента
                    </p>
                  </div>
                  <div class="bcg-box">
                    <p>
                      import { useState, useEffect } from
                      "react";<br />
                      <br />
                      const App = () => {<br />
                          const [clicks, setClicks] =
                      useState(0);<br />
                      <br />
                          <b>useEffect</b>(() => {<br />
                              console.log("You can see me
                      only once!");<br />
                          }, <b>[]</b>);<br />
                      <br />
                          <b>useEffect</b>(() => {<br />
                              console.log("Clicks updated:
                      ", clicks);<br />
                          }, <b>[clicks]</b>);<br />
                      <br />
                          <b>useEffect</b>(() => {<br />
                              document.title = `You clicked
                      ${clicks}`;<br />
                          });<br />
                      <br />
                          return (<br />
                              &#60;button onClick={<br />
                                  () => setClicks(clicks +
                      1)<br />
                              }><br />
                                  You clicked {clicks}
                      times<br />
                              &#60;/button><br />
                          );<br />
                      };
                    </p>
                  </div>
                  <div class="bcg-box">
                    <p>
                      const App = () => {<br />
                          const [first, setFirst] =
                      useState(0);<br />
                          const [second, setSecond] =
                      useState(0);<br />
                          <b>useEffect</b>(() => {<br />
                              console.log("First updated: ",
                      first);<br />
                          }, [<b>first</b>]);<br />
                          <b>useEffect</b>(() => {<br />
                              console.log("Second updated:
                      ", second);<br />
                          }, [<b>second</b>]);<br />
                          <b>useEffect</b>(() => {<br />
                              console.log(<br />
                                  "First or second updated:
                      ",<br />
                                  first + second);<br />
                          }, [<b>first, second</b>]);<br />
                      <br />
                          return (<br />
                              &#60;><br />
                                  &#60;button onClick={() =>
                      setFirst(first + 1)}><br />
                                      First: {first}<br />
                                  &#60;/button><br />
                                  &#60;button onClick={<br />
                                      () => setSecond(second
                      + 1)<br />
                                  }><br />
                                      Second: {second}<br />
                                  &#60;/button><br />
                              &#60;/><br />
                          );<br />
                      };
                    </p>
                  </div>
                </div>
              </div>
            </section>
          </section>

          <!-- Хук useRef -->
          <section id="useRef" class="section new-page">
            <h3 id="useRef" class="m-bottom center-text">
              Хук useRef
            </h3>

            <p>
              <b>Рефи</b> дозволяють отримати прямий доступ
              до DOM-вузлів або React-елементів із шаблону
              компонента. Вони використовуються якщо
              необхідно звернутися до DOM-методів та
              властивостей елемента.
            </p>
            <ul class="m-bottom-min">
              <li>
                Фокус елемента під час події, виділення
                тексту.
              </li>
              <li>Контроль програвання медіаконтенту.</li>
              <li>Інтеграція з DOM-бібліотеками.</li>
              <li>
                Доступ до DOM-властивостей, значення яких
                неможливо отримати по-іншому - розміри
                елемента, значення скрола тощо.
              </li>
            </ul>

            <div class="m-bottom flex">
              <p>
                Рефи створюються хуком
                <b>useRef()</b> та прив'язані до
                React-елементів за допомогою атрибуту ref
                (скорочення від reference), який зберігатиме
                посилання на DOM-елемент.
              </p>
              <div class="bcg-box">
                <p>
                  <b>import { useRef } from "react"</b
                  >;<br />
                  <br />
                  const App = () => {<br />
                     
                  <b>const btnRef = useRef()</b>;<br />
                      <br />
                      return &#60;button
                  <b>ref="{btnRef}"</b>>Button with
                  ref&#60;/button >;<br />
                  };
                </p>
              </div>
            </div>

            <!-- Життєвий цикл рефа -->
            <div class="m-bottom">
              <h4 class="m-bottom-min">
                Життєвий цикл рефа
              </h4>

              <p>
                React надає властивості <b>current</b>
                <i>посилання на DOM-елемент</i> коли
                компонент монтується та <i>undefined</i> при
                розмонтуванні, тому
                <b
                  >значення рефа доступне тільки після
                  монтування</b
                >.
              </p>

              <ul>
                <li>
                  <i>на першому рендері</i> буде
                  <b>undefined</b> - посилання на
                  DOM-елемент всі наступні;
                </li>
                <li>
                  ефекти (<b>useEffect</b>) виконуються
                  після монтування, тому завжди буде
                  посиланням на DOM-елемент;
                </li>
                <li>
                  <b>функції-події</b> будуть після
                  монтування, тому завжди буде посиланням на
                  DOM-елемент.
                </li>
              </ul>
            </div>

            <!-- Відсутність реактивності -->
            <div class="m-bottom flex">
              <div class="">
                <div class="m-bottom-min">
                  <h4 class="m-bottom-min">
                    Відсутність реактивності
                  </h4>
                  <p class="m-bottom-min">
                    Рефи це не стан, тобто вони не
                    реактивні, тому зміна значення рефа не
                    впливає на оновлення компонента і не
                    викликає повторний рендер.
                  </p>

                  <p>
                    Рефи також можна використовувати як
                    сховище довільних значень, які не
                    змінюються між рендерами компонента та
                    на нього не впливають.
                  </p>
                </div>

                <!-- Приклад. Відеоплеєр -->

                <div class="m-bottom-min">
                  <h4 class="m-bottom-min">
                    Приклад. Відеоплеєр &#10142;
                  </h4>

                  <p class="m-bottom-min">
                    Створимо компонент <b>Player</b> для
                    програвання відео, використовуючи
                    нативний тег <i>&#60;video></i>. Щоб
                    запустити та зупинити програвання
                    необхідно викликати методи
                    <b>HTMLMediaElement.play()</b> та
                    <b>HTMLMediaElement.pause()</b>, де
                    <b>HTMLMediaElement</b> це елемент
                    <i>&#60;video></i>. Використовуємо реф
                    для отримання доступу до DOM-елементу та
                    його методам.
                  </p>
                </div>

                <div
                  class="bcg-box print-fs-14 print-m-left-none"
                >
                  <p>
                    import { forwardRef, useRef, useEffect }
                    from "react";<br />
                    <br />
                    const CustomButton = forwardRef((props,
                    ref) => (<br />
                        &#60;button
                    ref={ref}>{props.children}&#60;/button><br />
                    ));<br />
                    <br />
                    const App = () => {<br />
                        const btnRef = useRef();<br />
                    <br />
                        useEffect(() =>
                    btnRef.current.focus(), []);<br />
                    <br />
                        return &#60;CustomButton
                    ref={btnRef}><br />
                            Button with forwarded ref<br />
                    &#60;/CustomButton>;<br />
                    };
                  </p>
                </div>
              </div>

              <!-- Перенаправлення рефів -->
              <div>
                <div
                  class="bcg-box print-fs-14 m-bottom-min"
                >
                  <p>
                    import { useRef } from "react";<br />
                    <br />
                    const Player = ({ source }) => {<br />
                        const playerRef = useRef();<br />
                        const play = () =>
                    playerRef.current.play();<br />
                        const pause = () =>
                    playerRef.current.pause();<br />
                        <br />
                        return (<br />
                            &#60;div><br />
                                &#60;video ref={playerRef}
                    src={source}><br />
                                    Sorry, your browser does
                    not<br />
                                        support embedded
                    videos.<br />
                                &#60;/video><br />
                                &#60;div><br />
                                    &#60;button
                    onClick={play}>Play&#60;/button><br />
                                    &#60;button
                    onClick={pause}>Pause&#60;/button><br />
                                &#60;/div><br />
                            &#60;/div><br />
                        );<br />
                    };<br />
                    <br />
                    const App = () => {<br />
                        return &#60;Player<br />
                           
                    source=&#60;http://.../trailer.mp4>"/>;<br />
                    };
                  </p>
                </div>

                <div>
                  <h4 class="m-bottom-min">
                    &#129044; Перенаправлення рефів
                  </h4>

                  <p>
                    При використанні рефів на компоненті,
                    <i>проп</i> <b>ref</b>
                    <i>не передається автоматично</i>. Це
                    створює проблеми у випадку коли
                    необхідно отримати <b>ref</b> на елемент
                    усередині самого компонента, а не на сам
                    компонент. Для цього використовується
                    функція <b>forwardRef</b>.
                  </p>
                </div>
              </div>
            </div>
          </section>

          <!-- Context, useContext -->
          <section id="useContext" class="section new-page">
            <h3 class="m-bottom center-text">
              Context, useContext
            </h3>

            <!-- Context -->
            <h4 class="m-bottom-min">Context</h4>
            <div class="m-bottom-min">
              <p class="m-bottom-min">
                Контекст забезпечує спосіб передачі даних
                глибоко по дереву компонентів без
                необхідності явно передавати пропси в
                проміжні компоненти вручну на кожному рівні.
                Тобто це щось схоже на глобальну змінну, до
                якої можна отримати доступ в будь-якій
                частині вашого коду.
              </p>
              <p class="m-bottom-min border-box">
                <b>Важливо!</b> Контекст не використовується
                для уникнення передачі пропсів на кілька
                рівнів вниз. Цей механізм призначений для
                вузького спектра завдань.
              </p>

              <div class="m-bottom-min flex">
                <p>
                  Для створення контексту використовується
                  вбудована
                  <i>функція</i> <b>createContext</b>.
                  Результатом виклику цієї функції є
                  <i>об'єкт контексту</i>.
                </p>
                <div class="bcg-box">
                  <p>
                    import { <b>createContext</b> } from
                    "react";<br />
                    <b>const myContext = createContext()</b
                    >;
                  </p>
                </div>
              </div>
              <p>
                <i>Функції</i> <b>createContext</b> можна
                передати один аргумент - значення контексту
                за замовчуванням. На практиці, зазвичай його
                не вказують, оскільки намагатися отримати
                доступ до контексту, якого немає, не має
                сенсу.
              </p>
            </div>

            <!-- Компонент <Provider> -->
            <h5 class="m-bottom-min">
              Компонент &#60;Provider>
            </h5>
            <div class="m-bottom flex">
              <div>
                <p>
                  У об'єкта контексту є властивість
                  <b>Provider</b> - компонент, який
                  використовується для передачі контексту,
                  щоб компоненти могли отримувати доступ до
                  значення контексту.
                </p>
                <ul>
                  <li>
                    Обгортає всі компоненти додатка, так як
                    в нього вкладений компонент
                    <b>App</b>.
                  </li>
                  <li>
                    Приймає проп <b>value</b> - значення
                    контексту, яке буде доступне
                    компонентам.
                  </li>
                  <li>
                    Дозволяє компонентам підписуватись на
                    зміни контексту незалежно від глибини
                    вкладеності.
                  </li>
                </ul>
              </div>
              <div class="bcg-box">
                <p>
                  import { createContext } from "react";<br />
                  import ReactDOM from
                  "react-dom/client";<br />
                  <br />
                  const myContext = createContext();<br />
                  <br />
                  ReactDOM.createRoot(document.getElementById("root"))<br />
                      .render(<br />
                          &#60;myContext.Provider value={{
                  username: "Mango" }}><br />
                              &#60;App /><br />
                          &#60;/myContext.Provider><br />
                  );
                </p>
              </div>
            </div>

            <!-- Хук useContext() -->
            <h4 class="m-bottom-min">Хук useContext()</h4>
            <div class="m-bottom flex">
              <div>
                <p>
                  Дозволяє будь-якому вкладеному компоненту
                  отримати доступ до поточного значення
                  контексту.
                </p>
                <ul>
                  <li>
                    Використовується в компонентах для
                    доступу до контексту.
                  </li>
                  <li>
                    Очікує єдиний аргумент – посилання на
                    створений контекст.
                  </li>
                  <li>
                    Повертає значення контексту від
                    провайдера.
                  </li>
                  <li>
                    Кожного разу, коли змінюється значення
                    контексту, залежний компонент
                    оновлюється.
                  </li>
                </ul>
              </div>
              <div class="bcg-box">
                <p>
                  import { createContext, useContext } from
                  "react";<br />
                  <br />
                  const myContext = createContext();<br />
                  <br />
                  const contextValue =
                  useContext(myContext);
                </p>
              </div>
            </div>

            <div class="m-bottom flex">
              <p class="">
                Кожного разу імпортувати посилання на об'єкт
                контексту може бути не дуже зручно. Тому
                створюється власний хук для доступу до
                контексту.
              </p>
              <div class="bcg-box">
                <p>
                  import { createContext, useContext } from
                  "react";<br />
                  <br />
                  const myContext = createContext();<br />
                  <br />
                  <i
                    >// Імпортуємо та використовуємо цей хук
                    у компонентах </i
                  ><br />
                  export const useMyContext = () =>
                  useContext(myContext);
                </p>
              </div>
            </div>

            <!-- Приклад. Контекст користувача -->
            <h4 class="m-bottom-min new-page">
              Приклад. Контекст користувача
            </h4>
            <div class="m-bottom flex">
              <div>
                <p class="m-bottom-min">
                  <b>1</b>. Створимо контекст для зберігання
                  інформації про поточний стан користувача -
                  статусу логіну та особистої інформації
                  <b>userContext.js</b>.
                </p>
                <div
                  class="m-bottom-min bcg-box print-m-left-none print-fs-13"
                >
                  <p>
                    <i>// src/userContext.js</i><br />
                    import { createContext, useContext }
                    from "react";<br />
                    <br />
                    export const userContext =
                    createContext();<br />
                    <br />
                    export const useUser = () =>
                    useContext(userContext);
                  </p>
                </div>

                <p class="m-bottom-min">
                  <b>2</b>. Обгорнемо все дерево компонентів
                  провайдером. Це можна зробити в головному
                  файлі <b>main.jsx</b>.
                </p>
                <div class="bcg-box print-fs-13">
                  <p>
                    <i>// src/main.jsx</i><br />
                    import ReactDOM from
                    "react-dom/client";<br />
                    import { userContext } from
                    "./userContext";<br />
                    <br />
                    const contextValue = { <br />
                        username: "Mango", <br />
                        isLoggedIn: true <br />
                    };<br />

                    ReactDOM.createRoot(document.getElementById("root"))<br />
                        .render(<br />
                            &#60;userContext.Provider
                    value={contextValue}><br />
                                &#60;App /><br />
                            &#60;/userContext.Provider><br />
                        );
                  </p>
                </div>
              </div>

              <div>
                <p class="m-bottom-min">
                  <b>3</b>. Додамо компонент меню
                  користувача, вкладений у <b>App.jsx</b>. В
                  ньому будемо отримувати значення контексту
                  та відображати ім'я користувача. Рендеримо
                  меню користувача <i>UserMenu</i>.
                </p>
                <div
                  class="m-bottom-min bcg-box print-fs-13"
                >
                  <p>
                    <i>// src/components/App.jsx</i><br />
                    import { UserMenu } from
                    "./UserMenu";<br />
                    const App = () => {<br />
                        return (<br />
                            &#60;div>&#60;UserMenu
                    />&#60;/div><br />
                        );<br />
                    };
                  </p>
                </div>

                <p class="m-bottom-min">
                  <b>4</b>. Використовуємо власний хук
                  <b>useUser</b> в <b>UserMenu</b> для
                  доступу до значення контексту та виводимо
                  ім'я користувача.
                </p>
                <div
                  class="m-bottom-min bcg-box print-fs-13"
                >
                  <p>
                    <i>// src/components/UserMenu.jsx </i
                    ><br />
                    import { useUser } from
                    "../userContext";<br />
                    export const UserMenu = () => {<br />
                        const { username } = useUser();<br />
                        return (<br />
                            &#60;div><br />
                                &#60;p>Welcome,
                    {username}!&#60;/p><br />
                                &#60;button>Log
                    out&#60;/button><br />
                            &#60;/div><br />
                        );<br />
                    };
                  </p>
                </div>
              </div>
            </div>

            <h5 class="m-bottom-min">
              Кастомний компонент провайдера
            </h5>
            <div class="flex">
              <div>
                <p class="m-bottom-min">
                  До цого значення контексту не динамічне.
                  Користувач може зареєструватися та
                  розлогінитися, зберігатимемо це в стані
                  компонента і методи для його зміни.
                </p>
                <div
                  class="bcg-box print-m-left-none print-fs-13"
                >
                  <p>
                    <i>// src/userContext.jsx</i><br />
                    import { createContext, useContext,
                    useState } from "react";<br />
                    const userContext = createContext();<br />
                    export const useUser = () =>
                    useContext(userContext);<br />
                    export const UserProvider = ({ children
                    }) => {<br />
                        const [ isLoggedIn, setIsLoggedIn ]
                    = useState(false);<br />
                        const [ username, setUsername ] =
                    useState(null);<br />
                        const logIn = () => {<br />
                            setIsLoggedIn(true);<br />
                            setUsername("Mango");<br />
                        };<br />
                        const logOut = () => {<br />
                            setIsLoggedIn(false);<br />
                            setUsername(null);<br />
                        };<br />
                            return (<br />
                            &#60;userContext.Provider
                    value={{<br />
                                isLoggedIn, username, logIn,
                    logOut<br />
                            }}><br />
                                {children}<br />
                            &#60;/userContext.Provider><br />
                        );<br />
                    };
                  </p>
                </div>
              </div>

              <div>
                <div
                  class="m-bottom-min bcg-box print-fs-13"
                >
                  <p>
                    <i>// src/main.jsx </i><br />
                    import { UserProvider } from
                    "./userContext";<br />

                    ReactDOM.createRoot(document.getElementById("root"))<br />
                        .render(<br />
                            &#60;UserProvider><br />
                                &#60;App /><br />
                            &#60;/UserProvider><br />
                    );
                  </p>
                </div>

                <div class="bcg-box print-fs-13">
                  <p>
                    <i>// src/components/UserMenu.jsx</i
                    ><br />

                    import { useUser } from
                    "../userContext";<br />

                    export const UserMenu = () => {<br />
                        const { isLoggedIn, username,
                    logOut, logIn } = useUser();<br />
                            return (<br />
                            &#60;div><br />
                                {isLoggedIn ? (<br />
                                    &#60;><br />
                                       
                    &#60;p>{username}&#60;/p><br />
                                        &#60;button
                    onClick={logOut}>Log out&#60;/button><br />
                                    &#60;/><br />
                                    ) : (<br />
                                        &#60;button
                    onClick={logIn}>Log in&#60;/button><br />
                                )}<br />
                            &#60;/div><br />
                        );<br />
                    };
                  </p>
                </div>
              </div>
            </div>
          </section>

          <!-- Хук useMemo -->
          <section id="useMemo" class="section new-page">
            <h3 class="m-bottom-min center-text">
              Хук useMemo
            </h3>

            <p class="m-bottom-min">
              Хук <b>useMemo</b> використовує концепцію
              мемоізації, метод оптимізації комп'ютерних
              програм шляхом збереження результатів викликів
              функції та повернення кешованого результату
              при повторенні тих самих вхідних даних.
              Мемоізована функція «запам'ятовує» результат
              обчислень відповідний набору аргументів.
              Наступні виклики з такими самими значеннями
              аргументів повертають запам'ятований
              результат, а не перераховують його.
            </p>

            <div class="m-bottom-min flex">
              <div>
                <p>
                  Хук useMemo приймає
                  <b>два аругменти</b>:
                </p>
                <ul>
                  <li>
                    Першим є анонімна функція, яка повертає
                    значення, саме вона буде мемоізована.
                  </li>
                  <li>
                    Другим є масив залежностей, при зміні
                    якоїсь з них, викликається функція
                    передана першим аргументом.
                  </li>
                </ul>
              </div>
              <div class="bcg-box">
                <p>
                  import { useMemo } from "react";<br />
                  <br />
                  const memoizedValue = useMemo(() => {<br />
                      return a + b;<br />
                  }, [a, b]);
                </p>
              </div>
            </div>

            <div class="m-bottom-min flex">
              <div>
                <p><b>Алгоритм</b> роботи хука useMemo:</p>
                <ul class="m-bottom-min">
                  <li>
                    При першому рендері компонента
                    викликається функція, результат
                    запам'ятовується і повертається як
                    результат роботи хука.
                  </li>
                  <li>
                    Якщо за наступних рендерів залежності не
                    змінюються, то хук не викликає функцію,
                    а просто повертає збережений результат
                    роботи.
                  </li>
                  <li>
                    Якщо будь-яка залежність змінилася, то
                    хук викликає функцію заново,
                    запам'ятовує нове значення та повертає
                    його.
                  </li>
                </ul>
                <div class="border-box">
                  <p class="m-bottom-min">
                    <b>Опис прикладу!</b>
                  </p>
                  <p class="m-bottom-min">
                    Кожного разу, коли зміниться значення
                    <b>planets</b> або <b>query</b>,
                    компонент буде оновлено.
                  </p>
                  <p class="m-bottom-min">
                    Компонент <b>App</b> містить додатковий
                    стан <b>clicks</b>, який ніяк
                    <i>не впливає на планети</i>.
                  </p>
                  <p>
                    Кожного разу, коли змінюється стан
                    <b>clicks</b>, компонент буде оновлено,
                    що призведе до обчислення
                    <b>filteredPlanets</b>, хоча значення
                    <b>planets</b> та <b>planets</b> не
                    змінилися! Оскільки метод
                    <b>filter</b> повертає посилання на
                    новий масив, React сприймає це як
                    абсолютно нові дані та список планет
                    буде відображено заново. У такому разі
                    варто мемоізувати обчислення
                    <b>filteredPlanets</b>.
                  </p>
                </div>
              </div>
              <div class="bcg-box">
                <p>
                  <b>import { useMemo } from "react"</b
                  >;<br />
                  <br />
                  const App = () => {<br />
                      const [<b>planets</b>, setPlanets] =
                  useState(<br />
                          ["Earth", "Mars", "Jupiter",
                  "Venus"]<br />
                      );<br />
                      const [<b>query</b>, setQuery] =
                  useState("");<br />
                      const [clicks, setClicks] =
                  useState(0);<br />
                      <br />
                     
                  <b
                    >const filteredPlanets = useMemo(<br />
                            () => planets.filter(<br />
                                planet =>
                    planet.includes(query)<br />
                            ),<br />
                            [planets, query]<br />
                        )</b
                  >;<br />
                      <br />
                      return (<br />
                          &#60;><br />
                              &#60;button onClick={<br />
                                  () => setClicks(clicks +
                  1)<br />
                              }><br />
                                  Number of clicks:
                  {clicks}<br />
                              &#60;/button><br />
                              &#60;ul><br />
                                 
                  {filteredPlanets.map(planet => (<br />
                                      &#60;li
                  key={planet}>{planet}&#60;/li><br />
                                  ))}<br />
                              &#60;/ul><br />
                          &#60;/><br />
                      );<br />
                  };
                </p>
              </div>
            </div>

            <p class="m-bottom-min">
              Те ж саме стосується дорогих операцій, таких
              як використання довгого циклу <b>for</b>.
              Дорогі обчислення можуть бути витратними за
              часом, що гарантовано призведе до погіршення
              роботи інтерфейсу.
            </p>

            <p>
              Не потрібно мемоізувати все поспіль, це може
              призвести до втрат продуктивності, оскільки
              мемоізація також займає обчислювальні ресурси.
              Найчастіше повторні прості обчислення
              обійдуться дешевше, ніж їхня мемоїзація.
              Використовуйте useMemo() точково, в першу
              чергу при роботі з масивами та для дорогих
              обчислень.
            </p>
          </section>

          <!-- Власні хуки -->
          <section id="own-hooks" class="section new-page">
            <h3 class="m-bottom center-text">
              Власні хуки
            </h3>

            <div class="m-bottom flex">
              <div>
                <p class="center-text"><b>Без хуку</b></p>
                <div
                  class="m-bottom-min bcg-box print-m-left-none print-fs-15"
                >
                  <p>
                    <i>// ComponentA.jsx</i><br />
                    const ComponentA = () => {<br />
                        const [isModalOpen, setIsModalOpen]
                    = useState(false);<br />
                        const openModal = () =>
                    setIsModalOpen(true);<br />
                        const closeModal = () =>
                    setIsModalOpen(false);<br />
                        <br />
                        return (<br />
                            &#60;><br />
                                &#60;button
                    onClick={openModal}><br />
                                    Open modal<br />
                                &#60;/button><br />
                                &#60;Modal<br />
                                    isOpen={isModalOpen}<br />
                                    onClose={closeModal}
                    <br />
                                /><br />
                            &#60;/><br />
                        );<br />
                    };<br />
                    <br />
                    <i>// ComponentB.jsx</i><br />
                    const ComponentB = () => {<br />
                        const [isSidebarOpen,
                    setIsSidebarOpen] = useState(false);<br />
                        const openSidebar = () =>
                    setIsSidebarOpen(true);<br />
                        const closeSidebar = () =>
                    setIsSidebarOpen(false);<br />
                        <br />
                        return (<br />
                            &#60;><br />
                                &#60;button
                    onClick={openSidebar}><br />
                                    Open sidebar<br />
                                &#60;/button><br />
                                &#60;Sidebar <br />
                                   
                    isOpen={isSidebarOpen}<br />
                                    onClose={closeSidebar}
                    <br />
                                /><br />
                            &#60;/><br />
                        );<br />
                    };<br />
                  </p>
                </div>
                <div class="m-bottom-min flex">
                  <p>
                    Хук <b>useToggle</b> в приховує у собі
                    створення стану та функцій роботи з ним
                    (open, close).
                  </p>
                  <p>&#10132;</p>
                </div>
                <p class="border-box">
                  Власний хук може приймати будь-які
                  аргументи і повертати будь-що, правил
                  немає, залежить від реалізації.
                </p>
              </div>
              <div>
                <p class="center-text">
                  <b>Із власним хуком</b>
                </p>

                <div
                  class="m-bottom-min bcg-box print-fs-15"
                >
                  <p>
                    <i>// src/hooks/useToggle.js</i><br />
                    export const <b>useToggle</b> = () =>
                    {<br />
                        const [isOpen, setIsOpen] =
                    useState(false);<br />
                        const open = () =>
                    setIsOpen(true);<br />
                        const close = () =>
                    setIsOpen(false);<br />
                        <br />
                        return { isOpen, open, close };<br />
                    };
                  </p>
                </div>
                <div class="bcg-box print-fs-15">
                  <p>
                    <i>// ComponentA.jsx</i><br />
                    import { <b>useToggle</b> } from
                    "../useToggle.js";<br />
                    const ComponentA = () => {<br />
                       
                    <b
                      >const { isOpen, open, close } =
                      useToggle()</b
                    >;<br />
                        <br />
                        return (<br />
                            &#60;><br />
                                &#60;button
                    onClick={open}><br />
                                    Open modal<br />
                                &#60;/button><br />
                                &#60;Modal<br />
                                    isOpen={isOpen}<br />
                                    onClose={close} <br />
                                /><br />
                            &#60;/><br />
                        );<br />
                    };<br />
                    <br />
                    <i>// ComponentB.jsx</i><br />
                    import { <b>useToggle</b> } from
                    "../useToggle.js";<br />
                    const ComponentB = () => {<br />
                       
                    <b
                      >const { isOpen, open, close } =
                      useToggle()</b
                    >;<br />
                        <br />
                        return (<br />
                            &#60;><br />
                                &#60;button
                    onClick={open}><br />
                                    Open sidebar<br />
                                &#60;/button><br />
                                &#60;Sidebar<br />
                                    isOpen={isOpen}<br />
                                    onClose={close} /><br />
                                &#60;/><br />
                        );<br />
                    };
                  </p>
                </div>
              </div>
            </div>

            <div class="flex">
              <p class="">
                Хук <b>useToggle</b> можна розширити так,
                щоб модальне вікно спочатку було відкритим.
                При цьому, за замовчуванням - закрите.
              </p>
              <div class="bcg-box print-fs-15">
                <p>
                  export const <b>useToggle</b> = (<b
                    >initialState = false</b
                  >) => {<br />
                      const [isOpen, setIsOpen] =
                  <b>useState(initialState)</b>;<br />
                         
                  <i
                    >// other code with func. "open" &
                    "clkse"</i
                  ><br />
                      return { isOpen, open, close };<br />
                  };<br />
                  <br />
                  const MyComponent = () => {<br />
                      const { isOpen, open, close } =
                  <b>useToggle(true)</b>;<br />
                          <i>// other code </i><br />
                  };
                </p>
              </div>
            </div>
          </section>
        </div>
      </section>
    </main>
  </body>
</html>
