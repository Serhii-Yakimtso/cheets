<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0"
    />
    <title>Обробка подій</title>
    <link rel="stylesheet" href="../../css/styles.css" />
    <link
      rel="stylesheet"
      href="../../css/styles-print.css"
    />
  </head>
  <body>
    <a class="print-home-link" href="../../index.html"
      >На головну</a
    >

    <h1 class="m-bottom center-text">Обробка подій</h1>
    <!-- Загальне -->
    <section class="section">
      <div class="container">
        <h2 class="m-bottom-min">Загальне</h2>
        <div class="m-bottom-min flex">
          <div>
            <p class="m-bottom-min">
              <b>Обробники подій</b> - це власні функції,
              які будуть викликані відповідно до взаємодій,
              таких як клікання, наведення, фокусування на
              полях введення форм і таке інше.
            </p>
            <p class="">
              Щоб додати обробник подій до JSX-елементу,
              потрібно передати йому проп, який описує тип
              події. Значенням пропа повинно бути посилання
              на функцію зворотного виклику, яка буде
              викликана при настанні події. Для цього
              необхідно:
            </p>
            <ul class="">
              <li>
                об'явити функцію всередині компонента
                (<b>handleClick</b>);
              </li>
              <li>
                задати в середині функції логіку
                (<b>alert</b>);
              </li>
              <li>
                додати пропс до JSX-коду
                (<b>onClick={handleClick}</b>).
              </li>
            </ul>
          </div>
          <div class="bcg-box">
            <p>
              const App = () => {<br />
                  const <b>handleClick</b> = () => {<br />
                      <b>alert</b>("I'm a button!");<br />
                  };<br />
                  return <br />
                  &#60;button
              <b>onClick={handleClick}</b>><br />
                      Click me!<br />
                  &#60;/button>;<br />
              };
            </p>
          </div>
        </div>
        <div class="m-bottom-min">
          <p>Основні моменти:</p>
          <ul class="">
            <li>
              <i>пропи</i> подій визначаються в React та
              мають ім'я в стилі <b>camelCase</b>, починаючи
              з префікса <b>on</b>, після чого йде назва
              події (<b>onClick, onSubmit, onChange</b>);
            </li>
            <li>
              <i>функції обробників подій</i> визначаються
              всередині компонентів (<b>handleClick</b>);
            </li>
            <li>
              за конвенцією ім'я обробника подій починається
              з
              <b>handle</b>,
              <i>за яким слідує назва події</i>
              (<b>onClick={handleClick}</b>).
            </li>
          </ul>
        </div>
        <div class="flex">
          <div>
            <p class="m-bottom-min">
              Можна визначити обробник подій безпосередньо
              всередині JSX як анонімну інлайн-функцію.
            </p>
            <p class="border-box">
              <b>Важливо!</b> Встроєні обробники подій
              зручні для коротких функцій. Але великі
              інлайн-функції в JSX можуть ускладнити
              читабельність розмітки компонента.
            </p>
          </div>
          <div class="bcg-box">
            <p>
              const App = () => {<br />
                  return <br />
                      &#60;button onClick={<b
                >() => alert("I'm a button!")</b
              >} ><br />
                          Click me!<br />
                      &#60;/button>;<br />
              };
            </p>
          </div>
        </div>
      </div>
    </section>

    <!-- Посилання на функцію -->
    <section class="section">
      <div class="container">
        <h2 class="m-bottom-min">Посилання на функцію</h2>
        <p class="m-bottom-min">
          Функції, які передаються обробникам подій, повинні
          бути передані як посилання, а не викликані.
        </p>
        <div class="flex">
          <div>
            <p class="m-bottom-min">
              У <i>першому</i> прикладі функція
              <b>handleClick</b> передається як обробник
              подій <b>onClick</b>. Це говорить React
              запам'ятати її і викликати лише тоді, коли
              користувач клікає кнопку.
            </p>
            <p class="m-bottom-min">
              У другому прикладі <b>дужки ()</b> в кінці
              <b>handleClick()</b>
              викликає функцію безпосередньо під час
              рендерингу, не дочекавшись події кліку.
            </p>
          </div>
          <div class="bcg-box">
            <p>
              <i>// ✅ Передача функції (правильно)</i
              ><br />
              &#60;button onClick={<b>handleClick</b>}>
              <br />
              <br />
              <i>// ❌ Виклик функції (неправильно)</i
              ><br />
              &#60;button onClick={<b>handleClick()</b>}>
            </p>
          </div>
        </div>
      </div>
    </section>

    <!-- Об'єкт події -->
    <section class="section print-m-bottom-max">
      <div class="container">
        <h2 class="m-bottom-min">Об'єкт події</h2>
        <div class="flex">
          <div>
            <p class="m-bottom-min">
              Callback-функція, яка передається як обробник
              події, незалежно від її типу, гарантовано
              отримає один аргумент -
              <b>об'єкт події</b> браузера.
            </p>
            <p class="border-box">
              <b>Цікаво!</b> Для подій браузера у React
              створюється об'єкт-обгортка
              <b>SyntheticEvent</b>, призначення якоі
              полягає в уникненні проблем, пов'язаних з
              кросбраузерністю. З точки зору розробника,
              використання SyntheticEvent не відрізняється
              від роботи з нативними подіями.
            </p>
          </div>
          <div class="bcg-box">
            <p>
              const App = () => {<br />
                  const
              <b>handleClick = evt => console.log(evt)</b
              >;<br />
                  return (<br />
                      &#60;><br />
                          &#60;button
              <b>onClick={handleClick}</b>>First
              button&#60;/button><br />
                          &#60;button
              <b>onClick={evt => console.log(evt)}</b
              >><br />
                              Second button<br />
                          &#60;/button><br />
                      &#60;/><br />
                  );<br />
              };
            </p>
          </div>
        </div>
      </div>
    </section>

    <!-- Читання props -->
    <section class="section">
      <div class="container">
        <h2 class="m-bottom-min">Читання props</h2>
        <div class="flex">
          <div>
            <p class="m-bottom-min">
              Обробники подій оголошуються всередині
              компонента, отже, вони
              <b>мають доступ до пропсів компонента</b>.
            </p>
          </div>
          <div class="bcg-box">
            <p>
              const Button = ({ <b>message</b>, children })
              => {<br />
                  return (<br />
                      &#60;button onClick={() =>
              alert(<b>message</b>)}> {children}
              &#60;/button><br />
                  );<br />
              };<br />
              <br />
              const App = () => {<br />
                  return (<br />
                      &#60;><br />
                          &#60;Button
              <b>message="Playing music!"</b>> Play music
              &#60;/Button><br />
                      &#60;/><br />
                  );<br />
              }
            </p>
          </div>
        </div>
      </div>
    </section>

    <!-- Стан компонента -->
    <section class="section">
      <div class="container">
        <h2 class="m-bottom-min">Стан компонента</h2>
        <div>
          <p class="m-bottom-min">
            Компонентам потрібно змінювати те, що
            відображається на екрані внаслідок взаємодії з
            користувачем (введення даних в форму повинно
            оновлювати поле вводу, клікання в слайдері
            зображень).
          </p>
          <p class="m-bottom-min">
            <b>Стан (state)</b> - вид пам'яті, що
            специфічний для компонента.
          </p>
          <p class="m-bottom-min">
            <b>Пропси (props)</b> - це дані, які передаються
            компоненту ззовні, а <b>стан (state)</b> - це
            його внутрішні динамічні дані.
          </p>
          <p class="m-bottom-min">
            Коли стан або пропси компонента змінюються,
            відбувається оновлення та повторний рендер JSX.
            Іншими словами, стан - це реактивні дані, які
            контролюють те, що відображається в інтерфейсі.
          </p>
          <p class="m-bottom-min">
            Зміна стану компонента ніколи не впливає на його
            батьків чи сусідів, а тільки на його дочірні
            елементи.
          </p>
          <p>Отже:</p>
          <ul class="m-bottom-min">
            <li>
              у стані зберігається мінімально необхідний
              набір даних, на основі яких можна обчислити
              все необхідне для рендеру інтерфейсу;
            </li>
            <li>
              у стані може зберігатися будь-який тип даних;
            </li>
            <li>
              стан може змінюватися відповідно до дій
              користувача;
            </li>
            <li>
              під час зміни стану компонент повертає
              оновлену розмітку і змінює інтерфейс.
            </li>
          </ul>
          <div class="m-bottom-min border-box">
            <p><b>Важливо!</b></p>
            <ul class="m-bottom-min">
              <li>
                Локальні змінні не зберігаються між
                рендерами. Коли React рендерить компонент
                вдруге, він рендерить його з нуля — не
                враховує жодних змін у локальних змінних.
              </li>
              <li>
                Зміни локальних змінних не викликають
                повторних рендерів. React не усвідомлює
                необхідності повторного рендерингу
                компонента з новими даними.
              </li>
            </ul>
            <p>
              Для оновлення компонента новими даними
              потрібно:
            </p>
            <ul class="">
              <li>зберегти дані між рендерами;</li>
              <li>
                заставити React рендерити компонент з новими
                даними (повторний рендеринг).
              </li>
            </ul>
          </div>
          <p>
            Станом компонента можна керувати за допомогою
            <b>хука</b> <b>useState</b>.
          </p>
        </div>
      </div>
    </section>
  </body>
</html>
